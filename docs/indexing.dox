/** \file

\internal

\page nchashmap Indexed Access to Metadata Objects

\tableofcontents

The original internal representations of metadata in memory
relied on linear searching of lists to locate various objects
by name or by numeric id (e.g. "varid" or "grpid").

In recent years, the flaws in that approach have become obvious
as users create files with extremely large numbers of objects:
group, variables, attributes, and dimensions. One case
has 14 megabytes of metadata. Creating and (especially) later
opening such files was exceedingly slow.

This problem was partially alleviated in both netcdf-3 (libsrc)
and netcdf-4 (libsrc4) by adding name hashing tables.
However, and especially for netcdf-4, linear search still prevailed.

A pervasive change has been made to try to remove (almost) all
occurrences of linear search and replace it with either hashing
(for name-based lookup) or vectors (for numeric id-based
lookup).  The cases left as linear search include these.

1. Enum constants for an enumeration
2. Dimensions associated with a variable
3. Fields of Compound types
4. Searches when we have neither the id nor the name of an object.

This document describes the architecture and details of the netCDF
internal object lookup mechanisms now in place.

\section S1 Indexed Searches

There are, as a rule, two searches that are used to locate
metadata object: (1) search by name and (2) search by
externally visible id (e.g. dimid or varid).

It is currently the case that after all the metadata is read or created,
hashing is used for locating objects by name. In all other
cases -- apparently -- lookup is by linear search of some
kind of linked list or a vector.

It is relevant that, once created, no metadata object -- except
attributes -- can be deleted.  They can be renamed, but that
does not change the associated structure or id.  Deletion only
occurs when an error occurs in creating an object or on invoking
"nc_close()".

The numeric identifiers for dimensions, types, and groups are
all globally unique across a file.  But note that variable id's
are not globally unique (IMO a bad design decision) but are only
unique within the containing group.  Thus, in order to provide a
unique id for a variable it must be composed of the containing
group id plus the variable id.

Note also that names are unique only within a group and with respect
to some kind of metadata. That is a group cannot have e.g. two
dimensions with the same name. But it can have a variable and a dimension
with the same name (as with coordinate variables).

Finally, attribute names are unique only with respect to each other
and with respect to the containing object (a variable or a group).

\section S2 Basic Data Structures

The basic data structures used by the new lookup mechanisms
are described in the following sections.

\subsection SS1_1 NClist

With rare exceptions, vectors of objects are maintained as
instances of NClist, which provides a dynamically extendible
vector of pointers: pointers to metadata objects in this case.
It is possible to append new objects or insert at a specific
vector offset, or overwrite an existing pointer at a specific
offset.

The NClist structure definition is as follows.

\code
typedef struct NClist {
  size_t alloc;
  size_t length;
  void** content;
} NClist;
\endcode

\subsection SS1_2 NC_hashmap

The NC_hashmap type is a hash table mapping a sequence of bytes
(the key) to a data item. As a rule, the data item is a pointer to a
metadata object.  The current implementation supports table
expansion when the # of entries in the table starts to get too
large. Basically a simple linear rehash is used for collisions
and no separate hash-chain is used.  This means that when
expanded, it must be completely rebuilt. The performance hit for
this has yet to be determined. The alternative is to move to some
form of extendible hashing as used in databases.

The hashtable definition is as follows.

\code
typedef struct NC_hashmap {
  size_t size;
  size_t count;
  NC_hentry* table;
} NC_hashmap;
\endcode

where size is the current allocated size and count is the
number of active entries in the table. The "table" field is 
a vector of entries of this form.

\code
typedef struct NC_hentry {
    int flags;
    uintptr_t data;
    unsigned int hashkey;
    size_t keysize;
    uintptr_t key;
} NC_hentry;
\endcode

The flags indicate the state of the entry and can be one of three states:

1. ACTIVE - there is an object referenced in this entry
2. DELETED - an entry was deleted, but must be marked so
   that linear rehash will work.
3. EMPTY - unused

The "data" field is of type "uintptr_t". Note that we assume
that sizeof(unintptr_t) == sizeof(void*). This is very
important.  It is supposed to be the case that a value of type
uintptr_t is an integer of sufficient size to hold a void* pointer.

This means that the data field can hold an unsigned integer or a
void* pointer. As a pointer, it often points to an instance of a
variable, or dimension, or other object.

The hashkey field is a CRC32 hash of the key. Note that comparing
hashkeys is not sufficient to ensure that the corresponding keys are
the same because hash collisions are possible. Even moving to, say,
64 bit keys, is probably not sufficient to avoid hash collisions.
A 128 bit key might (e.g. MD5) might be sufficient but mathematical
investigation would be required.

Since comparing hash keys is not sufficient, it is necessary to store
a reference to the actual key. The key and keysize fields are used for this.
Again note that the key is of uintptr_t type.

There are some rather nasty hacks associated with storing of the key.

1. If the keysize <= sizeof(uintptr_t), then the actual key is stored
   in the key field.
2. Otherwise, a pointer to the key is stored in the key field. It is important
   to note that this is NOT a copy of the incoming key, but is the key pointer itself.
   Usually this will be the name of a metadata object stored in the metadata structure
   (e.g. NC_DIM_INFO_T). This places restraints on the renaming or deletion of
   metadata objects since the key in the hash table may be incorrect. 

\subsection SS1_3 NC_listmap

A listmap is a combination of an NClist and an NC_hashmap instances.
A listmap is used to provide several kinds of lookup with respect to a
specific list of metadata objects. For example, the subgroups
of a group are stored using a vector of pointers to the subgroup objects.
This also provides information about creation order, which is sometimes
important.
However, we often need fast access to that vector by name
so a list map provides these capabilities.

1. A vector into which the object pointers can be stored
   and iterated over.
2. A map from name to the corresponding object index in the vector.

Note that currently, NC_listmap is only used in libsrc4,
but if performance issues warrant, it will also be used in
libsrc.

\section S3 Global Object Access

As mentioned, dimension, group, and type external id's (dimid,
grpid, typeid) are unique across the whole file. It is therefore
convenient to store in memory a per-file vector for each object
type such that the external id of the object is the same as the
position of that object in the corresponding per-file
vector. This makes lookup by external id efficient.
Note that this is was already the case for netcdf-3 (libsrc) so
this is a change for libsrc4 only.

The global set of dimensions, types, and groups is maintained by
three instances of NClist in the NC_HDF5_FILE_INFO structure:
namely alldims, alltypes, and allgroups.
The position of the object within the corresponding list determines
the object's external id. Thus, a position of a dimension object within the
"alldims" field of the file structure determines its dimid. Similarly
for types and groups.

\section S4 Per-Group Object Access

Each group object (NC_GRP_INFO) contains five instances of
NC_listmap. One is for dimensions, one is for types, one is for
subgroups, one is for variables, and one is for attributes.  A
listmap is used for two reasons. First, it allows name-based lookup
for these items. Second, the declaration order is maintained by
the list within the listmap's vector. Note that the position of
an object in a group listmap vector has no necessary
relationship to the position of that object within the global
vectors.

Note however that the listmap vector for variables does define
the variable id, which is unique only within a group.
In this special case, the external id for the variable is
the same as its offset in the listmap's vector for the group.

A note about typeids. Since user defined types have an external
id starting at NC_FIRSTUSERTYPEID, we leave the global type
vector entries 0..NC_FIRSTUSERTYPEID-1 empty.

\section S6 Metadata Object Header

Each metadata object (e.g. NC_DIM_INFO_T, NC_VAR_INFO_T)
now has what is called a "hdr" object as its first field.
This provides a form of pseudo-inheritance for these objects
because they can all be cast to "NC_OBJ" to get common information.
The structure of the header is as follows.

\code
typedef struct NC_OBJ {
    NC_SORT sort;
    char* name; /* assumed to be null terminated */
    size_t id;
} NC_OBJ;
\endcode

The sort is one of the values NCVAR, NCDIM, NCATT, NCTYP, or NCGRP.
The name is assumed to be nul terminated. The id is the assigned id
for the object.

\section S5 Implementation Alternatives.

1. As an alternative to the use of the alldims, allgrps, etc.,
vectors, we could use a listmap that maps the object id to
the vector index of the object with that id. This would allow
us to have holes in the object id space and still have O(1)
access time. This would require keeping (as it was before)
various object id counters.

\section S6 Notes and Warning

1. NC_Listmap is currently not used for enum constants and compound fields.
Additionally, it is not used for listing the dimensions associated
with a variable.
2. References between meta-data objects (e.g. group parent or
containing group) are stored directly and not using any kind
of vector or hashtable.
3. Attribute deletion is still a costly operation because it causes
   the whole attribute listmap to be rebuilt.
4. Renaming is still a costly operation because it causes
   the whole containing listmap to be rebuilt.

\section Provenance

__Author__: Dennis Heimbigner<br>
__Initial Version__: 01/10/2018<br>
__Last Revised__: 02/24/2018

*/
