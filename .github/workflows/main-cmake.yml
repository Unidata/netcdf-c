name: NetCDF-C CMake CI - Windows

on: [ pull_request, workflow_dispatch]

env:
  REMOTETESTDOWN: ${{ vars.REMOTETESTDOWN }}

concurrency:  
  group: ${{ github.workflow }}-${{ github.head_ref }}  
  cancel-in-progress: true
  
jobs:

  cmake_build_and_test:
    strategy:
      
        matrix:
            name: 
                - "Windows MSVC"
            hdf5:
                - "1.14.3"

            # Visual Studio + CMake
            include:
                - name: "Windows MSVC"
                  os: windows-latest
                  generator: "-G  \"Visual Studio 17 2022\""

    name: "${{ matrix.name }}"
        
    runs-on: ${{ matrix.os }}

    # Each step in the job.
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    steps:
        - uses: msys2/setup-msys2@v2
          with:
            update: true
        - uses: actions/checkout@v4
        - uses: conda-incubator/setup-miniconda@v3
          with:
            miniconda-version: "latest"
            activate-environment: ""
            auto-activate-base: true

        - name: Set up Paths and env
          shell: bash -el {0}
          run: |
            echo "" >> ~/.bash_profile
            cat ~/.bash_profile


        - name: Dump Matrix Context
          run: echo '${{ toJSON(matrix) }}'

        #- run: echo "CMAKE_PREFIX_PATH=${env.CONDA_PREFIX}/Library" >> $GITHUB_ENV
        #- run: echo "/c/Users/runneradmin/miniconda3/Library/lib:${GITHUB_PATH}" >> $GITHUB_ENV
        #- run: echo ""
        #- run: echo "CTEST_OUTPUT_ON_FAILURE=1" >> $GITHUB_ENV
       
        # Grab miniconda and use it to install HDF5
        - name: Install Dependencies using Miniconda
          run: |
            conda config --set always_yes yes --set changeps1 no --set show_channel_urls true
            conda config --add channels conda-forge
            conda update conda
            conda install hdf5=${{ matrix.hdf5 }} m2-m4 libxml2
          shell: bash -el {0}

        # Double-check something
        - name: Check Miniconda
          run: |
            which h5dump
            which m4
          shell: bash -el {0}
     
        # Check current directory
        - name: Query Current Environment
          run: |
            ls 
            echo ""
            echo "PATH: $PATH"
            echo ""
            env
            echo ""
            ls $CONDA_PREFIX/Library
            echo ""
            ls $CONDA_PREFIX/Library/include/
          shell: bash -el {0}

        - name: Perform out-of-directory configuration
          shell: bash -el {0}
          run: |
            mkdir build
            cd build
            cmake .. -DCMAKE_PREFIX_PATH="${CONDA_PREFIX}/Library" -DCMAKE_C_FLAGS="-I${CONDA_PREFIX}/Library/include" -DCMAKE_INSTALL_PREFIX=~/tmp -DNETCDF_ENABLE_FILTER_TESTING=OFF
          if: ${{ success() }}

        - name: View cache - configuration
          shell: bash -el {0}
          run: |
            cd build
            cmake -L .
          if: ${{ success() }}

        - name: Print Summary
          shell: bash -el {0}
          run: |
            cd build
            cat libnetcdf.settings  

        - name: Perform out-of-directory build - libnetcdf
          shell: bash -el {0}
          run: |
            cd build
            cmake --build . --config Release --target netcdf -j 4

        # The install step may fail on Windows (e.g. permission errors or
        # missing paths) but that should not block the test-suite build or
        # ctest run.  Use continue-on-error so subsequent steps still execute.
        - name: Perform out-of-directory install - libnetcdf
          shell: bash -el {0}
          run: |
            cd build
            cmake --build . --config Release --target install -j 4
          continue-on-error: true

        - name: View config.h - libnetcdf failure
          shell: bash -el {0}
          run: |
            cd build
            cat config.h
          if: ${{ failure() }}

        # id: build_tests is referenced by the ctest step's 'if' condition
        # so that ctest only runs when the full build succeeds.
        - name: Perform out-of-directory build - test suite
          id: build_tests
          shell: bash -el {0}
          run: | 
            cd build
            cmake --build . --config Release -j 4
      
        - name: View config.h - tests failure failure
          shell: bash -el {0}
          run: |
            cd build
            cat config.h
          if: ${{ failure() }}  

        # On Windows, test executables need DLLs (netcdf.dll, hdf5.dll,
        # etc.) on PATH at runtime.  Without this step, ctest fails with
        # 0xc0000135 (STATUS_DLL_NOT_FOUND).  We add three directories:
        #   1. Conda Library/bin  – hdf5.dll, zlib.dll, libcurl.dll, etc.
        #   2. Install bin        – netcdf.dll from the install step
        #   3. Build liblib dir   – netcdf.dll from the build tree
        # Writing to $GITHUB_PATH makes the additions visible to all
        # subsequent steps.  Runs with if: always() so the PATH is set
        # even if the install step failed (continue-on-error above).
        - name: Add DLL directories to PATH
          if: always()
          shell: powershell
          run: |
            # conda Library/bin – hdf5.dll, zlib.dll, libcurl.dll, etc.
            $condaBin = "$env:CONDA\Library\bin"
            Write-Host "Adding to PATH: $condaBin"
            $condaBin | Out-File -Append -FilePath $env:GITHUB_PATH -Encoding utf8
            # Install prefix bin – netcdf.dll placed by 'cmake --install'
            $installBin = "$env:USERPROFILE\tmp\bin"
            Write-Host "Adding to PATH: $installBin"
            $installBin | Out-File -Append -FilePath $env:GITHUB_PATH -Encoding utf8
            # Build tree – netcdf.dll built in liblib/Release
            $buildLib = "D:\a\netcdf-c\netcdf-c\build\liblib\Release"
            Write-Host "Adding to PATH: $buildLib"
            $buildLib | Out-File -Append -FilePath $env:GITHUB_PATH -Encoding utf8
            Write-Host ""
            Write-Host "=== GITHUB_PATH contents ==="
            Get-Content $env:GITHUB_PATH

        # Only run ctest when the full build succeeded (see id: build_tests).
        # Uses PowerShell instead of bash because bash on Windows has trouble
        # with DLL PATH resolution and tilde expansion for the install prefix.
        # The -E exclusion pattern skips tests that rely on:
        #   bom           – byte-order-mark tests that need Unix utilities
        #   run_          – shell-script-based tests (bash .sh) that are
        #                   not portable to the Windows MSVC environment
        #   tst_ncdap     – remote OPeNDAP tests (network-dependent)
        #   dap4_test_test_ – remote DAP4 tests (network-dependent)
        #   do_comps      – comparison script tests requiring Unix tools
        - name: Run ctest
          if: ${{ steps.build_tests.outcome == 'success' }}
          shell: powershell
          run: |
            cd build
            ctest . -j 4 -E "bom|run_|tst_ncdap|dap4_test_test_|do_comps" --output-on-failure
            if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
            
        # Re-run only the failed tests with maximum verbosity (-VV) to
        # capture detailed output for debugging.  Uses PowerShell to match
        # the ctest step above (same DLL PATH / shell environment).
        - name: Verbose Output if CTest Failure
          shell: powershell
          run: |
            cd build
            ctest . --rerun-failed --output-on-failure -VV
          if: ${{ failure() }}    
