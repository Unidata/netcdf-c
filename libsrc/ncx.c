#line 11 "ncx.m4"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 13
/*
 *	Copyright 1996, University Corporation for Atmospheric Research
 *	See netcdf/COPYRIGHT file for copying and redistribution conditions.
 *
 * 	This file contains some routines derived from code
 *	which is copyrighted by Sun Microsystems, Inc.
 *	The "#ifdef vax" versions of
 *		 ncx_put_float_float()
 *		 ncx_get_float_float()
 *		 ncx_put_double_double()
 *		 ncx_get_double_double()
 *		 ncx_putn_float_float()
 *		 ncx_getn_float_float()
 *		 ncx_putn_double_double()
 *		 ncx_getn_double_double()
 * 	are derived from xdr_float() and xdr_double() routines
 *	in the freely available, copyrighted Sun RPCSRC 3.9
 *	distribution, xdr_float.c.
 * 	Our "value added" is that these are always memory to memory,
 *	they handle IEEE subnormals properly, and their "n" versions
 *	operate speedily on arrays.
 */
/* $Id: ncx.m4,v 2.58 2010/05/26 18:11:08 dmh Exp $ */

/*
 * An external data representation interface.
 */

#include "ncx.h"
#include "nc3dispatch.h"
#include <string.h>
#include <limits.h>

/* alias poorly named limits.h macros */
#define  SHORT_MAX  SHRT_MAX
#define  SHORT_MIN  SHRT_MIN
#define USHORT_MAX USHRT_MAX
#ifndef LLONG_MAX
#   define LLONG_MAX	9223372036854775807LL
#   define LLONG_MIN	(-LLONG_MAX - 1LL)
#   define ULLONG_MAX	18446744073709551615ULL
#endif
#ifndef LONG_LONG_MAX
#define LONG_LONG_MAX LLONG_MAX
#endif
#ifndef LONG_LONG_MIN
#define LONG_LONG_MIN LLONG_MIN
#endif
#ifndef ULONG_LONG_MAX
#define ULONG_LONG_MAX ULLONG_MAX
#endif
#include <float.h>
#ifndef FLT_MAX /* This POSIX macro missing on some systems */
# ifndef NO_IEEE_FLOAT
# define FLT_MAX 3.40282347e+38f
# else
# error "You will need to define FLT_MAX"
# endif
#endif
/* alias poorly named float.h macros */
#define FLOAT_MAX FLT_MAX
#define FLOAT_MIN (-FLT_MAX)
#define DOUBLE_MAX DBL_MAX
#define DOUBLE_MIN (-DBL_MAX)
#define FLOAT_MAX_EXP FLT_MAX_EXP
#define DOUBLE_MAX_EXP DBL_MAX_EXP
#include <assert.h>
#define UCHAR_MIN 0
#define Min(a,b) ((a) < (b) ? (a) : (b))
#define Max(a,b) ((a) > (b) ? (a) : (b))

/*
 * If the machine's float domain is "smaller" than the external one
 * use the machine domain
 */
#if defined(FLT_MAX_EXP) && FLT_MAX_EXP < 128 /* 128 is X_FLT_MAX_EXP */
#undef X_FLOAT_MAX
# define X_FLOAT_MAX FLT_MAX
#undef X_FLOAT_MIN
# define X_FLOAT_MIN (-X_FLOAT_MAX)
#endif

#if _SX /* NEC SUPER UX */
#define LOOPCNT 256    /* must be no longer than hardware vector length */
#if _INT64
#undef  INT_MAX /* workaround cpp bug */
#define INT_MAX  X_INT_MAX
#undef  INT_MIN /* workaround cpp bug */
#define INT_MIN  X_INT_MIN
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  X_INT_MAX
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN  X_INT_MIN
#elif _LONG64
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  4294967295L
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN -4294967295L
#endif
#if !_FLOAT0
#error "FLOAT1 and FLOAT2 not supported"
#endif
#endif /* _SX */

static const char nada[X_ALIGN] = {0, 0, 0, 0};

#ifndef WORDS_BIGENDIAN
/* LITTLE_ENDIAN: DEC and intel */
/*
 * Routines to convert to BIGENDIAN.
 * Optimize the swapn?b() and swap?b() routines aggressivly.
 */

#define SWAP2(a) ( (((a) & 0xff) << 8) | \
		(((a) >> 8) & 0xff) )

#define SWAP4(a) ( ((a) << 24) | \
		(((a) <<  8) & 0x00ff0000) | \
		(((a) >>  8) & 0x0000ff00) | \
		(((a) >> 24) & 0x000000ff) )


static void
swapn2b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *
 *	while(nn-- != 0)
 *	{
 *		*op++ = *(++ip);
 *		*op++ = *(ip++ -1);
 *	}
 */
	while(nn > 3)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		nn -= 4;
	}
	while(nn-- != 0)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
	}
}

# ifndef vax
void
swap4b(void *dst, const void *src)
{
    unsigned int *op = dst;
    const char *ip = src;
    unsigned int tempIn;
    unsigned int tempOut;

    tempIn = *(unsigned int *)(ip+0);
    tempOut =
    ( tempIn << 24) |
    ((tempIn & 0x0000ff00) << 8) |
    ((tempIn & 0x00ff0000) >> 8) |
    ( tempIn >> 24);

    *(float *)op = *(float *)(&tempOut);
}
# endif /* !vax */

static void
swapn4b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[3];
 *		op[1] = ip[2];
 *		op[2] = ip[1];
 *		op[3] = ip[0];
 *		op += 4;
 *		ip += 4;
 *	}
 */
	while(nn > 3)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op[8] = ip[11];
		op[9] = ip[10];
		op[10] = ip[9];
		op[11] = ip[8];
		op[12] = ip[15];
		op[13] = ip[14];
		op[14] = ip[13];
		op[15] = ip[12];
		op += 16;
		ip += 16;
		nn -= 4;
	}
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op += 4;
		ip += 4;
	}
}

# ifndef vax
static void
swap8b(void *dst, const void *src)
{
	char *op = dst;
	const char *ip = src;
#  ifndef FLOAT_WORDS_BIGENDIAN
	op[0] = ip[7];
	op[1] = ip[6];
	op[2] = ip[5];
	op[3] = ip[4];
	op[4] = ip[3];
	op[5] = ip[2];
	op[6] = ip[1];
	op[7] = ip[0];
#  else
	op[0] = ip[3];
	op[1] = ip[2];
	op[2] = ip[1];
	op[3] = ip[0];
	op[4] = ip[7];
	op[5] = ip[6];
	op[6] = ip[5];
	op[7] = ip[4];
#  endif
}
# endif /* !vax */

# ifndef vax
static void
swapn8b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[7];
 *		op[1] = ip[6];
 *		op[2] = ip[5];
 *		op[3] = ip[4];
 *		op[4] = ip[3];
 *		op[5] = ip[2];
 *		op[6] = ip[1];
 *		op[7] = ip[0];
 *		op += 8;
 *		ip += 8;
 *	}
 */
#  ifndef FLOAT_WORDS_BIGENDIAN
	while(nn > 1)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op[8] = ip[15];
		op[9] = ip[14];
		op[10] = ip[13];
		op[11] = ip[12];
		op[12] = ip[11];
		op[13] = ip[10];
		op[14] = ip[9];
		op[15] = ip[8];
		op += 16;
		ip += 16;
		nn -= 2;
	}
	while(nn-- != 0)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op += 8;
		ip += 8;
	}
#  else
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op += 8;
		ip += 8;
	}
#  endif
}
# endif /* !vax */

#endif /* LITTLE_ENDIAN */


/*
 * Primitive numeric conversion functions.
 */

/* x_schar */

/* We don't implement any x_schar primitives. */


/* x_short */

#if SHORT_MAX == X_SHORT_MAX
typedef short ix_short;
#define SIZEOF_IX_SHORT SIZEOF_SHORT
#define IX_SHORT_MAX SHORT_MAX
#elif INT_MAX >= X_SHORT_MAX
typedef int ix_short;
#define SIZEOF_IX_SHORT SIZEOF_INT
#define IX_SHORT_MAX INT_MAX
#elif LONG_MAX >= X_SHORT_MAX
typedef long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG
#define IX_SHORT_MAX LONG_MAX
#elif LLONG_MAX >= X_SHORT_MAX
typedef long long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG_LONG
#define IX_SHORT_MAX LLONG_MAX
#else
#error "ix_short implementation"
#endif

static void
get_ix_short(const void *xp, ix_short *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if(*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= *cp;
}

static void
put_ix_short(void *xp, const ix_short *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (*ip) >> 8;
	*cp = (*ip) & 0xff;
}


int
ncx_get_short_schar(const void *xp, schar *ip)
{
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_short_uchar(const void *xp, uchar *ip)
{
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
	if(xx > UCHAR_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_short_short(const void *xp, short *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
	get_ix_short(xp, (ix_short *)ip);
	return ENOERR;
#else
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
#   if IX_SHORT_MAX > SHORT_MAX
	if(xx > SHORT_MAX || xx < SHORT_MIN)
		return NC_ERANGE;
#   endif
	return ENOERR;
#endif
}

int
ncx_get_short_int(const void *xp, int *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
	get_ix_short(xp, (ix_short *)ip);
	return ENOERR;
#else
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
#   if IX_SHORT_MAX > INT_MAX
	if(xx > INT_MAX || xx < INT_MIN)
		return NC_ERANGE;
#   endif
	return ENOERR;
#endif
}

int
ncx_get_short_uint(const void *xp, unsigned int *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
	get_ix_short(xp, (ix_short *)ip);
	return ENOERR;
#else
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
#   if IX_SHORT_MAX > INT_MAX
	if(xx > UINT_MAX || xx < 0)
		return NC_ERANGE;
#   endif
	return ENOERR;
#endif
}

int
ncx_get_short_longlong(const void *xp, long long *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_LONG_LONG && IX_SHORT_MAX == LONG_LONG_MAX
	get_ix_short(xp, (ix_short *)ip);
	return ENOERR;
#else
	/* assert(LONG_LONG_MAX >= X_SHORT_MAX); */
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
	return ENOERR;
#endif
}

int
ncx_get_short_ulonglong(const void *xp, unsigned long long *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_LONG && IX_SHORT_MAX == LONG_MAX
	get_ix_short(xp, (ix_short *)ip);
	return ENOERR;
#else
	/* assert(LONG_LONG_MAX >= X_SHORT_MAX); */
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
	if(xx < 0)
		return NC_ERANGE;
	return ENOERR;
#endif
}

int
ncx_get_short_float(const void *xp, float *ip)
{
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
#if 0	/* TODO: determine when necessary */
	if(xx > FLT_MAX || xx < (-FLT_MAX))
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_get_short_double(const void *xp, double *ip)
{
	/* assert(DBL_MAX >= X_SHORT_MAX); */
	ix_short xx;
	get_ix_short(xp, &xx);
	*ip = xx;
	return ENOERR;
}

int
ncx_put_short_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
	return ENOERR;
}

int
ncx_put_short_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return ENOERR;
}

int
ncx_put_short_short(void *xp, const short *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && X_SHORT_MAX == SHORT_MAX
	put_ix_short(xp, (const ix_short *)ip);
	return ENOERR;
#else
	ix_short xx = (ix_short)*ip;
	put_ix_short(xp, &xx);
# if X_SHORT_MAX < SHORT_MAX
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
		return NC_ERANGE;
# endif
	return ENOERR;
#endif
}

int
ncx_put_short_int(void *xp, const int *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_INT && X_SHORT_MAX == INT_MAX
	put_ix_short(xp, (const ix_short *)ip);
	return ENOERR;
#else
	ix_short xx = (ix_short)*ip;
	put_ix_short(xp, &xx);
# if X_SHORT_MAX < INT_MAX
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
		return NC_ERANGE;
# endif
	return ENOERR;
#endif
}

int
ncx_put_short_uint(void *xp, const unsigned int *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_INT && X_SHORT_MAX == INT_MAX
	put_ix_short(xp, (const ix_short *)ip);
	return ENOERR;
#else
	ix_short xx = (ix_short)*ip;
	put_ix_short(xp, &xx);
# if X_SHORT_MAX < INT_MAX
	if(*ip > X_SHORT_MAX)
		return NC_ERANGE;
# endif
	return ENOERR;
#endif
}

int
ncx_put_short_longlong(void *xp, const long long *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_LONG_LONG && X_SHORT_MAX == LONG_LONG_MAX
	put_ix_short(xp, (const ix_short *)ip);
	return ENOERR;
#else
	ix_short xx = (ix_short)*ip;
	put_ix_short(xp, &xx);
# if X_SHORT_MAX < LONG_LONG_MAX
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
		return NC_ERANGE;
# endif
	return ENOERR;
#endif
}

int
ncx_put_short_ulonglong(void *xp, const unsigned long long *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_LONG_LONG && X_SHORT_MAX == LONG_LONG_MAX
	put_ix_short(xp, (const ix_short *)ip);
	return ENOERR;
#else
	ix_short xx = (ix_short)*ip;
	put_ix_short(xp, &xx);
# if X_SHORT_MAX < LONG_LONG_MAX
	if(*ip > X_SHORT_MAX)
		return NC_ERANGE;
# endif
	return ENOERR;
#endif
}

int
ncx_put_short_float(void *xp, const float *ip)
{
	ix_short xx = *ip;
	put_ix_short(xp, &xx);
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_put_short_double(void *xp, const double *ip)
{
	ix_short xx = *ip;
	put_ix_short(xp, &xx);
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

/* x_int */

#if SHORT_MAX == X_INT_MAX
typedef short ix_int;
#define SIZEOF_IX_INT SIZEOF_SHORT
#define IX_INT_MAX SHORT_MAX
#elif INT_MAX  >= X_INT_MAX
typedef int ix_int;
#define SIZEOF_IX_INT SIZEOF_INT
#define IX_INT_MAX INT_MAX
#elif LONG_MAX  >= X_INT_MAX
typedef long ix_int;
#define SIZEOF_IX_INT SIZEOF_LONG
#define IX_INT_MAX LONG_MAX
#else
#error "ix_int implementation"
#endif


static void
get_ix_int(const void *xp, ix_int *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
#if SIZEOF_IX_INT > X_SIZEOF_INT
	if(*ip & 0x80000000)
	{
		/* extern is negative */
		*ip |= (~(0xffffffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp;
}

static void
put_ix_int(void *xp, const ix_int *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (*ip) >> 24;
	*cp++ = ((*ip) & 0x00ff0000) >> 16;
	*cp++ = ((*ip) & 0x0000ff00) >>  8;
	*cp   = ((*ip) & 0x000000ff);
}


int
ncx_get_int_schar(const void *xp, schar *ip)
{
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_int_uchar(const void *xp, uchar *ip)
{
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
	if(xx > UCHAR_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_int_short(const void *xp, short *ip)
{
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
	get_ix_int(xp, (ix_int *)ip);
	return ENOERR;
#else
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
#  if IX_INT_MAX > SHORT_MAX
	if(xx > SHORT_MAX || xx < SHORT_MIN)
		return NC_ERANGE;
#  endif
	return ENOERR;
#endif
}

int
ncx_get_int_int(const void *xp, int *ip)
{
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
	get_ix_int(xp, (ix_int *)ip);
	return ENOERR;
#else
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
#  if IX_INT_MAX > INT_MAX
	if(xx > INT_MAX || xx < INT_MIN)
		return NC_ERANGE;
#  endif
	return ENOERR;
#endif
}

int
ncx_get_int_uint(const void *xp, unsigned int *ip)
{
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
	if(xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_int_longlong(const void *xp, long long *ip)
{
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
	return ENOERR;
}

int
ncx_get_int_ulonglong(const void *xp, unsigned long long *ip)
{
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
	if(xx < 0)
	      return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_int_float(const void *xp, float *ip)
{
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
#if 0	/* TODO: determine when necessary */
	if(xx > FLT_MAX || xx < (-FLT_MAX))
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_get_int_double(const void *xp, double *ip)
{
	/* assert((DBL_MAX >= X_INT_MAX); */
	ix_int xx;
	get_ix_int(xp, &xx);
	*ip = xx;
	return ENOERR;
}

int
ncx_put_int_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
	{
		*cp++ = 0xff;
		*cp++ = 0xff;
		*cp++ = 0xff;
	}
	else
	{
		*cp++ = 0x00;
		*cp++ = 0x00;
		*cp++ = 0x00;
	}
	*cp = (uchar)*ip;
	return ENOERR;
}

int
ncx_put_int_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return ENOERR;
}

int
ncx_put_int_short(void *xp, const short *ip)
{
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
	put_ix_int(xp, (ix_int *)ip);
	return ENOERR;
#else
	ix_int xx = (ix_int)(*ip);
	put_ix_int(xp, &xx);
#   if IX_INT_MAX < SHORT_MAX
	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
		return NC_ERANGE;
#   endif
	return ENOERR;
#endif
}

int
ncx_put_int_int(void *xp, const int *ip)
{
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
	put_ix_int(xp, (ix_int *)ip);
	return ENOERR;
#else
	ix_int xx = (ix_int)(*ip);
	put_ix_int(xp, &xx);
#   if IX_INT_MAX < INT_MAX
	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
		return NC_ERANGE;
#   endif
	return ENOERR;
#endif
}

int
ncx_put_int_uint(void *xp, const unsigned int *ip)
{
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
	put_ix_int(xp, (ix_int *)ip);
	return ENOERR;
#else
	ix_int xx = (ix_int)(*ip);
	put_ix_int(xp, &xx);
	if(*ip > X_UINT_MAX)
		return NC_ERANGE;
	return ENOERR;
#endif
}

int
ncx_put_int_longlong(void *xp, const longlong *ip)
{
#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
	put_ix_int(xp, (ix_int *)ip);
	return ENOERR;
#else
	ix_int xx = (ix_int)(*ip);
	put_ix_int(xp, &xx);
#   if IX_INT_MAX < LONG_LONG_MAX
	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
		return NC_ERANGE;
#   endif
	return ENOERR;
#endif
}

int
ncx_put_int_ulonglong(void *xp, const unsigned long long *ip)
{
#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
	put_ix_int(xp, (ix_int *)ip);
	return ENOERR;
#else
	ix_int xx = (ix_int)(*ip);
	put_ix_int(xp, &xx);
#   if IX_INT_MAX < LONG_MAX
	if(*ip > X_INT_MAX)
		return NC_ERANGE;
#   endif
	return ENOERR;
#endif
}

int
ncx_put_int_float(void *xp, const float *ip)
{
	ix_int xx = (ix_int)(*ip);
	put_ix_int(xp, &xx);
	if(*ip > (double)X_INT_MAX || *ip < (double)X_INT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_put_int_double(void *xp, const double *ip)
{
	ix_int xx = (ix_int)(*ip);
	put_ix_int(xp, &xx);
	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
		return NC_ERANGE;
	return ENOERR;
}


/* x_float */

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)

static void
get_ix_float(const void *xp, float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(float));
#else
	swap4b(ip, xp);
#endif
}

static void
put_ix_float(void *xp, const float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_FLOAT);
#else
	swap4b(xp, ip);
#endif
}

#elif vax

/* What IEEE single precision floating point looks like on a Vax */
struct	ieee_single {
	unsigned int	exp_hi       : 7;
	unsigned int	sign         : 1;
	unsigned int 	mant_hi      : 7;
	unsigned int	exp_lo       : 1;
	unsigned int	mant_lo_hi   : 8;
	unsigned int	mant_lo_lo   : 8;
};

/* Vax single precision floating point */
struct	vax_single {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
};

#define VAX_SNG_BIAS	0x81
#define IEEE_SNG_BIAS	0x7f

static struct sgl_limits {
	struct vax_single s;
	struct ieee_single ieee;
} max = {
	{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0x1, 0x0, 0x0 }		/* Max IEEE */
};
static struct sgl_limits min = {
	{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }		/* Min IEEE */
};

#line 1064
static void
get_ix_float(const void *xp, float *ip)
{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 1067
		const struct ieee_single *const isp =
#line 1067
			 (const struct ieee_single *) xp;
#line 1067
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 1067

#line 1067
		switch(exp) {
#line 1067
		case 0 :
#line 1067
			/* ieee subnormal */
#line 1067
			if(isp->mant_hi == min.ieee.mant_hi
#line 1067
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 1067
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 1067
			{
#line 1067
				*vsp = min.s;
#line 1067
			}
#line 1067
			else
#line 1067
			{
#line 1067
				unsigned mantissa = (isp->mant_hi << 16)
#line 1067
					 | isp->mant_lo_hi << 8
#line 1067
					 | isp->mant_lo_lo;
#line 1067
				unsigned tmp = mantissa >> 20;
#line 1067
				if(tmp >= 4) {
#line 1067
					vsp->exp = 2;
#line 1067
				} else if (tmp >= 2) {
#line 1067
					vsp->exp = 1;
#line 1067
				} else {
#line 1067
					*vsp = min.s;
#line 1067
					break;
#line 1067
				} /* else */
#line 1067
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 1067
				tmp <<= 3 - vsp->exp;
#line 1067
				vsp->mantissa2 = tmp;
#line 1067
				vsp->mantissa1 = (tmp >> 16);
#line 1067
			}
#line 1067
			break;
#line 1067
		case 0xfe :
#line 1067
		case 0xff :
#line 1067
			*vsp = max.s;
#line 1067
			break;
#line 1067
		default :
#line 1067
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 1067
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 1067
			vsp->mantissa1 = isp->mant_hi;
#line 1067
		}
#line 1067

#line 1067
		vsp->sign = isp->sign;
#line 1067

}

#line 1121

static void
put_ix_float(void *xp, const float *ip)
{
		const struct vax_single *const vsp =
#line 1125
			 (const struct vax_single *)ip;
#line 1125
		struct ieee_single *const isp = (struct ieee_single *) xp;
#line 1125

#line 1125
		switch(vsp->exp){
#line 1125
		case 0 :
#line 1125
			/* all vax float with zero exponent map to zero */
#line 1125
			*isp = min.ieee;
#line 1125
			break;
#line 1125
		case 2 :
#line 1125
		case 1 :
#line 1125
		{
#line 1125
			/* These will map to subnormals */
#line 1125
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 1125
					 | vsp->mantissa2;
#line 1125
			mantissa >>= 3 - vsp->exp;
#line 1125
			mantissa += (1 << (20 + vsp->exp));
#line 1125
			isp->mant_lo_lo = mantissa;
#line 1125
			isp->mant_lo_hi = mantissa >> 8;
#line 1125
			isp->mant_hi = mantissa >> 16;
#line 1125
			isp->exp_lo = 0;
#line 1125
			isp->exp_hi = 0;
#line 1125
		}
#line 1125
			break;
#line 1125
		case 0xff : /* max.s.exp */
#line 1125
			if( vsp->mantissa2 == max.s.mantissa2
#line 1125
				&& vsp->mantissa1 == max.s.mantissa1)
#line 1125
			{
#line 1125
				/* map largest vax float to ieee infinity */
#line 1125
				*isp = max.ieee;
#line 1125
				break;
#line 1125
			} /* else, fall thru */
#line 1125
		default :
#line 1125
		{
#line 1125
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 1125
			isp->exp_hi = exp >> 1;
#line 1125
			isp->exp_lo = exp;
#line 1125
			isp->mant_lo_lo = vsp->mantissa2;
#line 1125
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 1125
			isp->mant_hi = vsp->mantissa1;
#line 1125
		}
#line 1125
		}
#line 1125

#line 1125
		isp->sign = vsp->sign;
#line 1125

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

/*
 * Return the number of bytes until the next "word" boundary
 * N.B. This is based on the very weird YMP address structure,
 * which puts the address within a word in the leftmost 3 bits
 * of the address.
 */
static size_t
word_align(const void *vp)
{
	const size_t rem = ((size_t)vp >> (64 - 3)) & 0x7;
	return (rem != 0);
}

struct ieee_single_hi {
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
	unsigned int	pad	:32;
};
typedef struct ieee_single_hi ieee_single_hi;

struct ieee_single_lo {
	unsigned int	pad	:32;
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
};
typedef struct ieee_single_lo ieee_single_lo;

static const int ieee_single_bias = 0x7f;

struct ieee_double {
	unsigned int	sign	: 1;
	unsigned int	 exp	:11;
	unsigned int	mant	:52;
};
typedef struct ieee_double ieee_double;

static const int ieee_double_bias = 0x3ff;

#if defined(NO_IEEE_FLOAT)

struct cray_single {
	unsigned int	sign	: 1;
	unsigned int	 exp	:15;
	unsigned int	mant	:48;
};
typedef struct cray_single cray_single;

static const int cs_ieis_bias = 0x4000 - 0x7f;

static const int cs_id_bias = 0x4000 - 0x3ff;

#line 1260

static void
get_ix_float(const void *xp, float *ip)
{

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1268

#line 1268
		if(isp->exp == 0)
#line 1268
		{
#line 1268
			/* ieee subnormal */
#line 1268
			*ip = (double)isp->mant;
#line 1268
			if(isp->mant != 0)
#line 1268
			{
#line 1268
				csp->exp -= (ieee_single_bias + 22);
#line 1268
			}
#line 1268
		}
#line 1268
		else
#line 1268
		{
#line 1268
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1268
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1268
			csp->mant |= (1 << (48 - 1));
#line 1268
		}
#line 1268
		csp->sign = isp->sign;
#line 1268

#line 1268

	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1273

#line 1273
		if(isp->exp == 0)
#line 1273
		{
#line 1273
			/* ieee subnormal */
#line 1273
			*ip = (double)isp->mant;
#line 1273
			if(isp->mant != 0)
#line 1273
			{
#line 1273
				csp->exp -= (ieee_single_bias + 22);
#line 1273
			}
#line 1273
		}
#line 1273
		else
#line 1273
		{
#line 1273
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1273
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1273
			csp->mant |= (1 << (48 - 1));
#line 1273
		}
#line 1273
		csp->sign = isp->sign;
#line 1273

#line 1273

	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1283
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1283

#line 1283
	isp->sign = csp->sign;
#line 1283

#line 1283
	if(ieee_exp >= 0xff)
#line 1283
	{
#line 1283
		/* NC_ERANGE => ieee Inf */
#line 1283
		isp->exp = 0xff;
#line 1283
		isp->mant = 0x0;
#line 1283
	}
#line 1283
	else if(ieee_exp > 0)
#line 1283
	{
#line 1283
		/* normal ieee representation */
#line 1283
		isp->exp  = ieee_exp;
#line 1283
		/* assumes cray rep is in normal form */
#line 1283
		assert(csp->mant & 0x800000000000);
#line 1283
		isp->mant = (((csp->mant << 1) &
#line 1283
				0xffffffffffff) >> (48 - 23));
#line 1283
	}
#line 1283
	else if(ieee_exp > -23)
#line 1283
	{
#line 1283
		/* ieee subnormal, right shift */
#line 1283
		const int rshift = (48 - 23 - ieee_exp);
#line 1283

#line 1283
		isp->mant = csp->mant >> rshift;
#line 1283

#line 1283
#if 0
#line 1283
		if(csp->mant & (1 << (rshift -1)))
#line 1283
		{
#line 1283
			/* round up */
#line 1283
			isp->mant++;
#line 1283
		}
#line 1283
#endif
#line 1283

#line 1283
		isp->exp  = 0;
#line 1283
	}
#line 1283
	else
#line 1283
	{
#line 1283
		/* smaller than ieee can represent */
#line 1283
		isp->exp = 0;
#line 1283
		isp->mant = 0;
#line 1283
	}
#line 1283

	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1288
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1288

#line 1288
	isp->sign = csp->sign;
#line 1288

#line 1288
	if(ieee_exp >= 0xff)
#line 1288
	{
#line 1288
		/* NC_ERANGE => ieee Inf */
#line 1288
		isp->exp = 0xff;
#line 1288
		isp->mant = 0x0;
#line 1288
	}
#line 1288
	else if(ieee_exp > 0)
#line 1288
	{
#line 1288
		/* normal ieee representation */
#line 1288
		isp->exp  = ieee_exp;
#line 1288
		/* assumes cray rep is in normal form */
#line 1288
		assert(csp->mant & 0x800000000000);
#line 1288
		isp->mant = (((csp->mant << 1) &
#line 1288
				0xffffffffffff) >> (48 - 23));
#line 1288
	}
#line 1288
	else if(ieee_exp > -23)
#line 1288
	{
#line 1288
		/* ieee subnormal, right shift */
#line 1288
		const int rshift = (48 - 23 - ieee_exp);
#line 1288

#line 1288
		isp->mant = csp->mant >> rshift;
#line 1288

#line 1288
#if 0
#line 1288
		if(csp->mant & (1 << (rshift -1)))
#line 1288
		{
#line 1288
			/* round up */
#line 1288
			isp->mant++;
#line 1288
		}
#line 1288
#endif
#line 1288

#line 1288
		isp->exp  = 0;
#line 1288
	}
#line 1288
	else
#line 1288
	{
#line 1288
		/* smaller than ieee can represent */
#line 1288
		isp->exp = 0;
#line 1288
		isp->mant = 0;
#line 1288
	}
#line 1288

	}
}

#else
	/* IEEE Cray with only doubles */
static void
get_ix_float(const void *xp, float *ip)
{

	ieee_double *idp = (ieee_double *) ip;

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	const ieee_double *idp = (const ieee_double *) ip;
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
}
#endif

#else
#error "ix_float implementation"
#endif


int
ncx_get_float_schar(const void *xp, schar *ip)
{
	float xx;
	get_ix_float(xp, &xx);
	*ip = (schar) xx;
	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_float_uchar(const void *xp, uchar *ip)
{
	float xx;
	get_ix_float(xp, &xx);
	*ip = (uchar) xx;
	if(xx > UCHAR_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_float_short(const void *xp, short *ip)
{
	float xx;
	get_ix_float(xp, &xx);
	*ip = (short) xx;
	if(xx > SHORT_MAX || xx < SHORT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_float_int(const void *xp, int *ip)
{
	float xx;
	get_ix_float(xp, &xx);
	*ip = (int) xx;
	if(xx > (double)INT_MAX || xx < (double)INT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_float_uint(const void *xp, unsigned int *ip)
{
	float xx;
	get_ix_float(xp, &xx);
	*ip = (unsigned int) xx;
	if(xx > (double)UINT_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_float_longlong(const void *xp, longlong *ip)
{
	float xx;
	get_ix_float(xp, &xx);
	*ip = (longlong) xx;
	if(xx > (double)LONG_LONG_MAX || xx < (double)LONG_LONG_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_float_ulonglong(const void *xp, unsigned long long *ip)
{
	float xx;
	get_ix_float(xp, &xx);
	*ip = (longlong) xx;
	if(xx > (double)ULONG_LONG_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_float_float(const void *xp, float *ip)
{
	/* TODO */
	get_ix_float(xp, ip);
	return ENOERR;
}

int
ncx_get_float_double(const void *xp, double *ip)
{
	/* TODO */
	float xx;
	get_ix_float(xp, &xx);
	*ip = xx;
	return ENOERR;
}


int
ncx_put_float_schar(void *xp, const schar *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
	return ENOERR;
}

int
ncx_put_float_uchar(void *xp, const uchar *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
	return ENOERR;
}

int
ncx_put_float_short(void *xp, const short *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
#if 0	/* TODO: figure this out */
	if((float)(*ip) > X_FLOAT_MAX || (float)(*ip) < X_FLOAT_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_float_int(void *xp, const int *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
#if 1	/* TODO: figure this out */
	if((float)(*ip) > X_FLOAT_MAX || (float)(*ip) < X_FLOAT_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_float_uint(void *xp, const unsigned int *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
#if 1	/* TODO: figure this out */
	if((float)(*ip) > X_FLOAT_MAX)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_float_longlong(void *xp, const longlong *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
#if 1	/* TODO: figure this out */
	if((float)(*ip) > X_FLOAT_MAX || (float)(*ip) < X_FLOAT_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_float_ulonglong(void *xp, const unsigned long long *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
#if 1	/* TODO: figure this out */
	if((float)(*ip) > X_FLOAT_MAX)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_float_float(void *xp, const float *ip)
{
	put_ix_float(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_float_double(void *xp, const double *ip)
{
	float xx = (float) *ip;
	put_ix_float(xp, &xx);
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

/* x_double */

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE  && !defined(NO_IEEE_FLOAT)

static void
get_ix_double(const void *xp, double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(double));
#else
	swap8b(ip, xp);
#endif
}

static void
put_ix_double(void *xp, const double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_DOUBLE);
#else
	swap8b(xp, ip);
#endif
}

#elif vax

/* What IEEE double precision floating point looks like on a Vax */
struct	ieee_double {
	unsigned int	exp_hi   : 7;
	unsigned int	sign     : 1;
	unsigned int 	mant_6   : 4;
	unsigned int	exp_lo   : 4;
	unsigned int	mant_5   : 8;
	unsigned int	mant_4   : 8;

	unsigned int	mant_lo  : 32;
};

/* Vax double precision floating point */
struct  vax_double {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
	unsigned int	mantissa3 : 16;
	unsigned int	mantissa4 : 16;
};

#define VAX_DBL_BIAS	0x81
#define IEEE_DBL_BIAS	0x3ff
#define MASK(nbits)	((1 << nbits) - 1)

static const struct dbl_limits {
	struct	vax_double d;
	struct	ieee_double ieee;
} dbl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0}}, /* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}, /* Min IEEE */
};


#line 1668
static void
get_ix_double(const void *xp, double *ip)
{
	struct vax_double *const vdp =
#line 1671
			 (struct vax_double *)ip;
#line 1671
	const struct ieee_double *const idp =
#line 1671
			 (const struct ieee_double *) xp;
#line 1671
	{
#line 1671
		const struct dbl_limits *lim;
#line 1671
		int ii;
#line 1671
		for (ii = 0, lim = dbl_limits;
#line 1671
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 1671
			ii++, lim++)
#line 1671
		{
#line 1671
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 1671
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 1671
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 1671
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 1671
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 1671
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 1671
				)
#line 1671
			{
#line 1671
				*vdp = lim->d;
#line 1671
				goto doneit;
#line 1671
			}
#line 1671
		}
#line 1671
	}
#line 1671
	{
#line 1671
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 1671
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 1671
	}
#line 1671
	{
#line 1671
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 1671
				 | (idp->mant_5 << 8)
#line 1671
				 | idp->mant_4);
#line 1671
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 1671
		vdp->mantissa1 = (mant_hi >> 13);
#line 1671
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 1671
				| (mant_lo >> 29);
#line 1671
		vdp->mantissa3 = (mant_lo >> 13);
#line 1671
		vdp->mantissa4 = (mant_lo << 3);
#line 1671
	}
#line 1671
	doneit:
#line 1671
		vdp->sign = idp->sign;
#line 1671

}


#line 1741
static void
put_ix_double(void *xp, const double *ip)
{
	const struct vax_double *const vdp =
#line 1744
			(const struct vax_double *)ip;
#line 1744
	struct ieee_double *const idp =
#line 1744
			 (struct ieee_double *) xp;
#line 1744

#line 1744
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 1744
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 1744
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 1744
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 1744
		(vdp->exp == dbl_limits[0].d.exp))
#line 1744
	{
#line 1744
		*idp = dbl_limits[0].ieee;
#line 1744
		goto shipit;
#line 1744
	}
#line 1744
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 1744
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 1744
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 1744
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 1744
		(vdp->exp == dbl_limits[1].d.exp))
#line 1744
	{
#line 1744
		*idp = dbl_limits[1].ieee;
#line 1744
		goto shipit;
#line 1744
	}
#line 1744

#line 1744
	{
#line 1744
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 1744

#line 1744
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 1744
			(vdp->mantissa3 << 13) |
#line 1744
			((vdp->mantissa4 >> 3) & MASK(13));
#line 1744

#line 1744
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 1744
				 | (vdp->mantissa2 >> 3);
#line 1744

#line 1744
		if((vdp->mantissa4 & 7) > 4)
#line 1744
		{
#line 1744
			/* round up */
#line 1744
			mant_lo++;
#line 1744
			if(mant_lo == 0)
#line 1744
			{
#line 1744
				mant_hi++;
#line 1744
				if(mant_hi > 0xffffff)
#line 1744
				{
#line 1744
					mant_hi = 0;
#line 1744
					exp++;
#line 1744
				}
#line 1744
			}
#line 1744
		}
#line 1744

#line 1744
		idp->mant_lo = SWAP4(mant_lo);
#line 1744
		idp->mant_6 = mant_hi >> 16;
#line 1744
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 1744
		idp->mant_4 = mant_hi;
#line 1744
		idp->exp_hi = exp >> 4;
#line 1744
		idp->exp_lo = exp;
#line 1744
	}
#line 1744

#line 1744
	shipit:
#line 1744
		idp->sign = vdp->sign;
#line 1744

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

static void
get_ix_double(const void *xp, double *ip)
{
	const ieee_double *idp = (const ieee_double *) xp;
	cray_single *csp = (cray_single *) ip;

	if(idp->exp == 0)
	{
		/* ieee subnormal */
		*ip = (double)idp->mant;
		if(idp->mant != 0)
		{
			csp->exp -= (ieee_double_bias + 51);
		}
	}
	else
	{
		csp->exp  = idp->exp + cs_id_bias + 1;
		csp->mant = idp->mant >> (52 - 48 + 1);
		csp->mant |= (1 << (48 - 1));
	}
	csp->sign = idp->sign;
}

static void
put_ix_double(void *xp, const double *ip)
{
	ieee_double *idp = (ieee_double *) xp;
	const cray_single *csp = (const cray_single *) ip;

	int ieee_exp = csp->exp - cs_id_bias -1;

	idp->sign = csp->sign;

	if(ieee_exp >= 0x7ff)
	{
		/* NC_ERANGE => ieee Inf */
		idp->exp = 0x7ff;
		idp->mant = 0x0;
	}
	else if(ieee_exp > 0)
	{
		/* normal ieee representation */
		idp->exp  = ieee_exp;
		/* assumes cray rep is in normal form */
		assert(csp->mant & 0x800000000000);
		idp->mant = (((csp->mant << 1) &
				0xffffffffffff) << (52 - 48));
	}
	else if(ieee_exp >= (-(52 -48)))
	{
		/* ieee subnormal, left shift */
		const int lshift = (52 - 48) + ieee_exp;
		idp->mant = csp->mant << lshift;
		idp->exp  = 0;
	}
	else if(ieee_exp >= -52)
	{
		/* ieee subnormal, right shift */
		const int rshift = (- (52 - 48) - ieee_exp);

		idp->mant = csp->mant >> rshift;

#if 0
		if(csp->mant & (1 << (rshift -1)))
		{
			/* round up */
			idp->mant++;
		}
#endif

		idp->exp  = 0;
	}
	else
	{
		/* smaller than ieee can represent */
		idp->exp = 0;
		idp->mant = 0;
	}
}
#else
#error "ix_double implementation"
#endif

int
ncx_get_double_schar(const void *xp, schar *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	*ip = (schar) xx;
	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_double_uchar(const void *xp, uchar *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	*ip = (uchar) xx;
	if(xx > UCHAR_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_double_short(const void *xp, short *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	*ip = (short) xx;
	if(xx > SHORT_MAX || xx < SHORT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_double_int(const void *xp, int *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	*ip = (int) xx;
	if(xx > INT_MAX || xx < INT_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_double_uint(const void *xp, unsigned int *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	*ip = (unsigned int) xx;
	if(xx > UINT_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_double_longlong(const void *xp, longlong *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	*ip = (longlong) xx;
	if(xx > LONG_LONG_MAX || xx < LONG_LONG_MIN)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_double_ulonglong(const void *xp, unsigned long long *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	*ip = (unsigned long long) xx;
	if(xx > ULONG_LONG_MAX || xx < 0)
		return NC_ERANGE;
	return ENOERR;
}

int
ncx_get_double_float(const void *xp, float *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	if(xx > FLT_MAX)
	{
		*ip = FLT_MAX;
		return NC_ERANGE;
	}
	if(xx < (-FLT_MAX))
	{
		*ip = (-FLT_MAX);
		return NC_ERANGE;
	}
	*ip = (float) xx;
	return ENOERR;
}

int
ncx_get_double_double(const void *xp, double *ip)
{
	/* TODO */
	get_ix_double(xp, ip);
	return ENOERR;
}


int
ncx_put_double_schar(void *xp, const schar *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
	return ENOERR;
}

int
ncx_put_double_uchar(void *xp, const uchar *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
	return ENOERR;
}

int
ncx_put_double_short(void *xp, const short *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 0	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_double_int(void *xp, const int *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 0	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_double_uint(void *xp, const unsigned int *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 0	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_double_longlong(void *xp, const longlong *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 1	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_double_ulonglong(void *xp, const unsigned long long *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 1	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_double_float(void *xp, const float *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 1	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

int
ncx_put_double_double(void *xp, const double *ip)
{
	put_ix_double(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}


/* x_size_t */

#if SIZEOF_SIZE_T < X_SIZEOF_SIZE_T
#error "x_size_t implementation"
/* netcdf requires size_t which can hold a values from 0 to 2^32 -1 */
#endif

int
ncx_put_size_t(void **xpp, const size_t *ulp)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
	assert(*ulp <= X_SIZE_MAX);

	*cp++ = (uchar)((*ulp) >> 24);
	*cp++ = (uchar)(((*ulp) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ulp) & 0x0000ff00) >>  8);
	*cp   = (uchar)((*ulp) & 0x000000ff);

	*xpp = (void *)((char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

int
ncx_get_size_t(const void **xpp,  size_t *ulp)
{
	/* similar to get_ix_int */
	const uchar *cp = (const uchar *) *xpp;

	*ulp = (unsigned)(*cp++ << 24);
	*ulp |= (*cp++ << 16);
	*ulp |= (*cp++ << 8);
	*ulp |= *cp;

	*xpp = (const void *)((const char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

/* x_off_t */

int
ncx_put_off_t(void **xpp, const off_t *lp, size_t sizeof_off_t)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
		/* No negative offsets stored in netcdf */
	if (*lp < 0) {
	  /* Assume this is an overflow of a 32-bit int... */
	  return ERANGE;
	}

	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

	if (sizeof_off_t == 4) {
		*cp++ = (uchar) ((*lp)               >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
	} else {
#if SIZEOF_OFF_T == 4
/* Write a 64-bit offset on a system with only a 32-bit offset */
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;

		*cp++ = (uchar)(((*lp) & 0xff000000) >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
#else
		*cp++ = (uchar) ((*lp)                          >> 56);
		*cp++ = (uchar)(((*lp) & 0x00ff000000000000ULL) >> 48);
		*cp++ = (uchar)(((*lp) & 0x0000ff0000000000ULL) >> 40);
		*cp++ = (uchar)(((*lp) & 0x000000ff00000000ULL) >> 32);
		*cp++ = (uchar)(((*lp) & 0x00000000ff000000ULL) >> 24);
		*cp++ = (uchar)(((*lp) & 0x0000000000ff0000ULL) >> 16);
		*cp++ = (uchar)(((*lp) & 0x000000000000ff00ULL) >>  8);
		*cp   = (uchar)( (*lp) & 0x00000000000000ffULL);
#endif
	}
	*xpp = (void *)((char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}

int
ncx_get_off_t(const void **xpp, off_t *lp, size_t sizeof_off_t)
{
	/* similar to get_ix_int() */
	const uchar *cp = (const uchar *) *xpp;
	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

 	if (sizeof_off_t == 4) {
		*lp =  (off_t)(*cp++ << 24);
		*lp |= (off_t)(*cp++ << 16);
		*lp |= (off_t)(*cp++ <<  8);
		*lp |= (off_t)*cp;
	} else {
#if SIZEOF_OFF_T == 4
/* Read a 64-bit offset on a system with only a 32-bit offset */
/* If the offset overflows, set an error code and return */
		*lp =  ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |= ((off_t)(*cp++));
/*
 * lp now contains the upper 32-bits of the 64-bit offset.  if lp is
 * not zero, then the dataset is larger than can be represented
 * on this system.  Set an error code and return.
 */
		if (*lp != 0) {
		  return ERANGE;
		}

		*lp  = ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;

		if (*lp < 0) {
		  /*
		   * If this fails, then the offset is >2^31, but less
		   * than 2^32 which is not allowed, but is not caught
		   * by the previous check
		   */
		  return ERANGE;
		}
#else
		*lp =  ((off_t)(*cp++) << 56);
		*lp |= ((off_t)(*cp++) << 48);
		*lp |= ((off_t)(*cp++) << 40);
		*lp |= ((off_t)(*cp++) << 32);
		*lp |= ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;
#endif
	}
	*xpp = (const void *)((const char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}


/*
 * Aggregate numeric conversion functions.
 */
#line 2632


#line 2639

/* schar */

#line 2643
int
ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2646
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2646
	return ENOERR;
#line 2646

}
#line 2649
int
ncx_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2652
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2652
	return ENOERR;
#line 2652

}
int
#line 2654
ncx_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2654
{
#line 2654
	schar *xp = (schar *)(*xpp);
#line 2654

#line 2654
	while(nelems-- != 0)
#line 2654
	{
#line 2654
		*tp++ = *xp++;
#line 2654
	}
#line 2654

#line 2654
	*xpp = (const void *)xp;
#line 2654
	return ENOERR;
#line 2654
}
#line 2654

int
#line 2655
ncx_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2655
{
#line 2655
	schar *xp = (schar *)(*xpp);
#line 2655

#line 2655
	while(nelems-- != 0)
#line 2655
	{
#line 2655
		*tp++ = *xp++;
#line 2655
	}
#line 2655

#line 2655
	*xpp = (const void *)xp;
#line 2655
	return ENOERR;
#line 2655
}
#line 2655

int
#line 2656
ncx_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2656
{
#line 2656
	schar *xp = (schar *)(*xpp);
#line 2656

#line 2656
	while(nelems-- != 0)
#line 2656
	{
#line 2656
		*tp++ = *xp++;
#line 2656
	}
#line 2656

#line 2656
	*xpp = (const void *)xp;
#line 2656
	return ENOERR;
#line 2656
}
#line 2656

int
#line 2657
ncx_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2657
{
#line 2657
	schar *xp = (schar *)(*xpp);
#line 2657

#line 2657
	while(nelems-- != 0)
#line 2657
	{
#line 2657
		*tp++ = *xp++;
#line 2657
	}
#line 2657

#line 2657
	*xpp = (const void *)xp;
#line 2657
	return ENOERR;
#line 2657
}
#line 2657

int
#line 2658
ncx_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2658
{
#line 2658
	schar *xp = (schar *)(*xpp);
#line 2658

#line 2658
	while(nelems-- != 0)
#line 2658
	{
#line 2658
		*tp++ = *xp++;
#line 2658
	}
#line 2658

#line 2658
	*xpp = (const void *)xp;
#line 2658
	return ENOERR;
#line 2658
}
#line 2658

int
#line 2659
ncx_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2659
{
#line 2659
	schar *xp = (schar *)(*xpp);
#line 2659

#line 2659
	while(nelems-- != 0)
#line 2659
	{
#line 2659
		*tp++ = *xp++;
#line 2659
	}
#line 2659

#line 2659
	*xpp = (const void *)xp;
#line 2659
	return ENOERR;
#line 2659
}
#line 2659

int
#line 2660
ncx_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2660
{
#line 2660
	schar *xp = (schar *)(*xpp);
#line 2660

#line 2660
	while(nelems-- != 0)
#line 2660
	{
#line 2660
		*tp++ = *xp++;
#line 2660
	}
#line 2660

#line 2660
	*xpp = (const void *)xp;
#line 2660
	return ENOERR;
#line 2660
}
#line 2660


#line 2663
int
ncx_pad_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2666

#line 2666
	if(rndup)
#line 2666
		rndup = X_ALIGN - rndup;
#line 2666

#line 2666
	(void) memcpy(tp, *xpp, nelems);
#line 2666
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2666

#line 2666
	return ENOERR;
#line 2666

}
#line 2669
int
ncx_pad_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2672

#line 2672
	if(rndup)
#line 2672
		rndup = X_ALIGN - rndup;
#line 2672

#line 2672
	(void) memcpy(tp, *xpp, nelems);
#line 2672
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2672

#line 2672
	return ENOERR;
#line 2672

}
int
#line 2674
ncx_pad_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2674
{
#line 2674
	size_t rndup = nelems % X_ALIGN;
#line 2674
	schar *xp = (schar *) *xpp;
#line 2674

#line 2674
	if(rndup)
#line 2674
		rndup = X_ALIGN - rndup;
#line 2674

#line 2674
	while(nelems-- != 0)
#line 2674
	{
#line 2674
		*tp++ = *xp++;
#line 2674
	}
#line 2674

#line 2674
	*xpp = (void *)(xp + rndup);
#line 2674
	return ENOERR;
#line 2674
}
#line 2674

int
#line 2675
ncx_pad_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2675
{
#line 2675
	size_t rndup = nelems % X_ALIGN;
#line 2675
	schar *xp = (schar *) *xpp;
#line 2675

#line 2675
	if(rndup)
#line 2675
		rndup = X_ALIGN - rndup;
#line 2675

#line 2675
	while(nelems-- != 0)
#line 2675
	{
#line 2675
		*tp++ = *xp++;
#line 2675
	}
#line 2675

#line 2675
	*xpp = (void *)(xp + rndup);
#line 2675
	return ENOERR;
#line 2675
}
#line 2675

int
#line 2676
ncx_pad_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2676
{
#line 2676
	size_t rndup = nelems % X_ALIGN;
#line 2676
	schar *xp = (schar *) *xpp;
#line 2676

#line 2676
	if(rndup)
#line 2676
		rndup = X_ALIGN - rndup;
#line 2676

#line 2676
	while(nelems-- != 0)
#line 2676
	{
#line 2676
		*tp++ = *xp++;
#line 2676
	}
#line 2676

#line 2676
	*xpp = (void *)(xp + rndup);
#line 2676
	return ENOERR;
#line 2676
}
#line 2676

int
#line 2677
ncx_pad_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2677
{
#line 2677
	size_t rndup = nelems % X_ALIGN;
#line 2677
	schar *xp = (schar *) *xpp;
#line 2677

#line 2677
	if(rndup)
#line 2677
		rndup = X_ALIGN - rndup;
#line 2677

#line 2677
	while(nelems-- != 0)
#line 2677
	{
#line 2677
		*tp++ = *xp++;
#line 2677
	}
#line 2677

#line 2677
	*xpp = (void *)(xp + rndup);
#line 2677
	return ENOERR;
#line 2677
}
#line 2677

int
#line 2678
ncx_pad_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2678
{
#line 2678
	size_t rndup = nelems % X_ALIGN;
#line 2678
	schar *xp = (schar *) *xpp;
#line 2678

#line 2678
	if(rndup)
#line 2678
		rndup = X_ALIGN - rndup;
#line 2678

#line 2678
	while(nelems-- != 0)
#line 2678
	{
#line 2678
		*tp++ = *xp++;
#line 2678
	}
#line 2678

#line 2678
	*xpp = (void *)(xp + rndup);
#line 2678
	return ENOERR;
#line 2678
}
#line 2678

int
#line 2679
ncx_pad_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2679
{
#line 2679
	size_t rndup = nelems % X_ALIGN;
#line 2679
	schar *xp = (schar *) *xpp;
#line 2679

#line 2679
	if(rndup)
#line 2679
		rndup = X_ALIGN - rndup;
#line 2679

#line 2679
	while(nelems-- != 0)
#line 2679
	{
#line 2679
		*tp++ = *xp++;
#line 2679
	}
#line 2679

#line 2679
	*xpp = (void *)(xp + rndup);
#line 2679
	return ENOERR;
#line 2679
}
#line 2679

int
#line 2680
ncx_pad_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2680
{
#line 2680
	size_t rndup = nelems % X_ALIGN;
#line 2680
	schar *xp = (schar *) *xpp;
#line 2680

#line 2680
	if(rndup)
#line 2680
		rndup = X_ALIGN - rndup;
#line 2680

#line 2680
	while(nelems-- != 0)
#line 2680
	{
#line 2680
		*tp++ = *xp++;
#line 2680
	}
#line 2680

#line 2680
	*xpp = (void *)(xp + rndup);
#line 2680
	return ENOERR;
#line 2680
}
#line 2680


#line 2683
int
ncx_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2686
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2686

#line 2686
	return ENOERR;
#line 2686

}
#line 2689
int
ncx_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2692
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2692

#line 2692
	return ENOERR;
#line 2692

}
int
#line 2694
ncx_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2694
{
#line 2694
	int status = ENOERR;
#line 2694
	schar *xp = (schar *) *xpp;
#line 2694

#line 2694
	while(nelems-- != 0)
#line 2694
	{
#line 2694
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2694
			status = NC_ERANGE;
#line 2694
		*xp++ = (schar) *tp++;
#line 2694
	}
#line 2694

#line 2694
	*xpp = (void *)xp;
#line 2694
	return status;
#line 2694
}
#line 2694

int
#line 2695
ncx_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2695
{
#line 2695
	int status = ENOERR;
#line 2695
	schar *xp = (schar *) *xpp;
#line 2695

#line 2695
	while(nelems-- != 0)
#line 2695
	{
#line 2695
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2695
			status = NC_ERANGE;
#line 2695
		*xp++ = (schar) *tp++;
#line 2695
	}
#line 2695

#line 2695
	*xpp = (void *)xp;
#line 2695
	return status;
#line 2695
}
#line 2695

int
#line 2696
ncx_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2696
{
#line 2696
	int status = ENOERR;
#line 2696
	schar *xp = (schar *) *xpp;
#line 2696

#line 2696
	while(nelems-- != 0)
#line 2696
	{
#line 2696
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2696
			status = NC_ERANGE;
#line 2696
		*xp++ = (schar) *tp++;
#line 2696
	}
#line 2696

#line 2696
	*xpp = (void *)xp;
#line 2696
	return status;
#line 2696
}
#line 2696

int
#line 2697
ncx_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2697
{
#line 2697
	int status = ENOERR;
#line 2697
	schar *xp = (schar *) *xpp;
#line 2697

#line 2697
	while(nelems-- != 0)
#line 2697
	{
#line 2697
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2697
			status = NC_ERANGE;
#line 2697
		*xp++ = (schar) *tp++;
#line 2697
	}
#line 2697

#line 2697
	*xpp = (void *)xp;
#line 2697
	return status;
#line 2697
}
#line 2697

int
#line 2698
ncx_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2698
{
#line 2698
	int status = ENOERR;
#line 2698
	schar *xp = (schar *) *xpp;
#line 2698

#line 2698
	while(nelems-- != 0)
#line 2698
	{
#line 2698
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2698
			status = NC_ERANGE;
#line 2698
		*xp++ = (schar) *tp++;
#line 2698
	}
#line 2698

#line 2698
	*xpp = (void *)xp;
#line 2698
	return status;
#line 2698
}
#line 2698

int
#line 2699
ncx_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2699
{
#line 2699
	int status = ENOERR;
#line 2699
	schar *xp = (schar *) *xpp;
#line 2699

#line 2699
	while(nelems-- != 0)
#line 2699
	{
#line 2699
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2699
			status = NC_ERANGE;
#line 2699
		*xp++ = (schar) *tp++;
#line 2699
	}
#line 2699

#line 2699
	*xpp = (void *)xp;
#line 2699
	return status;
#line 2699
}
#line 2699

int
#line 2700
ncx_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2700
{
#line 2700
	int status = ENOERR;
#line 2700
	schar *xp = (schar *) *xpp;
#line 2700

#line 2700
	while(nelems-- != 0)
#line 2700
	{
#line 2700
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2700
			status = NC_ERANGE;
#line 2700
		*xp++ = (schar) *tp++;
#line 2700
	}
#line 2700

#line 2700
	*xpp = (void *)xp;
#line 2700
	return status;
#line 2700
}
#line 2700


#line 2703
int
ncx_pad_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2706

#line 2706
	if(rndup)
#line 2706
		rndup = X_ALIGN - rndup;
#line 2706

#line 2706
	(void) memcpy(*xpp, tp, nelems);
#line 2706
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2706

#line 2706
	if(rndup)
#line 2706
	{
#line 2706
		(void) memcpy(*xpp, nada, rndup);
#line 2706
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2706
	}
#line 2706

#line 2706
	return ENOERR;
#line 2706

}
#line 2709
int
ncx_pad_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2712

#line 2712
	if(rndup)
#line 2712
		rndup = X_ALIGN - rndup;
#line 2712

#line 2712
	(void) memcpy(*xpp, tp, nelems);
#line 2712
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2712

#line 2712
	if(rndup)
#line 2712
	{
#line 2712
		(void) memcpy(*xpp, nada, rndup);
#line 2712
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2712
	}
#line 2712

#line 2712
	return ENOERR;
#line 2712

}
int
#line 2714
ncx_pad_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2714
{
#line 2714
	int status = ENOERR;
#line 2714
	size_t rndup = nelems % X_ALIGN;
#line 2714
	schar *xp = (schar *) *xpp;
#line 2714

#line 2714
	if(rndup)
#line 2714
		rndup = X_ALIGN - rndup;
#line 2714

#line 2714
	while(nelems-- != 0)
#line 2714
	{
#line 2714
		/* N.B. schar as signed */
#line 2714
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2714
			status = NC_ERANGE;
#line 2714
		*xp++ = (schar) *tp++;
#line 2714
	}
#line 2714

#line 2714

#line 2714
	if(rndup)
#line 2714
	{
#line 2714
		(void) memcpy(xp, nada, rndup);
#line 2714
		xp += rndup;
#line 2714
	}
#line 2714

#line 2714
	*xpp = (void *)xp;
#line 2714
	return status;
#line 2714
}
#line 2714

int
#line 2715
ncx_pad_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2715
{
#line 2715
	int status = ENOERR;
#line 2715
	size_t rndup = nelems % X_ALIGN;
#line 2715
	schar *xp = (schar *) *xpp;
#line 2715

#line 2715
	if(rndup)
#line 2715
		rndup = X_ALIGN - rndup;
#line 2715

#line 2715
	while(nelems-- != 0)
#line 2715
	{
#line 2715
		/* N.B. schar as signed */
#line 2715
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2715
			status = NC_ERANGE;
#line 2715
		*xp++ = (schar) *tp++;
#line 2715
	}
#line 2715

#line 2715

#line 2715
	if(rndup)
#line 2715
	{
#line 2715
		(void) memcpy(xp, nada, rndup);
#line 2715
		xp += rndup;
#line 2715
	}
#line 2715

#line 2715
	*xpp = (void *)xp;
#line 2715
	return status;
#line 2715
}
#line 2715

int
#line 2716
ncx_pad_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2716
{
#line 2716
	int status = ENOERR;
#line 2716
	size_t rndup = nelems % X_ALIGN;
#line 2716
	schar *xp = (schar *) *xpp;
#line 2716

#line 2716
	if(rndup)
#line 2716
		rndup = X_ALIGN - rndup;
#line 2716

#line 2716
	while(nelems-- != 0)
#line 2716
	{
#line 2716
		/* N.B. schar as signed */
#line 2716
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2716
			status = NC_ERANGE;
#line 2716
		*xp++ = (schar) *tp++;
#line 2716
	}
#line 2716

#line 2716

#line 2716
	if(rndup)
#line 2716
	{
#line 2716
		(void) memcpy(xp, nada, rndup);
#line 2716
		xp += rndup;
#line 2716
	}
#line 2716

#line 2716
	*xpp = (void *)xp;
#line 2716
	return status;
#line 2716
}
#line 2716

int
#line 2717
ncx_pad_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2717
{
#line 2717
	int status = ENOERR;
#line 2717
	size_t rndup = nelems % X_ALIGN;
#line 2717
	schar *xp = (schar *) *xpp;
#line 2717

#line 2717
	if(rndup)
#line 2717
		rndup = X_ALIGN - rndup;
#line 2717

#line 2717
	while(nelems-- != 0)
#line 2717
	{
#line 2717
		/* N.B. schar as signed */
#line 2717
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2717
			status = NC_ERANGE;
#line 2717
		*xp++ = (schar) *tp++;
#line 2717
	}
#line 2717

#line 2717

#line 2717
	if(rndup)
#line 2717
	{
#line 2717
		(void) memcpy(xp, nada, rndup);
#line 2717
		xp += rndup;
#line 2717
	}
#line 2717

#line 2717
	*xpp = (void *)xp;
#line 2717
	return status;
#line 2717
}
#line 2717

int
#line 2718
ncx_pad_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2718
{
#line 2718
	int status = ENOERR;
#line 2718
	size_t rndup = nelems % X_ALIGN;
#line 2718
	schar *xp = (schar *) *xpp;
#line 2718

#line 2718
	if(rndup)
#line 2718
		rndup = X_ALIGN - rndup;
#line 2718

#line 2718
	while(nelems-- != 0)
#line 2718
	{
#line 2718
		/* N.B. schar as signed */
#line 2718
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2718
			status = NC_ERANGE;
#line 2718
		*xp++ = (schar) *tp++;
#line 2718
	}
#line 2718

#line 2718

#line 2718
	if(rndup)
#line 2718
	{
#line 2718
		(void) memcpy(xp, nada, rndup);
#line 2718
		xp += rndup;
#line 2718
	}
#line 2718

#line 2718
	*xpp = (void *)xp;
#line 2718
	return status;
#line 2718
}
#line 2718

int
#line 2719
ncx_pad_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2719
{
#line 2719
	int status = ENOERR;
#line 2719
	size_t rndup = nelems % X_ALIGN;
#line 2719
	schar *xp = (schar *) *xpp;
#line 2719

#line 2719
	if(rndup)
#line 2719
		rndup = X_ALIGN - rndup;
#line 2719

#line 2719
	while(nelems-- != 0)
#line 2719
	{
#line 2719
		/* N.B. schar as signed */
#line 2719
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2719
			status = NC_ERANGE;
#line 2719
		*xp++ = (schar) *tp++;
#line 2719
	}
#line 2719

#line 2719

#line 2719
	if(rndup)
#line 2719
	{
#line 2719
		(void) memcpy(xp, nada, rndup);
#line 2719
		xp += rndup;
#line 2719
	}
#line 2719

#line 2719
	*xpp = (void *)xp;
#line 2719
	return status;
#line 2719
}
#line 2719

int
#line 2720
ncx_pad_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2720
{
#line 2720
	int status = ENOERR;
#line 2720
	size_t rndup = nelems % X_ALIGN;
#line 2720
	schar *xp = (schar *) *xpp;
#line 2720

#line 2720
	if(rndup)
#line 2720
		rndup = X_ALIGN - rndup;
#line 2720

#line 2720
	while(nelems-- != 0)
#line 2720
	{
#line 2720
		/* N.B. schar as signed */
#line 2720
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2720
			status = NC_ERANGE;
#line 2720
		*xp++ = (schar) *tp++;
#line 2720
	}
#line 2720

#line 2720

#line 2720
	if(rndup)
#line 2720
	{
#line 2720
		(void) memcpy(xp, nada, rndup);
#line 2720
		xp += rndup;
#line 2720
	}
#line 2720

#line 2720
	*xpp = (void *)xp;
#line 2720
	return status;
#line 2720
}
#line 2720



/* short */

int
#line 2725
ncx_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2725
{
#line 2725
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2725

#line 2725
 /* basic algorithm is:
#line 2725
  *   - ensure sane alignment of input data
#line 2725
  *   - copy (conversion happens automatically) input data
#line 2725
  *     to output
#line 2725
  *   - update xpp to point at next unconverted input, and tp to point
#line 2725
  *     at next location for converted output
#line 2725
  */
#line 2725
  long i, j, ni;
#line 2725
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2725
  short *xp;
#line 2725
  int nrange = 0;         /* number of range errors */
#line 2725
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2725
  long cxp = (long) *((char**)xpp);
#line 2725

#line 2725
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2725
  /* sjl: manually stripmine so we can limit amount of
#line 2725
   * vector work space reserved to LOOPCNT elements. Also
#line 2725
   * makes vectorisation easy */
#line 2725
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2725
    ni=Min(nelems-j,LOOPCNT);
#line 2725
    if (realign) {
#line 2725
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2725
      xp = tmp;
#line 2725
    } else {
#line 2725
      xp = (short *) *xpp;
#line 2725
    }
#line 2725
   /* copy the next block */
#line 2725
#pragma cdir loopcnt=LOOPCNT
#line 2725
#pragma cdir shortloop
#line 2725
    for (i=0; i<ni; i++) {
#line 2725
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2725
     /* test for range errors (not always needed but do it anyway) */
#line 2725
      nrange += xp[i] < SCHAR_MIN || xp[i] > SCHAR_MAX;
#line 2725
    }
#line 2725
   /* update xpp and tp */
#line 2725
    if (realign) xp = (short *) *xpp;
#line 2725
    xp += ni;
#line 2725
    tp += ni;
#line 2725
    *xpp = (void*)xp;
#line 2725
  }
#line 2725
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2725

#line 2725
#else   /* not SX */
#line 2725
	const char *xp = (const char *) *xpp;
#line 2725
	int status = ENOERR;
#line 2725

#line 2725
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2725
	{
#line 2725
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2725
		if(lstatus != ENOERR)
#line 2725
			status = lstatus;
#line 2725
	}
#line 2725

#line 2725
	*xpp = (const void *)xp;
#line 2725
	return status;
#line 2725
#  endif
#line 2725
}
#line 2725

int
#line 2726
ncx_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2726
{
#line 2726
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2726

#line 2726
 /* basic algorithm is:
#line 2726
  *   - ensure sane alignment of input data
#line 2726
  *   - copy (conversion happens automatically) input data
#line 2726
  *     to output
#line 2726
  *   - update xpp to point at next unconverted input, and tp to point
#line 2726
  *     at next location for converted output
#line 2726
  */
#line 2726
  long i, j, ni;
#line 2726
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2726
  short *xp;
#line 2726
  int nrange = 0;         /* number of range errors */
#line 2726
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2726
  long cxp = (long) *((char**)xpp);
#line 2726

#line 2726
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2726
  /* sjl: manually stripmine so we can limit amount of
#line 2726
   * vector work space reserved to LOOPCNT elements. Also
#line 2726
   * makes vectorisation easy */
#line 2726
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2726
    ni=Min(nelems-j,LOOPCNT);
#line 2726
    if (realign) {
#line 2726
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2726
      xp = tmp;
#line 2726
    } else {
#line 2726
      xp = (short *) *xpp;
#line 2726
    }
#line 2726
   /* copy the next block */
#line 2726
#pragma cdir loopcnt=LOOPCNT
#line 2726
#pragma cdir shortloop
#line 2726
    for (i=0; i<ni; i++) {
#line 2726
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2726
     /* test for range errors (not always needed but do it anyway) */
#line 2726
      nrange += xp[i] < UCHAR_MIN || xp[i] > UCHAR_MAX;
#line 2726
    }
#line 2726
   /* update xpp and tp */
#line 2726
    if (realign) xp = (short *) *xpp;
#line 2726
    xp += ni;
#line 2726
    tp += ni;
#line 2726
    *xpp = (void*)xp;
#line 2726
  }
#line 2726
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2726

#line 2726
#else   /* not SX */
#line 2726
	const char *xp = (const char *) *xpp;
#line 2726
	int status = ENOERR;
#line 2726

#line 2726
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2726
	{
#line 2726
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2726
		if(lstatus != ENOERR)
#line 2726
			status = lstatus;
#line 2726
	}
#line 2726

#line 2726
	*xpp = (const void *)xp;
#line 2726
	return status;
#line 2726
#  endif
#line 2726
}
#line 2726

#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(short));
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2741
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2741
{
#line 2741
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2741

#line 2741
 /* basic algorithm is:
#line 2741
  *   - ensure sane alignment of input data
#line 2741
  *   - copy (conversion happens automatically) input data
#line 2741
  *     to output
#line 2741
  *   - update xpp to point at next unconverted input, and tp to point
#line 2741
  *     at next location for converted output
#line 2741
  */
#line 2741
  long i, j, ni;
#line 2741
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2741
  short *xp;
#line 2741
  int nrange = 0;         /* number of range errors */
#line 2741
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2741
  long cxp = (long) *((char**)xpp);
#line 2741

#line 2741
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2741
  /* sjl: manually stripmine so we can limit amount of
#line 2741
   * vector work space reserved to LOOPCNT elements. Also
#line 2741
   * makes vectorisation easy */
#line 2741
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2741
    ni=Min(nelems-j,LOOPCNT);
#line 2741
    if (realign) {
#line 2741
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2741
      xp = tmp;
#line 2741
    } else {
#line 2741
      xp = (short *) *xpp;
#line 2741
    }
#line 2741
   /* copy the next block */
#line 2741
#pragma cdir loopcnt=LOOPCNT
#line 2741
#pragma cdir shortloop
#line 2741
    for (i=0; i<ni; i++) {
#line 2741
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2741
     /* test for range errors (not always needed but do it anyway) */
#line 2741
      nrange += xp[i] < SHORT_MIN || xp[i] > SHORT_MAX;
#line 2741
    }
#line 2741
   /* update xpp and tp */
#line 2741
    if (realign) xp = (short *) *xpp;
#line 2741
    xp += ni;
#line 2741
    tp += ni;
#line 2741
    *xpp = (void*)xp;
#line 2741
  }
#line 2741
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2741

#line 2741
#else   /* not SX */
#line 2741
	const char *xp = (const char *) *xpp;
#line 2741
	int status = ENOERR;
#line 2741

#line 2741
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2741
	{
#line 2741
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2741
		if(lstatus != ENOERR)
#line 2741
			status = lstatus;
#line 2741
	}
#line 2741

#line 2741
	*xpp = (const void *)xp;
#line 2741
	return status;
#line 2741
#  endif
#line 2741
}
#line 2741

#endif
int
#line 2743
ncx_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2743
{
#line 2743
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2743

#line 2743
 /* basic algorithm is:
#line 2743
  *   - ensure sane alignment of input data
#line 2743
  *   - copy (conversion happens automatically) input data
#line 2743
  *     to output
#line 2743
  *   - update xpp to point at next unconverted input, and tp to point
#line 2743
  *     at next location for converted output
#line 2743
  */
#line 2743
  long i, j, ni;
#line 2743
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2743
  short *xp;
#line 2743
  int nrange = 0;         /* number of range errors */
#line 2743
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2743
  long cxp = (long) *((char**)xpp);
#line 2743

#line 2743
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2743
  /* sjl: manually stripmine so we can limit amount of
#line 2743
   * vector work space reserved to LOOPCNT elements. Also
#line 2743
   * makes vectorisation easy */
#line 2743
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2743
    ni=Min(nelems-j,LOOPCNT);
#line 2743
    if (realign) {
#line 2743
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2743
      xp = tmp;
#line 2743
    } else {
#line 2743
      xp = (short *) *xpp;
#line 2743
    }
#line 2743
   /* copy the next block */
#line 2743
#pragma cdir loopcnt=LOOPCNT
#line 2743
#pragma cdir shortloop
#line 2743
    for (i=0; i<ni; i++) {
#line 2743
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2743
     /* test for range errors (not always needed but do it anyway) */
#line 2743
      nrange += xp[i] < INT_MIN || xp[i] > INT_MAX;
#line 2743
    }
#line 2743
   /* update xpp and tp */
#line 2743
    if (realign) xp = (short *) *xpp;
#line 2743
    xp += ni;
#line 2743
    tp += ni;
#line 2743
    *xpp = (void*)xp;
#line 2743
  }
#line 2743
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2743

#line 2743
#else   /* not SX */
#line 2743
	const char *xp = (const char *) *xpp;
#line 2743
	int status = ENOERR;
#line 2743

#line 2743
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2743
	{
#line 2743
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2743
		if(lstatus != ENOERR)
#line 2743
			status = lstatus;
#line 2743
	}
#line 2743

#line 2743
	*xpp = (const void *)xp;
#line 2743
	return status;
#line 2743
#  endif
#line 2743
}
#line 2743

int
#line 2744
ncx_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2744
{
#line 2744
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2744

#line 2744
 /* basic algorithm is:
#line 2744
  *   - ensure sane alignment of input data
#line 2744
  *   - copy (conversion happens automatically) input data
#line 2744
  *     to output
#line 2744
  *   - update xpp to point at next unconverted input, and tp to point
#line 2744
  *     at next location for converted output
#line 2744
  */
#line 2744
  long i, j, ni;
#line 2744
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2744
  short *xp;
#line 2744
  int nrange = 0;         /* number of range errors */
#line 2744
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2744
  long cxp = (long) *((char**)xpp);
#line 2744

#line 2744
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2744
  /* sjl: manually stripmine so we can limit amount of
#line 2744
   * vector work space reserved to LOOPCNT elements. Also
#line 2744
   * makes vectorisation easy */
#line 2744
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2744
    ni=Min(nelems-j,LOOPCNT);
#line 2744
    if (realign) {
#line 2744
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2744
      xp = tmp;
#line 2744
    } else {
#line 2744
      xp = (short *) *xpp;
#line 2744
    }
#line 2744
   /* copy the next block */
#line 2744
#pragma cdir loopcnt=LOOPCNT
#line 2744
#pragma cdir shortloop
#line 2744
    for (i=0; i<ni; i++) {
#line 2744
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2744
     /* test for range errors (not always needed but do it anyway) */
#line 2744
      nrange += xp[i] < FLOAT_MIN || xp[i] > FLOAT_MAX;
#line 2744
    }
#line 2744
   /* update xpp and tp */
#line 2744
    if (realign) xp = (short *) *xpp;
#line 2744
    xp += ni;
#line 2744
    tp += ni;
#line 2744
    *xpp = (void*)xp;
#line 2744
  }
#line 2744
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2744

#line 2744
#else   /* not SX */
#line 2744
	const char *xp = (const char *) *xpp;
#line 2744
	int status = ENOERR;
#line 2744

#line 2744
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2744
	{
#line 2744
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2744
		if(lstatus != ENOERR)
#line 2744
			status = lstatus;
#line 2744
	}
#line 2744

#line 2744
	*xpp = (const void *)xp;
#line 2744
	return status;
#line 2744
#  endif
#line 2744
}
#line 2744

int
#line 2745
ncx_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2745
{
#line 2745
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2745

#line 2745
 /* basic algorithm is:
#line 2745
  *   - ensure sane alignment of input data
#line 2745
  *   - copy (conversion happens automatically) input data
#line 2745
  *     to output
#line 2745
  *   - update xpp to point at next unconverted input, and tp to point
#line 2745
  *     at next location for converted output
#line 2745
  */
#line 2745
  long i, j, ni;
#line 2745
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2745
  short *xp;
#line 2745
  int nrange = 0;         /* number of range errors */
#line 2745
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2745
  long cxp = (long) *((char**)xpp);
#line 2745

#line 2745
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2745
  /* sjl: manually stripmine so we can limit amount of
#line 2745
   * vector work space reserved to LOOPCNT elements. Also
#line 2745
   * makes vectorisation easy */
#line 2745
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2745
    ni=Min(nelems-j,LOOPCNT);
#line 2745
    if (realign) {
#line 2745
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2745
      xp = tmp;
#line 2745
    } else {
#line 2745
      xp = (short *) *xpp;
#line 2745
    }
#line 2745
   /* copy the next block */
#line 2745
#pragma cdir loopcnt=LOOPCNT
#line 2745
#pragma cdir shortloop
#line 2745
    for (i=0; i<ni; i++) {
#line 2745
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2745
     /* test for range errors (not always needed but do it anyway) */
#line 2745
      nrange += xp[i] < DOUBLE_MIN || xp[i] > DOUBLE_MAX;
#line 2745
    }
#line 2745
   /* update xpp and tp */
#line 2745
    if (realign) xp = (short *) *xpp;
#line 2745
    xp += ni;
#line 2745
    tp += ni;
#line 2745
    *xpp = (void*)xp;
#line 2745
  }
#line 2745
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2745

#line 2745
#else   /* not SX */
#line 2745
	const char *xp = (const char *) *xpp;
#line 2745
	int status = ENOERR;
#line 2745

#line 2745
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2745
	{
#line 2745
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2745
		if(lstatus != ENOERR)
#line 2745
			status = lstatus;
#line 2745
	}
#line 2745

#line 2745
	*xpp = (const void *)xp;
#line 2745
	return status;
#line 2745
#  endif
#line 2745
}
#line 2745

int
#line 2746
ncx_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2746
{
#line 2746
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2746

#line 2746
 /* basic algorithm is:
#line 2746
  *   - ensure sane alignment of input data
#line 2746
  *   - copy (conversion happens automatically) input data
#line 2746
  *     to output
#line 2746
  *   - update xpp to point at next unconverted input, and tp to point
#line 2746
  *     at next location for converted output
#line 2746
  */
#line 2746
  long i, j, ni;
#line 2746
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2746
  short *xp;
#line 2746
  int nrange = 0;         /* number of range errors */
#line 2746
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2746
  long cxp = (long) *((char**)xpp);
#line 2746

#line 2746
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2746
  /* sjl: manually stripmine so we can limit amount of
#line 2746
   * vector work space reserved to LOOPCNT elements. Also
#line 2746
   * makes vectorisation easy */
#line 2746
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2746
    ni=Min(nelems-j,LOOPCNT);
#line 2746
    if (realign) {
#line 2746
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2746
      xp = tmp;
#line 2746
    } else {
#line 2746
      xp = (short *) *xpp;
#line 2746
    }
#line 2746
   /* copy the next block */
#line 2746
#pragma cdir loopcnt=LOOPCNT
#line 2746
#pragma cdir shortloop
#line 2746
    for (i=0; i<ni; i++) {
#line 2746
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2746
     /* test for range errors (not always needed but do it anyway) */
#line 2746
      nrange += xp[i] < UINT_MIN || xp[i] > UINT_MAX;
#line 2746
    }
#line 2746
   /* update xpp and tp */
#line 2746
    if (realign) xp = (short *) *xpp;
#line 2746
    xp += ni;
#line 2746
    tp += ni;
#line 2746
    *xpp = (void*)xp;
#line 2746
  }
#line 2746
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2746

#line 2746
#else   /* not SX */
#line 2746
	const char *xp = (const char *) *xpp;
#line 2746
	int status = ENOERR;
#line 2746

#line 2746
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2746
	{
#line 2746
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2746
		if(lstatus != ENOERR)
#line 2746
			status = lstatus;
#line 2746
	}
#line 2746

#line 2746
	*xpp = (const void *)xp;
#line 2746
	return status;
#line 2746
#  endif
#line 2746
}
#line 2746

int
#line 2747
ncx_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2747
{
#line 2747
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2747

#line 2747
 /* basic algorithm is:
#line 2747
  *   - ensure sane alignment of input data
#line 2747
  *   - copy (conversion happens automatically) input data
#line 2747
  *     to output
#line 2747
  *   - update xpp to point at next unconverted input, and tp to point
#line 2747
  *     at next location for converted output
#line 2747
  */
#line 2747
  long i, j, ni;
#line 2747
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2747
  short *xp;
#line 2747
  int nrange = 0;         /* number of range errors */
#line 2747
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2747
  long cxp = (long) *((char**)xpp);
#line 2747

#line 2747
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2747
  /* sjl: manually stripmine so we can limit amount of
#line 2747
   * vector work space reserved to LOOPCNT elements. Also
#line 2747
   * makes vectorisation easy */
#line 2747
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2747
    ni=Min(nelems-j,LOOPCNT);
#line 2747
    if (realign) {
#line 2747
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2747
      xp = tmp;
#line 2747
    } else {
#line 2747
      xp = (short *) *xpp;
#line 2747
    }
#line 2747
   /* copy the next block */
#line 2747
#pragma cdir loopcnt=LOOPCNT
#line 2747
#pragma cdir shortloop
#line 2747
    for (i=0; i<ni; i++) {
#line 2747
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2747
     /* test for range errors (not always needed but do it anyway) */
#line 2747
      nrange += xp[i] < LONGLONG_MIN || xp[i] > LONGLONG_MAX;
#line 2747
    }
#line 2747
   /* update xpp and tp */
#line 2747
    if (realign) xp = (short *) *xpp;
#line 2747
    xp += ni;
#line 2747
    tp += ni;
#line 2747
    *xpp = (void*)xp;
#line 2747
  }
#line 2747
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2747

#line 2747
#else   /* not SX */
#line 2747
	const char *xp = (const char *) *xpp;
#line 2747
	int status = ENOERR;
#line 2747

#line 2747
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2747
	{
#line 2747
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2747
		if(lstatus != ENOERR)
#line 2747
			status = lstatus;
#line 2747
	}
#line 2747

#line 2747
	*xpp = (const void *)xp;
#line 2747
	return status;
#line 2747
#  endif
#line 2747
}
#line 2747

int
#line 2748
ncx_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2748
{
#line 2748
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2748

#line 2748
 /* basic algorithm is:
#line 2748
  *   - ensure sane alignment of input data
#line 2748
  *   - copy (conversion happens automatically) input data
#line 2748
  *     to output
#line 2748
  *   - update xpp to point at next unconverted input, and tp to point
#line 2748
  *     at next location for converted output
#line 2748
  */
#line 2748
  long i, j, ni;
#line 2748
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2748
  short *xp;
#line 2748
  int nrange = 0;         /* number of range errors */
#line 2748
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2748
  long cxp = (long) *((char**)xpp);
#line 2748

#line 2748
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2748
  /* sjl: manually stripmine so we can limit amount of
#line 2748
   * vector work space reserved to LOOPCNT elements. Also
#line 2748
   * makes vectorisation easy */
#line 2748
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2748
    ni=Min(nelems-j,LOOPCNT);
#line 2748
    if (realign) {
#line 2748
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2748
      xp = tmp;
#line 2748
    } else {
#line 2748
      xp = (short *) *xpp;
#line 2748
    }
#line 2748
   /* copy the next block */
#line 2748
#pragma cdir loopcnt=LOOPCNT
#line 2748
#pragma cdir shortloop
#line 2748
    for (i=0; i<ni; i++) {
#line 2748
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2748
     /* test for range errors (not always needed but do it anyway) */
#line 2748
      nrange += xp[i] < ULONGLONG_MIN || xp[i] > ULONGLONG_MAX;
#line 2748
    }
#line 2748
   /* update xpp and tp */
#line 2748
    if (realign) xp = (short *) *xpp;
#line 2748
    xp += ni;
#line 2748
    tp += ni;
#line 2748
    *xpp = (void*)xp;
#line 2748
  }
#line 2748
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2748

#line 2748
#else   /* not SX */
#line 2748
	const char *xp = (const char *) *xpp;
#line 2748
	int status = ENOERR;
#line 2748

#line 2748
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2748
	{
#line 2748
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2748
		if(lstatus != ENOERR)
#line 2748
			status = lstatus;
#line 2748
	}
#line 2748

#line 2748
	*xpp = (const void *)xp;
#line 2748
	return status;
#line 2748
#  endif
#line 2748
}
#line 2748


int
#line 2750
ncx_pad_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2750
{
#line 2750
	const size_t rndup = nelems % 2;
#line 2750

#line 2750
	const char *xp = (const char *) *xpp;
#line 2750
	int status = ENOERR;
#line 2750

#line 2750
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2750
	{
#line 2750
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2750
		if(lstatus != ENOERR)
#line 2750
			status = lstatus;
#line 2750
	}
#line 2750

#line 2750
	if(rndup != 0)
#line 2750
		xp += X_SIZEOF_SHORT;
#line 2750

#line 2750
	*xpp = (void *)xp;
#line 2750
	return status;
#line 2750
}
#line 2750

int
#line 2751
ncx_pad_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2751
{
#line 2751
	const size_t rndup = nelems % 2;
#line 2751

#line 2751
	const char *xp = (const char *) *xpp;
#line 2751
	int status = ENOERR;
#line 2751

#line 2751
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2751
	{
#line 2751
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2751
		if(lstatus != ENOERR)
#line 2751
			status = lstatus;
#line 2751
	}
#line 2751

#line 2751
	if(rndup != 0)
#line 2751
		xp += X_SIZEOF_SHORT;
#line 2751

#line 2751
	*xpp = (void *)xp;
#line 2751
	return status;
#line 2751
}
#line 2751

int
#line 2752
ncx_pad_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2752
{
#line 2752
	const size_t rndup = nelems % 2;
#line 2752

#line 2752
	const char *xp = (const char *) *xpp;
#line 2752
	int status = ENOERR;
#line 2752

#line 2752
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2752
	{
#line 2752
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2752
		if(lstatus != ENOERR)
#line 2752
			status = lstatus;
#line 2752
	}
#line 2752

#line 2752
	if(rndup != 0)
#line 2752
		xp += X_SIZEOF_SHORT;
#line 2752

#line 2752
	*xpp = (void *)xp;
#line 2752
	return status;
#line 2752
}
#line 2752

int
#line 2753
ncx_pad_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2753
{
#line 2753
	const size_t rndup = nelems % 2;
#line 2753

#line 2753
	const char *xp = (const char *) *xpp;
#line 2753
	int status = ENOERR;
#line 2753

#line 2753
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2753
	{
#line 2753
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2753
		if(lstatus != ENOERR)
#line 2753
			status = lstatus;
#line 2753
	}
#line 2753

#line 2753
	if(rndup != 0)
#line 2753
		xp += X_SIZEOF_SHORT;
#line 2753

#line 2753
	*xpp = (void *)xp;
#line 2753
	return status;
#line 2753
}
#line 2753

int
#line 2754
ncx_pad_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2754
{
#line 2754
	const size_t rndup = nelems % 2;
#line 2754

#line 2754
	const char *xp = (const char *) *xpp;
#line 2754
	int status = ENOERR;
#line 2754

#line 2754
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2754
	{
#line 2754
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2754
		if(lstatus != ENOERR)
#line 2754
			status = lstatus;
#line 2754
	}
#line 2754

#line 2754
	if(rndup != 0)
#line 2754
		xp += X_SIZEOF_SHORT;
#line 2754

#line 2754
	*xpp = (void *)xp;
#line 2754
	return status;
#line 2754
}
#line 2754

int
#line 2755
ncx_pad_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2755
{
#line 2755
	const size_t rndup = nelems % 2;
#line 2755

#line 2755
	const char *xp = (const char *) *xpp;
#line 2755
	int status = ENOERR;
#line 2755

#line 2755
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2755
	{
#line 2755
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2755
		if(lstatus != ENOERR)
#line 2755
			status = lstatus;
#line 2755
	}
#line 2755

#line 2755
	if(rndup != 0)
#line 2755
		xp += X_SIZEOF_SHORT;
#line 2755

#line 2755
	*xpp = (void *)xp;
#line 2755
	return status;
#line 2755
}
#line 2755

int
#line 2756
ncx_pad_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2756
{
#line 2756
	const size_t rndup = nelems % 2;
#line 2756

#line 2756
	const char *xp = (const char *) *xpp;
#line 2756
	int status = ENOERR;
#line 2756

#line 2756
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2756
	{
#line 2756
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2756
		if(lstatus != ENOERR)
#line 2756
			status = lstatus;
#line 2756
	}
#line 2756

#line 2756
	if(rndup != 0)
#line 2756
		xp += X_SIZEOF_SHORT;
#line 2756

#line 2756
	*xpp = (void *)xp;
#line 2756
	return status;
#line 2756
}
#line 2756

int
#line 2757
ncx_pad_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2757
{
#line 2757
	const size_t rndup = nelems % 2;
#line 2757

#line 2757
	const char *xp = (const char *) *xpp;
#line 2757
	int status = ENOERR;
#line 2757

#line 2757
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2757
	{
#line 2757
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2757
		if(lstatus != ENOERR)
#line 2757
			status = lstatus;
#line 2757
	}
#line 2757

#line 2757
	if(rndup != 0)
#line 2757
		xp += X_SIZEOF_SHORT;
#line 2757

#line 2757
	*xpp = (void *)xp;
#line 2757
	return status;
#line 2757
}
#line 2757

int
#line 2758
ncx_pad_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2758
{
#line 2758
	const size_t rndup = nelems % 2;
#line 2758

#line 2758
	const char *xp = (const char *) *xpp;
#line 2758
	int status = ENOERR;
#line 2758

#line 2758
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2758
	{
#line 2758
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2758
		if(lstatus != ENOERR)
#line 2758
			status = lstatus;
#line 2758
	}
#line 2758

#line 2758
	if(rndup != 0)
#line 2758
		xp += X_SIZEOF_SHORT;
#line 2758

#line 2758
	*xpp = (void *)xp;
#line 2758
	return status;
#line 2758
}
#line 2758


int
#line 2760
ncx_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2760
{
#line 2760
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2760

#line 2760
 /* basic algorithm is:
#line 2760
  *   - ensure sane alignment of output data
#line 2760
  *   - copy (conversion happens automatically) input data
#line 2760
  *     to output
#line 2760
  *   - update tp to point at next unconverted input, and xpp to point
#line 2760
  *     at next location for converted output
#line 2760
  */
#line 2760
  long i, j, ni;
#line 2760
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2760
  short *xp;
#line 2760
  int nrange = 0;         /* number of range errors */
#line 2760
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2760
  long cxp = (long) *((char**)xpp);
#line 2760

#line 2760
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2760
  /* sjl: manually stripmine so we can limit amount of
#line 2760
   * vector work space reserved to LOOPCNT elements. Also
#line 2760
   * makes vectorisation easy */
#line 2760
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2760
    ni=Min(nelems-j,LOOPCNT);
#line 2760
    if (realign) {
#line 2760
      xp = tmp;
#line 2760
    } else {
#line 2760
      xp = (short *) *xpp;
#line 2760
    }
#line 2760
   /* copy the next block */
#line 2760
#pragma cdir loopcnt=LOOPCNT
#line 2760
#pragma cdir shortloop
#line 2760
    for (i=0; i<ni; i++) {
#line 2760
      /* the normal case: */
#line 2760
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2760
     /* test for range errors (not always needed but do it anyway) */
#line 2760
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2760
    }
#line 2760
   /* copy workspace back if necessary */
#line 2760
    if (realign) {
#line 2760
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2760
      xp = (short *) *xpp;
#line 2760
    }
#line 2760
   /* update xpp and tp */
#line 2760
    xp += ni;
#line 2760
    tp += ni;
#line 2760
    *xpp = (void*)xp;
#line 2760
  }
#line 2760
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2760

#line 2760
#else   /* not SX */
#line 2760

#line 2760
	char *xp = (char *) *xpp;
#line 2760
	int status = ENOERR;
#line 2760

#line 2760
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2760
	{
#line 2760
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2760
		if(lstatus != ENOERR)
#line 2760
			status = lstatus;
#line 2760
	}
#line 2760

#line 2760
	*xpp = (void *)xp;
#line 2760
	return status;
#line 2760
#endif
#line 2760
}
#line 2760

int
#line 2761
ncx_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2761
{
#line 2761
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2761

#line 2761
 /* basic algorithm is:
#line 2761
  *   - ensure sane alignment of output data
#line 2761
  *   - copy (conversion happens automatically) input data
#line 2761
  *     to output
#line 2761
  *   - update tp to point at next unconverted input, and xpp to point
#line 2761
  *     at next location for converted output
#line 2761
  */
#line 2761
  long i, j, ni;
#line 2761
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2761
  short *xp;
#line 2761
  int nrange = 0;         /* number of range errors */
#line 2761
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2761
  long cxp = (long) *((char**)xpp);
#line 2761

#line 2761
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2761
  /* sjl: manually stripmine so we can limit amount of
#line 2761
   * vector work space reserved to LOOPCNT elements. Also
#line 2761
   * makes vectorisation easy */
#line 2761
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2761
    ni=Min(nelems-j,LOOPCNT);
#line 2761
    if (realign) {
#line 2761
      xp = tmp;
#line 2761
    } else {
#line 2761
      xp = (short *) *xpp;
#line 2761
    }
#line 2761
   /* copy the next block */
#line 2761
#pragma cdir loopcnt=LOOPCNT
#line 2761
#pragma cdir shortloop
#line 2761
    for (i=0; i<ni; i++) {
#line 2761
      /* the normal case: */
#line 2761
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2761
     /* test for range errors (not always needed but do it anyway) */
#line 2761
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2761
    }
#line 2761
   /* copy workspace back if necessary */
#line 2761
    if (realign) {
#line 2761
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2761
      xp = (short *) *xpp;
#line 2761
    }
#line 2761
   /* update xpp and tp */
#line 2761
    xp += ni;
#line 2761
    tp += ni;
#line 2761
    *xpp = (void*)xp;
#line 2761
  }
#line 2761
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2761

#line 2761
#else   /* not SX */
#line 2761

#line 2761
	char *xp = (char *) *xpp;
#line 2761
	int status = ENOERR;
#line 2761

#line 2761
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2761
	{
#line 2761
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2761
		if(lstatus != ENOERR)
#line 2761
			status = lstatus;
#line 2761
	}
#line 2761

#line 2761
	*xpp = (void *)xp;
#line 2761
	return status;
#line 2761
#endif
#line 2761
}
#line 2761

#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_SHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2776
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2776
{
#line 2776
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2776

#line 2776
 /* basic algorithm is:
#line 2776
  *   - ensure sane alignment of output data
#line 2776
  *   - copy (conversion happens automatically) input data
#line 2776
  *     to output
#line 2776
  *   - update tp to point at next unconverted input, and xpp to point
#line 2776
  *     at next location for converted output
#line 2776
  */
#line 2776
  long i, j, ni;
#line 2776
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2776
  short *xp;
#line 2776
  int nrange = 0;         /* number of range errors */
#line 2776
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2776
  long cxp = (long) *((char**)xpp);
#line 2776

#line 2776
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2776
  /* sjl: manually stripmine so we can limit amount of
#line 2776
   * vector work space reserved to LOOPCNT elements. Also
#line 2776
   * makes vectorisation easy */
#line 2776
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2776
    ni=Min(nelems-j,LOOPCNT);
#line 2776
    if (realign) {
#line 2776
      xp = tmp;
#line 2776
    } else {
#line 2776
      xp = (short *) *xpp;
#line 2776
    }
#line 2776
   /* copy the next block */
#line 2776
#pragma cdir loopcnt=LOOPCNT
#line 2776
#pragma cdir shortloop
#line 2776
    for (i=0; i<ni; i++) {
#line 2776
      /* the normal case: */
#line 2776
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2776
     /* test for range errors (not always needed but do it anyway) */
#line 2776
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2776
    }
#line 2776
   /* copy workspace back if necessary */
#line 2776
    if (realign) {
#line 2776
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2776
      xp = (short *) *xpp;
#line 2776
    }
#line 2776
   /* update xpp and tp */
#line 2776
    xp += ni;
#line 2776
    tp += ni;
#line 2776
    *xpp = (void*)xp;
#line 2776
  }
#line 2776
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2776

#line 2776
#else   /* not SX */
#line 2776

#line 2776
	char *xp = (char *) *xpp;
#line 2776
	int status = ENOERR;
#line 2776

#line 2776
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2776
	{
#line 2776
		int lstatus = ncx_put_short_short(xp, tp);
#line 2776
		if(lstatus != ENOERR)
#line 2776
			status = lstatus;
#line 2776
	}
#line 2776

#line 2776
	*xpp = (void *)xp;
#line 2776
	return status;
#line 2776
#endif
#line 2776
}
#line 2776

#endif
int
#line 2778
ncx_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2778
{
#line 2778
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2778

#line 2778
 /* basic algorithm is:
#line 2778
  *   - ensure sane alignment of output data
#line 2778
  *   - copy (conversion happens automatically) input data
#line 2778
  *     to output
#line 2778
  *   - update tp to point at next unconverted input, and xpp to point
#line 2778
  *     at next location for converted output
#line 2778
  */
#line 2778
  long i, j, ni;
#line 2778
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2778
  short *xp;
#line 2778
  int nrange = 0;         /* number of range errors */
#line 2778
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2778
  long cxp = (long) *((char**)xpp);
#line 2778

#line 2778
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2778
  /* sjl: manually stripmine so we can limit amount of
#line 2778
   * vector work space reserved to LOOPCNT elements. Also
#line 2778
   * makes vectorisation easy */
#line 2778
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2778
    ni=Min(nelems-j,LOOPCNT);
#line 2778
    if (realign) {
#line 2778
      xp = tmp;
#line 2778
    } else {
#line 2778
      xp = (short *) *xpp;
#line 2778
    }
#line 2778
   /* copy the next block */
#line 2778
#pragma cdir loopcnt=LOOPCNT
#line 2778
#pragma cdir shortloop
#line 2778
    for (i=0; i<ni; i++) {
#line 2778
      /* the normal case: */
#line 2778
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2778
     /* test for range errors (not always needed but do it anyway) */
#line 2778
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2778
    }
#line 2778
   /* copy workspace back if necessary */
#line 2778
    if (realign) {
#line 2778
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2778
      xp = (short *) *xpp;
#line 2778
    }
#line 2778
   /* update xpp and tp */
#line 2778
    xp += ni;
#line 2778
    tp += ni;
#line 2778
    *xpp = (void*)xp;
#line 2778
  }
#line 2778
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2778

#line 2778
#else   /* not SX */
#line 2778

#line 2778
	char *xp = (char *) *xpp;
#line 2778
	int status = ENOERR;
#line 2778

#line 2778
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2778
	{
#line 2778
		int lstatus = ncx_put_short_int(xp, tp);
#line 2778
		if(lstatus != ENOERR)
#line 2778
			status = lstatus;
#line 2778
	}
#line 2778

#line 2778
	*xpp = (void *)xp;
#line 2778
	return status;
#line 2778
#endif
#line 2778
}
#line 2778

int
#line 2779
ncx_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2779
{
#line 2779
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2779

#line 2779
 /* basic algorithm is:
#line 2779
  *   - ensure sane alignment of output data
#line 2779
  *   - copy (conversion happens automatically) input data
#line 2779
  *     to output
#line 2779
  *   - update tp to point at next unconverted input, and xpp to point
#line 2779
  *     at next location for converted output
#line 2779
  */
#line 2779
  long i, j, ni;
#line 2779
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2779
  short *xp;
#line 2779
  int nrange = 0;         /* number of range errors */
#line 2779
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2779
  long cxp = (long) *((char**)xpp);
#line 2779

#line 2779
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2779
  /* sjl: manually stripmine so we can limit amount of
#line 2779
   * vector work space reserved to LOOPCNT elements. Also
#line 2779
   * makes vectorisation easy */
#line 2779
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2779
    ni=Min(nelems-j,LOOPCNT);
#line 2779
    if (realign) {
#line 2779
      xp = tmp;
#line 2779
    } else {
#line 2779
      xp = (short *) *xpp;
#line 2779
    }
#line 2779
   /* copy the next block */
#line 2779
#pragma cdir loopcnt=LOOPCNT
#line 2779
#pragma cdir shortloop
#line 2779
    for (i=0; i<ni; i++) {
#line 2779
      /* the normal case: */
#line 2779
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2779
     /* test for range errors (not always needed but do it anyway) */
#line 2779
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2779
    }
#line 2779
   /* copy workspace back if necessary */
#line 2779
    if (realign) {
#line 2779
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2779
      xp = (short *) *xpp;
#line 2779
    }
#line 2779
   /* update xpp and tp */
#line 2779
    xp += ni;
#line 2779
    tp += ni;
#line 2779
    *xpp = (void*)xp;
#line 2779
  }
#line 2779
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2779

#line 2779
#else   /* not SX */
#line 2779

#line 2779
	char *xp = (char *) *xpp;
#line 2779
	int status = ENOERR;
#line 2779

#line 2779
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2779
	{
#line 2779
		int lstatus = ncx_put_short_float(xp, tp);
#line 2779
		if(lstatus != ENOERR)
#line 2779
			status = lstatus;
#line 2779
	}
#line 2779

#line 2779
	*xpp = (void *)xp;
#line 2779
	return status;
#line 2779
#endif
#line 2779
}
#line 2779

int
#line 2780
ncx_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2780
{
#line 2780
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2780

#line 2780
 /* basic algorithm is:
#line 2780
  *   - ensure sane alignment of output data
#line 2780
  *   - copy (conversion happens automatically) input data
#line 2780
  *     to output
#line 2780
  *   - update tp to point at next unconverted input, and xpp to point
#line 2780
  *     at next location for converted output
#line 2780
  */
#line 2780
  long i, j, ni;
#line 2780
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2780
  short *xp;
#line 2780
  int nrange = 0;         /* number of range errors */
#line 2780
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2780
  long cxp = (long) *((char**)xpp);
#line 2780

#line 2780
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2780
  /* sjl: manually stripmine so we can limit amount of
#line 2780
   * vector work space reserved to LOOPCNT elements. Also
#line 2780
   * makes vectorisation easy */
#line 2780
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2780
    ni=Min(nelems-j,LOOPCNT);
#line 2780
    if (realign) {
#line 2780
      xp = tmp;
#line 2780
    } else {
#line 2780
      xp = (short *) *xpp;
#line 2780
    }
#line 2780
   /* copy the next block */
#line 2780
#pragma cdir loopcnt=LOOPCNT
#line 2780
#pragma cdir shortloop
#line 2780
    for (i=0; i<ni; i++) {
#line 2780
      /* the normal case: */
#line 2780
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2780
     /* test for range errors (not always needed but do it anyway) */
#line 2780
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2780
    }
#line 2780
   /* copy workspace back if necessary */
#line 2780
    if (realign) {
#line 2780
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2780
      xp = (short *) *xpp;
#line 2780
    }
#line 2780
   /* update xpp and tp */
#line 2780
    xp += ni;
#line 2780
    tp += ni;
#line 2780
    *xpp = (void*)xp;
#line 2780
  }
#line 2780
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2780

#line 2780
#else   /* not SX */
#line 2780

#line 2780
	char *xp = (char *) *xpp;
#line 2780
	int status = ENOERR;
#line 2780

#line 2780
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2780
	{
#line 2780
		int lstatus = ncx_put_short_double(xp, tp);
#line 2780
		if(lstatus != ENOERR)
#line 2780
			status = lstatus;
#line 2780
	}
#line 2780

#line 2780
	*xpp = (void *)xp;
#line 2780
	return status;
#line 2780
#endif
#line 2780
}
#line 2780

int
#line 2781
ncx_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2781
{
#line 2781
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2781

#line 2781
 /* basic algorithm is:
#line 2781
  *   - ensure sane alignment of output data
#line 2781
  *   - copy (conversion happens automatically) input data
#line 2781
  *     to output
#line 2781
  *   - update tp to point at next unconverted input, and xpp to point
#line 2781
  *     at next location for converted output
#line 2781
  */
#line 2781
  long i, j, ni;
#line 2781
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2781
  short *xp;
#line 2781
  int nrange = 0;         /* number of range errors */
#line 2781
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2781
  long cxp = (long) *((char**)xpp);
#line 2781

#line 2781
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2781
  /* sjl: manually stripmine so we can limit amount of
#line 2781
   * vector work space reserved to LOOPCNT elements. Also
#line 2781
   * makes vectorisation easy */
#line 2781
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2781
    ni=Min(nelems-j,LOOPCNT);
#line 2781
    if (realign) {
#line 2781
      xp = tmp;
#line 2781
    } else {
#line 2781
      xp = (short *) *xpp;
#line 2781
    }
#line 2781
   /* copy the next block */
#line 2781
#pragma cdir loopcnt=LOOPCNT
#line 2781
#pragma cdir shortloop
#line 2781
    for (i=0; i<ni; i++) {
#line 2781
      /* the normal case: */
#line 2781
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2781
     /* test for range errors (not always needed but do it anyway) */
#line 2781
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2781
    }
#line 2781
   /* copy workspace back if necessary */
#line 2781
    if (realign) {
#line 2781
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2781
      xp = (short *) *xpp;
#line 2781
    }
#line 2781
   /* update xpp and tp */
#line 2781
    xp += ni;
#line 2781
    tp += ni;
#line 2781
    *xpp = (void*)xp;
#line 2781
  }
#line 2781
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2781

#line 2781
#else   /* not SX */
#line 2781

#line 2781
	char *xp = (char *) *xpp;
#line 2781
	int status = ENOERR;
#line 2781

#line 2781
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2781
	{
#line 2781
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2781
		if(lstatus != ENOERR)
#line 2781
			status = lstatus;
#line 2781
	}
#line 2781

#line 2781
	*xpp = (void *)xp;
#line 2781
	return status;
#line 2781
#endif
#line 2781
}
#line 2781

int
#line 2782
ncx_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2782
{
#line 2782
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2782

#line 2782
 /* basic algorithm is:
#line 2782
  *   - ensure sane alignment of output data
#line 2782
  *   - copy (conversion happens automatically) input data
#line 2782
  *     to output
#line 2782
  *   - update tp to point at next unconverted input, and xpp to point
#line 2782
  *     at next location for converted output
#line 2782
  */
#line 2782
  long i, j, ni;
#line 2782
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2782
  short *xp;
#line 2782
  int nrange = 0;         /* number of range errors */
#line 2782
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2782
  long cxp = (long) *((char**)xpp);
#line 2782

#line 2782
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2782
  /* sjl: manually stripmine so we can limit amount of
#line 2782
   * vector work space reserved to LOOPCNT elements. Also
#line 2782
   * makes vectorisation easy */
#line 2782
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2782
    ni=Min(nelems-j,LOOPCNT);
#line 2782
    if (realign) {
#line 2782
      xp = tmp;
#line 2782
    } else {
#line 2782
      xp = (short *) *xpp;
#line 2782
    }
#line 2782
   /* copy the next block */
#line 2782
#pragma cdir loopcnt=LOOPCNT
#line 2782
#pragma cdir shortloop
#line 2782
    for (i=0; i<ni; i++) {
#line 2782
      /* the normal case: */
#line 2782
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2782
     /* test for range errors (not always needed but do it anyway) */
#line 2782
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2782
    }
#line 2782
   /* copy workspace back if necessary */
#line 2782
    if (realign) {
#line 2782
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2782
      xp = (short *) *xpp;
#line 2782
    }
#line 2782
   /* update xpp and tp */
#line 2782
    xp += ni;
#line 2782
    tp += ni;
#line 2782
    *xpp = (void*)xp;
#line 2782
  }
#line 2782
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2782

#line 2782
#else   /* not SX */
#line 2782

#line 2782
	char *xp = (char *) *xpp;
#line 2782
	int status = ENOERR;
#line 2782

#line 2782
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2782
	{
#line 2782
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2782
		if(lstatus != ENOERR)
#line 2782
			status = lstatus;
#line 2782
	}
#line 2782

#line 2782
	*xpp = (void *)xp;
#line 2782
	return status;
#line 2782
#endif
#line 2782
}
#line 2782

int
#line 2783
ncx_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2783
{
#line 2783
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2783

#line 2783
 /* basic algorithm is:
#line 2783
  *   - ensure sane alignment of output data
#line 2783
  *   - copy (conversion happens automatically) input data
#line 2783
  *     to output
#line 2783
  *   - update tp to point at next unconverted input, and xpp to point
#line 2783
  *     at next location for converted output
#line 2783
  */
#line 2783
  long i, j, ni;
#line 2783
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2783
  short *xp;
#line 2783
  int nrange = 0;         /* number of range errors */
#line 2783
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2783
  long cxp = (long) *((char**)xpp);
#line 2783

#line 2783
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2783
  /* sjl: manually stripmine so we can limit amount of
#line 2783
   * vector work space reserved to LOOPCNT elements. Also
#line 2783
   * makes vectorisation easy */
#line 2783
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2783
    ni=Min(nelems-j,LOOPCNT);
#line 2783
    if (realign) {
#line 2783
      xp = tmp;
#line 2783
    } else {
#line 2783
      xp = (short *) *xpp;
#line 2783
    }
#line 2783
   /* copy the next block */
#line 2783
#pragma cdir loopcnt=LOOPCNT
#line 2783
#pragma cdir shortloop
#line 2783
    for (i=0; i<ni; i++) {
#line 2783
      /* the normal case: */
#line 2783
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2783
     /* test for range errors (not always needed but do it anyway) */
#line 2783
      nrange += tp[i] < X_SHORT_MIN || tp[i] > X_SHORT_MAX;
#line 2783
    }
#line 2783
   /* copy workspace back if necessary */
#line 2783
    if (realign) {
#line 2783
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2783
      xp = (short *) *xpp;
#line 2783
    }
#line 2783
   /* update xpp and tp */
#line 2783
    xp += ni;
#line 2783
    tp += ni;
#line 2783
    *xpp = (void*)xp;
#line 2783
  }
#line 2783
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2783

#line 2783
#else   /* not SX */
#line 2783

#line 2783
	char *xp = (char *) *xpp;
#line 2783
	int status = ENOERR;
#line 2783

#line 2783
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2783
	{
#line 2783
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2783
		if(lstatus != ENOERR)
#line 2783
			status = lstatus;
#line 2783
	}
#line 2783

#line 2783
	*xpp = (void *)xp;
#line 2783
	return status;
#line 2783
#endif
#line 2783
}
#line 2783


int
#line 2785
ncx_pad_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2785
{
#line 2785
	const size_t rndup = nelems % 2;
#line 2785

#line 2785
	char *xp = (char *) *xpp;
#line 2785
	int status = ENOERR;
#line 2785

#line 2785
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2785
	{
#line 2785
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2785
		if(lstatus != ENOERR)
#line 2785
			status = lstatus;
#line 2785
	}
#line 2785

#line 2785
	if(rndup != 0)
#line 2785
	{
#line 2785
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2785
		xp += X_SIZEOF_SHORT;
#line 2785
	}
#line 2785

#line 2785
	*xpp = (void *)xp;
#line 2785
	return status;
#line 2785
}
#line 2785

int
#line 2786
ncx_pad_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2786
{
#line 2786
	const size_t rndup = nelems % 2;
#line 2786

#line 2786
	char *xp = (char *) *xpp;
#line 2786
	int status = ENOERR;
#line 2786

#line 2786
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2786
	{
#line 2786
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2786
		if(lstatus != ENOERR)
#line 2786
			status = lstatus;
#line 2786
	}
#line 2786

#line 2786
	if(rndup != 0)
#line 2786
	{
#line 2786
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2786
		xp += X_SIZEOF_SHORT;
#line 2786
	}
#line 2786

#line 2786
	*xpp = (void *)xp;
#line 2786
	return status;
#line 2786
}
#line 2786

int
#line 2787
ncx_pad_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2787
{
#line 2787
	const size_t rndup = nelems % 2;
#line 2787

#line 2787
	char *xp = (char *) *xpp;
#line 2787
	int status = ENOERR;
#line 2787

#line 2787
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2787
	{
#line 2787
		int lstatus = ncx_put_short_short(xp, tp);
#line 2787
		if(lstatus != ENOERR)
#line 2787
			status = lstatus;
#line 2787
	}
#line 2787

#line 2787
	if(rndup != 0)
#line 2787
	{
#line 2787
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2787
		xp += X_SIZEOF_SHORT;
#line 2787
	}
#line 2787

#line 2787
	*xpp = (void *)xp;
#line 2787
	return status;
#line 2787
}
#line 2787

int
#line 2788
ncx_pad_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2788
{
#line 2788
	const size_t rndup = nelems % 2;
#line 2788

#line 2788
	char *xp = (char *) *xpp;
#line 2788
	int status = ENOERR;
#line 2788

#line 2788
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2788
	{
#line 2788
		int lstatus = ncx_put_short_int(xp, tp);
#line 2788
		if(lstatus != ENOERR)
#line 2788
			status = lstatus;
#line 2788
	}
#line 2788

#line 2788
	if(rndup != 0)
#line 2788
	{
#line 2788
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2788
		xp += X_SIZEOF_SHORT;
#line 2788
	}
#line 2788

#line 2788
	*xpp = (void *)xp;
#line 2788
	return status;
#line 2788
}
#line 2788

int
#line 2789
ncx_pad_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2789
{
#line 2789
	const size_t rndup = nelems % 2;
#line 2789

#line 2789
	char *xp = (char *) *xpp;
#line 2789
	int status = ENOERR;
#line 2789

#line 2789
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2789
	{
#line 2789
		int lstatus = ncx_put_short_float(xp, tp);
#line 2789
		if(lstatus != ENOERR)
#line 2789
			status = lstatus;
#line 2789
	}
#line 2789

#line 2789
	if(rndup != 0)
#line 2789
	{
#line 2789
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2789
		xp += X_SIZEOF_SHORT;
#line 2789
	}
#line 2789

#line 2789
	*xpp = (void *)xp;
#line 2789
	return status;
#line 2789
}
#line 2789

int
#line 2790
ncx_pad_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2790
{
#line 2790
	const size_t rndup = nelems % 2;
#line 2790

#line 2790
	char *xp = (char *) *xpp;
#line 2790
	int status = ENOERR;
#line 2790

#line 2790
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2790
	{
#line 2790
		int lstatus = ncx_put_short_double(xp, tp);
#line 2790
		if(lstatus != ENOERR)
#line 2790
			status = lstatus;
#line 2790
	}
#line 2790

#line 2790
	if(rndup != 0)
#line 2790
	{
#line 2790
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2790
		xp += X_SIZEOF_SHORT;
#line 2790
	}
#line 2790

#line 2790
	*xpp = (void *)xp;
#line 2790
	return status;
#line 2790
}
#line 2790

int
#line 2791
ncx_pad_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2791
{
#line 2791
	const size_t rndup = nelems % 2;
#line 2791

#line 2791
	char *xp = (char *) *xpp;
#line 2791
	int status = ENOERR;
#line 2791

#line 2791
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2791
	{
#line 2791
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2791
		if(lstatus != ENOERR)
#line 2791
			status = lstatus;
#line 2791
	}
#line 2791

#line 2791
	if(rndup != 0)
#line 2791
	{
#line 2791
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2791
		xp += X_SIZEOF_SHORT;
#line 2791
	}
#line 2791

#line 2791
	*xpp = (void *)xp;
#line 2791
	return status;
#line 2791
}
#line 2791

int
#line 2792
ncx_pad_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2792
{
#line 2792
	const size_t rndup = nelems % 2;
#line 2792

#line 2792
	char *xp = (char *) *xpp;
#line 2792
	int status = ENOERR;
#line 2792

#line 2792
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2792
	{
#line 2792
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2792
		if(lstatus != ENOERR)
#line 2792
			status = lstatus;
#line 2792
	}
#line 2792

#line 2792
	if(rndup != 0)
#line 2792
	{
#line 2792
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2792
		xp += X_SIZEOF_SHORT;
#line 2792
	}
#line 2792

#line 2792
	*xpp = (void *)xp;
#line 2792
	return status;
#line 2792
}
#line 2792

int
#line 2793
ncx_pad_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2793
{
#line 2793
	const size_t rndup = nelems % 2;
#line 2793

#line 2793
	char *xp = (char *) *xpp;
#line 2793
	int status = ENOERR;
#line 2793

#line 2793
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2793
	{
#line 2793
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2793
		if(lstatus != ENOERR)
#line 2793
			status = lstatus;
#line 2793
	}
#line 2793

#line 2793
	if(rndup != 0)
#line 2793
	{
#line 2793
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2793
		xp += X_SIZEOF_SHORT;
#line 2793
	}
#line 2793

#line 2793
	*xpp = (void *)xp;
#line 2793
	return status;
#line 2793
}
#line 2793



/* int */

int
#line 2798
ncx_getn_int_schar(const void **xpp, size_t nelems, schar *tp)
#line 2798
{
#line 2798
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2798

#line 2798
 /* basic algorithm is:
#line 2798
  *   - ensure sane alignment of input data
#line 2798
  *   - copy (conversion happens automatically) input data
#line 2798
  *     to output
#line 2798
  *   - update xpp to point at next unconverted input, and tp to point
#line 2798
  *     at next location for converted output
#line 2798
  */
#line 2798
  long i, j, ni;
#line 2798
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2798
  int *xp;
#line 2798
  int nrange = 0;         /* number of range errors */
#line 2798
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2798
  long cxp = (long) *((char**)xpp);
#line 2798

#line 2798
  realign = (cxp & 7) % SIZEOF_INT;
#line 2798
  /* sjl: manually stripmine so we can limit amount of
#line 2798
   * vector work space reserved to LOOPCNT elements. Also
#line 2798
   * makes vectorisation easy */
#line 2798
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2798
    ni=Min(nelems-j,LOOPCNT);
#line 2798
    if (realign) {
#line 2798
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2798
      xp = tmp;
#line 2798
    } else {
#line 2798
      xp = (int *) *xpp;
#line 2798
    }
#line 2798
   /* copy the next block */
#line 2798
#pragma cdir loopcnt=LOOPCNT
#line 2798
#pragma cdir shortloop
#line 2798
    for (i=0; i<ni; i++) {
#line 2798
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2798
     /* test for range errors (not always needed but do it anyway) */
#line 2798
      nrange += xp[i] < SCHAR_MIN || xp[i] > SCHAR_MAX;
#line 2798
    }
#line 2798
   /* update xpp and tp */
#line 2798
    if (realign) xp = (int *) *xpp;
#line 2798
    xp += ni;
#line 2798
    tp += ni;
#line 2798
    *xpp = (void*)xp;
#line 2798
  }
#line 2798
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2798

#line 2798
#else   /* not SX */
#line 2798
	const char *xp = (const char *) *xpp;
#line 2798
	int status = ENOERR;
#line 2798

#line 2798
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2798
	{
#line 2798
		const int lstatus = ncx_get_int_schar(xp, tp);
#line 2798
		if(lstatus != ENOERR)
#line 2798
			status = lstatus;
#line 2798
	}
#line 2798

#line 2798
	*xpp = (const void *)xp;
#line 2798
	return status;
#line 2798
#  endif
#line 2798
}
#line 2798

int
#line 2799
ncx_getn_int_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2799
{
#line 2799
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2799

#line 2799
 /* basic algorithm is:
#line 2799
  *   - ensure sane alignment of input data
#line 2799
  *   - copy (conversion happens automatically) input data
#line 2799
  *     to output
#line 2799
  *   - update xpp to point at next unconverted input, and tp to point
#line 2799
  *     at next location for converted output
#line 2799
  */
#line 2799
  long i, j, ni;
#line 2799
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2799
  int *xp;
#line 2799
  int nrange = 0;         /* number of range errors */
#line 2799
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2799
  long cxp = (long) *((char**)xpp);
#line 2799

#line 2799
  realign = (cxp & 7) % SIZEOF_INT;
#line 2799
  /* sjl: manually stripmine so we can limit amount of
#line 2799
   * vector work space reserved to LOOPCNT elements. Also
#line 2799
   * makes vectorisation easy */
#line 2799
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2799
    ni=Min(nelems-j,LOOPCNT);
#line 2799
    if (realign) {
#line 2799
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2799
      xp = tmp;
#line 2799
    } else {
#line 2799
      xp = (int *) *xpp;
#line 2799
    }
#line 2799
   /* copy the next block */
#line 2799
#pragma cdir loopcnt=LOOPCNT
#line 2799
#pragma cdir shortloop
#line 2799
    for (i=0; i<ni; i++) {
#line 2799
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2799
     /* test for range errors (not always needed but do it anyway) */
#line 2799
      nrange += xp[i] < UCHAR_MIN || xp[i] > UCHAR_MAX;
#line 2799
    }
#line 2799
   /* update xpp and tp */
#line 2799
    if (realign) xp = (int *) *xpp;
#line 2799
    xp += ni;
#line 2799
    tp += ni;
#line 2799
    *xpp = (void*)xp;
#line 2799
  }
#line 2799
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2799

#line 2799
#else   /* not SX */
#line 2799
	const char *xp = (const char *) *xpp;
#line 2799
	int status = ENOERR;
#line 2799

#line 2799
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2799
	{
#line 2799
		const int lstatus = ncx_get_int_uchar(xp, tp);
#line 2799
		if(lstatus != ENOERR)
#line 2799
			status = lstatus;
#line 2799
	}
#line 2799

#line 2799
	*xpp = (const void *)xp;
#line 2799
	return status;
#line 2799
#  endif
#line 2799
}
#line 2799

int
#line 2800
ncx_getn_int_short(const void **xpp, size_t nelems, short *tp)
#line 2800
{
#line 2800
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2800

#line 2800
 /* basic algorithm is:
#line 2800
  *   - ensure sane alignment of input data
#line 2800
  *   - copy (conversion happens automatically) input data
#line 2800
  *     to output
#line 2800
  *   - update xpp to point at next unconverted input, and tp to point
#line 2800
  *     at next location for converted output
#line 2800
  */
#line 2800
  long i, j, ni;
#line 2800
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2800
  int *xp;
#line 2800
  int nrange = 0;         /* number of range errors */
#line 2800
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2800
  long cxp = (long) *((char**)xpp);
#line 2800

#line 2800
  realign = (cxp & 7) % SIZEOF_INT;
#line 2800
  /* sjl: manually stripmine so we can limit amount of
#line 2800
   * vector work space reserved to LOOPCNT elements. Also
#line 2800
   * makes vectorisation easy */
#line 2800
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2800
    ni=Min(nelems-j,LOOPCNT);
#line 2800
    if (realign) {
#line 2800
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2800
      xp = tmp;
#line 2800
    } else {
#line 2800
      xp = (int *) *xpp;
#line 2800
    }
#line 2800
   /* copy the next block */
#line 2800
#pragma cdir loopcnt=LOOPCNT
#line 2800
#pragma cdir shortloop
#line 2800
    for (i=0; i<ni; i++) {
#line 2800
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2800
     /* test for range errors (not always needed but do it anyway) */
#line 2800
      nrange += xp[i] < SHORT_MIN || xp[i] > SHORT_MAX;
#line 2800
    }
#line 2800
   /* update xpp and tp */
#line 2800
    if (realign) xp = (int *) *xpp;
#line 2800
    xp += ni;
#line 2800
    tp += ni;
#line 2800
    *xpp = (void*)xp;
#line 2800
  }
#line 2800
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2800

#line 2800
#else   /* not SX */
#line 2800
	const char *xp = (const char *) *xpp;
#line 2800
	int status = ENOERR;
#line 2800

#line 2800
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2800
	{
#line 2800
		const int lstatus = ncx_get_int_short(xp, tp);
#line 2800
		if(lstatus != ENOERR)
#line 2800
			status = lstatus;
#line 2800
	}
#line 2800

#line 2800
	*xpp = (const void *)xp;
#line 2800
	return status;
#line 2800
#  endif
#line 2800
}
#line 2800

#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(int));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
int
ncx_getn_int_uint(const void **xpp, size_t nelems, unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(int));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 2826
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
#line 2826
{
#line 2826
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2826

#line 2826
 /* basic algorithm is:
#line 2826
  *   - ensure sane alignment of input data
#line 2826
  *   - copy (conversion happens automatically) input data
#line 2826
  *     to output
#line 2826
  *   - update xpp to point at next unconverted input, and tp to point
#line 2826
  *     at next location for converted output
#line 2826
  */
#line 2826
  long i, j, ni;
#line 2826
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2826
  int *xp;
#line 2826
  int nrange = 0;         /* number of range errors */
#line 2826
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2826
  long cxp = (long) *((char**)xpp);
#line 2826

#line 2826
  realign = (cxp & 7) % SIZEOF_INT;
#line 2826
  /* sjl: manually stripmine so we can limit amount of
#line 2826
   * vector work space reserved to LOOPCNT elements. Also
#line 2826
   * makes vectorisation easy */
#line 2826
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2826
    ni=Min(nelems-j,LOOPCNT);
#line 2826
    if (realign) {
#line 2826
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2826
      xp = tmp;
#line 2826
    } else {
#line 2826
      xp = (int *) *xpp;
#line 2826
    }
#line 2826
   /* copy the next block */
#line 2826
#pragma cdir loopcnt=LOOPCNT
#line 2826
#pragma cdir shortloop
#line 2826
    for (i=0; i<ni; i++) {
#line 2826
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2826
     /* test for range errors (not always needed but do it anyway) */
#line 2826
      nrange += xp[i] < INT_MIN || xp[i] > INT_MAX;
#line 2826
    }
#line 2826
   /* update xpp and tp */
#line 2826
    if (realign) xp = (int *) *xpp;
#line 2826
    xp += ni;
#line 2826
    tp += ni;
#line 2826
    *xpp = (void*)xp;
#line 2826
  }
#line 2826
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2826

#line 2826
#else   /* not SX */
#line 2826
	const char *xp = (const char *) *xpp;
#line 2826
	int status = ENOERR;
#line 2826

#line 2826
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2826
	{
#line 2826
		const int lstatus = ncx_get_int_int(xp, tp);
#line 2826
		if(lstatus != ENOERR)
#line 2826
			status = lstatus;
#line 2826
	}
#line 2826

#line 2826
	*xpp = (const void *)xp;
#line 2826
	return status;
#line 2826
#  endif
#line 2826
}
#line 2826

int
#line 2827
ncx_getn_int_uint(const void **xpp, size_t nelems, uint *tp)
#line 2827
{
#line 2827
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2827

#line 2827
 /* basic algorithm is:
#line 2827
  *   - ensure sane alignment of input data
#line 2827
  *   - copy (conversion happens automatically) input data
#line 2827
  *     to output
#line 2827
  *   - update xpp to point at next unconverted input, and tp to point
#line 2827
  *     at next location for converted output
#line 2827
  */
#line 2827
  long i, j, ni;
#line 2827
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2827
  int *xp;
#line 2827
  int nrange = 0;         /* number of range errors */
#line 2827
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2827
  long cxp = (long) *((char**)xpp);
#line 2827

#line 2827
  realign = (cxp & 7) % SIZEOF_INT;
#line 2827
  /* sjl: manually stripmine so we can limit amount of
#line 2827
   * vector work space reserved to LOOPCNT elements. Also
#line 2827
   * makes vectorisation easy */
#line 2827
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2827
    ni=Min(nelems-j,LOOPCNT);
#line 2827
    if (realign) {
#line 2827
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2827
      xp = tmp;
#line 2827
    } else {
#line 2827
      xp = (int *) *xpp;
#line 2827
    }
#line 2827
   /* copy the next block */
#line 2827
#pragma cdir loopcnt=LOOPCNT
#line 2827
#pragma cdir shortloop
#line 2827
    for (i=0; i<ni; i++) {
#line 2827
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2827
     /* test for range errors (not always needed but do it anyway) */
#line 2827
      nrange += xp[i] < UINT_MIN || xp[i] > UINT_MAX;
#line 2827
    }
#line 2827
   /* update xpp and tp */
#line 2827
    if (realign) xp = (int *) *xpp;
#line 2827
    xp += ni;
#line 2827
    tp += ni;
#line 2827
    *xpp = (void*)xp;
#line 2827
  }
#line 2827
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2827

#line 2827
#else   /* not SX */
#line 2827
	const char *xp = (const char *) *xpp;
#line 2827
	int status = ENOERR;
#line 2827

#line 2827
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2827
	{
#line 2827
		const int lstatus = ncx_get_int_uint(xp, tp);
#line 2827
		if(lstatus != ENOERR)
#line 2827
			status = lstatus;
#line 2827
	}
#line 2827

#line 2827
	*xpp = (const void *)xp;
#line 2827
	return status;
#line 2827
#  endif
#line 2827
}
#line 2827

#endif

int
#line 2830
ncx_getn_int_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2830
{
#line 2830
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2830

#line 2830
 /* basic algorithm is:
#line 2830
  *   - ensure sane alignment of input data
#line 2830
  *   - copy (conversion happens automatically) input data
#line 2830
  *     to output
#line 2830
  *   - update xpp to point at next unconverted input, and tp to point
#line 2830
  *     at next location for converted output
#line 2830
  */
#line 2830
  long i, j, ni;
#line 2830
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2830
  int *xp;
#line 2830
  int nrange = 0;         /* number of range errors */
#line 2830
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2830
  long cxp = (long) *((char**)xpp);
#line 2830

#line 2830
  realign = (cxp & 7) % SIZEOF_INT;
#line 2830
  /* sjl: manually stripmine so we can limit amount of
#line 2830
   * vector work space reserved to LOOPCNT elements. Also
#line 2830
   * makes vectorisation easy */
#line 2830
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2830
    ni=Min(nelems-j,LOOPCNT);
#line 2830
    if (realign) {
#line 2830
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2830
      xp = tmp;
#line 2830
    } else {
#line 2830
      xp = (int *) *xpp;
#line 2830
    }
#line 2830
   /* copy the next block */
#line 2830
#pragma cdir loopcnt=LOOPCNT
#line 2830
#pragma cdir shortloop
#line 2830
    for (i=0; i<ni; i++) {
#line 2830
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2830
     /* test for range errors (not always needed but do it anyway) */
#line 2830
      nrange += xp[i] < LONGLONG_MIN || xp[i] > LONGLONG_MAX;
#line 2830
    }
#line 2830
   /* update xpp and tp */
#line 2830
    if (realign) xp = (int *) *xpp;
#line 2830
    xp += ni;
#line 2830
    tp += ni;
#line 2830
    *xpp = (void*)xp;
#line 2830
  }
#line 2830
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2830

#line 2830
#else   /* not SX */
#line 2830
	const char *xp = (const char *) *xpp;
#line 2830
	int status = ENOERR;
#line 2830

#line 2830
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2830
	{
#line 2830
		const int lstatus = ncx_get_int_longlong(xp, tp);
#line 2830
		if(lstatus != ENOERR)
#line 2830
			status = lstatus;
#line 2830
	}
#line 2830

#line 2830
	*xpp = (const void *)xp;
#line 2830
	return status;
#line 2830
#  endif
#line 2830
}
#line 2830

int
#line 2831
ncx_getn_int_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2831
{
#line 2831
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2831

#line 2831
 /* basic algorithm is:
#line 2831
  *   - ensure sane alignment of input data
#line 2831
  *   - copy (conversion happens automatically) input data
#line 2831
  *     to output
#line 2831
  *   - update xpp to point at next unconverted input, and tp to point
#line 2831
  *     at next location for converted output
#line 2831
  */
#line 2831
  long i, j, ni;
#line 2831
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2831
  int *xp;
#line 2831
  int nrange = 0;         /* number of range errors */
#line 2831
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2831
  long cxp = (long) *((char**)xpp);
#line 2831

#line 2831
  realign = (cxp & 7) % SIZEOF_INT;
#line 2831
  /* sjl: manually stripmine so we can limit amount of
#line 2831
   * vector work space reserved to LOOPCNT elements. Also
#line 2831
   * makes vectorisation easy */
#line 2831
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2831
    ni=Min(nelems-j,LOOPCNT);
#line 2831
    if (realign) {
#line 2831
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2831
      xp = tmp;
#line 2831
    } else {
#line 2831
      xp = (int *) *xpp;
#line 2831
    }
#line 2831
   /* copy the next block */
#line 2831
#pragma cdir loopcnt=LOOPCNT
#line 2831
#pragma cdir shortloop
#line 2831
    for (i=0; i<ni; i++) {
#line 2831
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2831
     /* test for range errors (not always needed but do it anyway) */
#line 2831
      nrange += xp[i] < ULONGLONG_MIN || xp[i] > ULONGLONG_MAX;
#line 2831
    }
#line 2831
   /* update xpp and tp */
#line 2831
    if (realign) xp = (int *) *xpp;
#line 2831
    xp += ni;
#line 2831
    tp += ni;
#line 2831
    *xpp = (void*)xp;
#line 2831
  }
#line 2831
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2831

#line 2831
#else   /* not SX */
#line 2831
	const char *xp = (const char *) *xpp;
#line 2831
	int status = ENOERR;
#line 2831

#line 2831
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2831
	{
#line 2831
		const int lstatus = ncx_get_int_ulonglong(xp, tp);
#line 2831
		if(lstatus != ENOERR)
#line 2831
			status = lstatus;
#line 2831
	}
#line 2831

#line 2831
	*xpp = (const void *)xp;
#line 2831
	return status;
#line 2831
#  endif
#line 2831
}
#line 2831


int
#line 2833
ncx_getn_int_float(const void **xpp, size_t nelems, float *tp)
#line 2833
{
#line 2833
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2833

#line 2833
 /* basic algorithm is:
#line 2833
  *   - ensure sane alignment of input data
#line 2833
  *   - copy (conversion happens automatically) input data
#line 2833
  *     to output
#line 2833
  *   - update xpp to point at next unconverted input, and tp to point
#line 2833
  *     at next location for converted output
#line 2833
  */
#line 2833
  long i, j, ni;
#line 2833
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2833
  int *xp;
#line 2833
  int nrange = 0;         /* number of range errors */
#line 2833
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2833
  long cxp = (long) *((char**)xpp);
#line 2833

#line 2833
  realign = (cxp & 7) % SIZEOF_INT;
#line 2833
  /* sjl: manually stripmine so we can limit amount of
#line 2833
   * vector work space reserved to LOOPCNT elements. Also
#line 2833
   * makes vectorisation easy */
#line 2833
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2833
    ni=Min(nelems-j,LOOPCNT);
#line 2833
    if (realign) {
#line 2833
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2833
      xp = tmp;
#line 2833
    } else {
#line 2833
      xp = (int *) *xpp;
#line 2833
    }
#line 2833
   /* copy the next block */
#line 2833
#pragma cdir loopcnt=LOOPCNT
#line 2833
#pragma cdir shortloop
#line 2833
    for (i=0; i<ni; i++) {
#line 2833
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2833
     /* test for range errors (not always needed but do it anyway) */
#line 2833
      nrange += xp[i] < FLOAT_MIN || xp[i] > FLOAT_MAX;
#line 2833
    }
#line 2833
   /* update xpp and tp */
#line 2833
    if (realign) xp = (int *) *xpp;
#line 2833
    xp += ni;
#line 2833
    tp += ni;
#line 2833
    *xpp = (void*)xp;
#line 2833
  }
#line 2833
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2833

#line 2833
#else   /* not SX */
#line 2833
	const char *xp = (const char *) *xpp;
#line 2833
	int status = ENOERR;
#line 2833

#line 2833
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2833
	{
#line 2833
		const int lstatus = ncx_get_int_float(xp, tp);
#line 2833
		if(lstatus != ENOERR)
#line 2833
			status = lstatus;
#line 2833
	}
#line 2833

#line 2833
	*xpp = (const void *)xp;
#line 2833
	return status;
#line 2833
#  endif
#line 2833
}
#line 2833

int
#line 2834
ncx_getn_int_double(const void **xpp, size_t nelems, double *tp)
#line 2834
{
#line 2834
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2834

#line 2834
 /* basic algorithm is:
#line 2834
  *   - ensure sane alignment of input data
#line 2834
  *   - copy (conversion happens automatically) input data
#line 2834
  *     to output
#line 2834
  *   - update xpp to point at next unconverted input, and tp to point
#line 2834
  *     at next location for converted output
#line 2834
  */
#line 2834
  long i, j, ni;
#line 2834
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2834
  int *xp;
#line 2834
  int nrange = 0;         /* number of range errors */
#line 2834
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2834
  long cxp = (long) *((char**)xpp);
#line 2834

#line 2834
  realign = (cxp & 7) % SIZEOF_INT;
#line 2834
  /* sjl: manually stripmine so we can limit amount of
#line 2834
   * vector work space reserved to LOOPCNT elements. Also
#line 2834
   * makes vectorisation easy */
#line 2834
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2834
    ni=Min(nelems-j,LOOPCNT);
#line 2834
    if (realign) {
#line 2834
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2834
      xp = tmp;
#line 2834
    } else {
#line 2834
      xp = (int *) *xpp;
#line 2834
    }
#line 2834
   /* copy the next block */
#line 2834
#pragma cdir loopcnt=LOOPCNT
#line 2834
#pragma cdir shortloop
#line 2834
    for (i=0; i<ni; i++) {
#line 2834
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2834
     /* test for range errors (not always needed but do it anyway) */
#line 2834
      nrange += xp[i] < DOUBLE_MIN || xp[i] > DOUBLE_MAX;
#line 2834
    }
#line 2834
   /* update xpp and tp */
#line 2834
    if (realign) xp = (int *) *xpp;
#line 2834
    xp += ni;
#line 2834
    tp += ni;
#line 2834
    *xpp = (void*)xp;
#line 2834
  }
#line 2834
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2834

#line 2834
#else   /* not SX */
#line 2834
	const char *xp = (const char *) *xpp;
#line 2834
	int status = ENOERR;
#line 2834

#line 2834
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2834
	{
#line 2834
		const int lstatus = ncx_get_int_double(xp, tp);
#line 2834
		if(lstatus != ENOERR)
#line 2834
			status = lstatus;
#line 2834
	}
#line 2834

#line 2834
	*xpp = (const void *)xp;
#line 2834
	return status;
#line 2834
#  endif
#line 2834
}
#line 2834


int
#line 2836
ncx_putn_int_schar(void **xpp, size_t nelems, const schar *tp)
#line 2836
{
#line 2836
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2836

#line 2836
 /* basic algorithm is:
#line 2836
  *   - ensure sane alignment of output data
#line 2836
  *   - copy (conversion happens automatically) input data
#line 2836
  *     to output
#line 2836
  *   - update tp to point at next unconverted input, and xpp to point
#line 2836
  *     at next location for converted output
#line 2836
  */
#line 2836
  long i, j, ni;
#line 2836
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2836
  int *xp;
#line 2836
  int nrange = 0;         /* number of range errors */
#line 2836
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2836
  long cxp = (long) *((char**)xpp);
#line 2836

#line 2836
  realign = (cxp & 7) % SIZEOF_INT;
#line 2836
  /* sjl: manually stripmine so we can limit amount of
#line 2836
   * vector work space reserved to LOOPCNT elements. Also
#line 2836
   * makes vectorisation easy */
#line 2836
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2836
    ni=Min(nelems-j,LOOPCNT);
#line 2836
    if (realign) {
#line 2836
      xp = tmp;
#line 2836
    } else {
#line 2836
      xp = (int *) *xpp;
#line 2836
    }
#line 2836
   /* copy the next block */
#line 2836
#pragma cdir loopcnt=LOOPCNT
#line 2836
#pragma cdir shortloop
#line 2836
    for (i=0; i<ni; i++) {
#line 2836
      /* the normal case: */
#line 2836
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2836
     /* test for range errors (not always needed but do it anyway) */
#line 2836
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2836
    }
#line 2836
   /* copy workspace back if necessary */
#line 2836
    if (realign) {
#line 2836
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2836
      xp = (int *) *xpp;
#line 2836
    }
#line 2836
   /* update xpp and tp */
#line 2836
    xp += ni;
#line 2836
    tp += ni;
#line 2836
    *xpp = (void*)xp;
#line 2836
  }
#line 2836
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2836

#line 2836
#else   /* not SX */
#line 2836

#line 2836
	char *xp = (char *) *xpp;
#line 2836
	int status = ENOERR;
#line 2836

#line 2836
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2836
	{
#line 2836
		int lstatus = ncx_put_int_schar(xp, tp);
#line 2836
		if(lstatus != ENOERR)
#line 2836
			status = lstatus;
#line 2836
	}
#line 2836

#line 2836
	*xpp = (void *)xp;
#line 2836
	return status;
#line 2836
#endif
#line 2836
}
#line 2836

int
#line 2837
ncx_putn_int_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2837
{
#line 2837
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2837

#line 2837
 /* basic algorithm is:
#line 2837
  *   - ensure sane alignment of output data
#line 2837
  *   - copy (conversion happens automatically) input data
#line 2837
  *     to output
#line 2837
  *   - update tp to point at next unconverted input, and xpp to point
#line 2837
  *     at next location for converted output
#line 2837
  */
#line 2837
  long i, j, ni;
#line 2837
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2837
  int *xp;
#line 2837
  int nrange = 0;         /* number of range errors */
#line 2837
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2837
  long cxp = (long) *((char**)xpp);
#line 2837

#line 2837
  realign = (cxp & 7) % SIZEOF_INT;
#line 2837
  /* sjl: manually stripmine so we can limit amount of
#line 2837
   * vector work space reserved to LOOPCNT elements. Also
#line 2837
   * makes vectorisation easy */
#line 2837
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2837
    ni=Min(nelems-j,LOOPCNT);
#line 2837
    if (realign) {
#line 2837
      xp = tmp;
#line 2837
    } else {
#line 2837
      xp = (int *) *xpp;
#line 2837
    }
#line 2837
   /* copy the next block */
#line 2837
#pragma cdir loopcnt=LOOPCNT
#line 2837
#pragma cdir shortloop
#line 2837
    for (i=0; i<ni; i++) {
#line 2837
      /* the normal case: */
#line 2837
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2837
     /* test for range errors (not always needed but do it anyway) */
#line 2837
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2837
    }
#line 2837
   /* copy workspace back if necessary */
#line 2837
    if (realign) {
#line 2837
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2837
      xp = (int *) *xpp;
#line 2837
    }
#line 2837
   /* update xpp and tp */
#line 2837
    xp += ni;
#line 2837
    tp += ni;
#line 2837
    *xpp = (void*)xp;
#line 2837
  }
#line 2837
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2837

#line 2837
#else   /* not SX */
#line 2837

#line 2837
	char *xp = (char *) *xpp;
#line 2837
	int status = ENOERR;
#line 2837

#line 2837
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2837
	{
#line 2837
		int lstatus = ncx_put_int_uchar(xp, tp);
#line 2837
		if(lstatus != ENOERR)
#line 2837
			status = lstatus;
#line 2837
	}
#line 2837

#line 2837
	*xpp = (void *)xp;
#line 2837
	return status;
#line 2837
#endif
#line 2837
}
#line 2837

int
#line 2838
ncx_putn_int_short(void **xpp, size_t nelems, const short *tp)
#line 2838
{
#line 2838
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2838

#line 2838
 /* basic algorithm is:
#line 2838
  *   - ensure sane alignment of output data
#line 2838
  *   - copy (conversion happens automatically) input data
#line 2838
  *     to output
#line 2838
  *   - update tp to point at next unconverted input, and xpp to point
#line 2838
  *     at next location for converted output
#line 2838
  */
#line 2838
  long i, j, ni;
#line 2838
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2838
  int *xp;
#line 2838
  int nrange = 0;         /* number of range errors */
#line 2838
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2838
  long cxp = (long) *((char**)xpp);
#line 2838

#line 2838
  realign = (cxp & 7) % SIZEOF_INT;
#line 2838
  /* sjl: manually stripmine so we can limit amount of
#line 2838
   * vector work space reserved to LOOPCNT elements. Also
#line 2838
   * makes vectorisation easy */
#line 2838
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2838
    ni=Min(nelems-j,LOOPCNT);
#line 2838
    if (realign) {
#line 2838
      xp = tmp;
#line 2838
    } else {
#line 2838
      xp = (int *) *xpp;
#line 2838
    }
#line 2838
   /* copy the next block */
#line 2838
#pragma cdir loopcnt=LOOPCNT
#line 2838
#pragma cdir shortloop
#line 2838
    for (i=0; i<ni; i++) {
#line 2838
      /* the normal case: */
#line 2838
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2838
     /* test for range errors (not always needed but do it anyway) */
#line 2838
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2838
    }
#line 2838
   /* copy workspace back if necessary */
#line 2838
    if (realign) {
#line 2838
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2838
      xp = (int *) *xpp;
#line 2838
    }
#line 2838
   /* update xpp and tp */
#line 2838
    xp += ni;
#line 2838
    tp += ni;
#line 2838
    *xpp = (void*)xp;
#line 2838
  }
#line 2838
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2838

#line 2838
#else   /* not SX */
#line 2838

#line 2838
	char *xp = (char *) *xpp;
#line 2838
	int status = ENOERR;
#line 2838

#line 2838
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2838
	{
#line 2838
		int lstatus = ncx_put_int_short(xp, tp);
#line 2838
		if(lstatus != ENOERR)
#line 2838
			status = lstatus;
#line 2838
	}
#line 2838

#line 2838
	*xpp = (void *)xp;
#line 2838
	return status;
#line 2838
#endif
#line 2838
}
#line 2838

#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_INT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
int
ncx_putn_int_uint(void **xpp, size_t nelems, const unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_INT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 2864
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
#line 2864
{
#line 2864
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2864

#line 2864
 /* basic algorithm is:
#line 2864
  *   - ensure sane alignment of output data
#line 2864
  *   - copy (conversion happens automatically) input data
#line 2864
  *     to output
#line 2864
  *   - update tp to point at next unconverted input, and xpp to point
#line 2864
  *     at next location for converted output
#line 2864
  */
#line 2864
  long i, j, ni;
#line 2864
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2864
  int *xp;
#line 2864
  int nrange = 0;         /* number of range errors */
#line 2864
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2864
  long cxp = (long) *((char**)xpp);
#line 2864

#line 2864
  realign = (cxp & 7) % SIZEOF_INT;
#line 2864
  /* sjl: manually stripmine so we can limit amount of
#line 2864
   * vector work space reserved to LOOPCNT elements. Also
#line 2864
   * makes vectorisation easy */
#line 2864
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2864
    ni=Min(nelems-j,LOOPCNT);
#line 2864
    if (realign) {
#line 2864
      xp = tmp;
#line 2864
    } else {
#line 2864
      xp = (int *) *xpp;
#line 2864
    }
#line 2864
   /* copy the next block */
#line 2864
#pragma cdir loopcnt=LOOPCNT
#line 2864
#pragma cdir shortloop
#line 2864
    for (i=0; i<ni; i++) {
#line 2864
      /* the normal case: */
#line 2864
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2864
     /* test for range errors (not always needed but do it anyway) */
#line 2864
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2864
    }
#line 2864
   /* copy workspace back if necessary */
#line 2864
    if (realign) {
#line 2864
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2864
      xp = (int *) *xpp;
#line 2864
    }
#line 2864
   /* update xpp and tp */
#line 2864
    xp += ni;
#line 2864
    tp += ni;
#line 2864
    *xpp = (void*)xp;
#line 2864
  }
#line 2864
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2864

#line 2864
#else   /* not SX */
#line 2864

#line 2864
	char *xp = (char *) *xpp;
#line 2864
	int status = ENOERR;
#line 2864

#line 2864
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2864
	{
#line 2864
		int lstatus = ncx_put_int_int(xp, tp);
#line 2864
		if(lstatus != ENOERR)
#line 2864
			status = lstatus;
#line 2864
	}
#line 2864

#line 2864
	*xpp = (void *)xp;
#line 2864
	return status;
#line 2864
#endif
#line 2864
}
#line 2864

int
#line 2865
ncx_putn_int_uint(void **xpp, size_t nelems, const uint *tp)
#line 2865
{
#line 2865
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2865

#line 2865
 /* basic algorithm is:
#line 2865
  *   - ensure sane alignment of output data
#line 2865
  *   - copy (conversion happens automatically) input data
#line 2865
  *     to output
#line 2865
  *   - update tp to point at next unconverted input, and xpp to point
#line 2865
  *     at next location for converted output
#line 2865
  */
#line 2865
  long i, j, ni;
#line 2865
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2865
  int *xp;
#line 2865
  int nrange = 0;         /* number of range errors */
#line 2865
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2865
  long cxp = (long) *((char**)xpp);
#line 2865

#line 2865
  realign = (cxp & 7) % SIZEOF_INT;
#line 2865
  /* sjl: manually stripmine so we can limit amount of
#line 2865
   * vector work space reserved to LOOPCNT elements. Also
#line 2865
   * makes vectorisation easy */
#line 2865
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2865
    ni=Min(nelems-j,LOOPCNT);
#line 2865
    if (realign) {
#line 2865
      xp = tmp;
#line 2865
    } else {
#line 2865
      xp = (int *) *xpp;
#line 2865
    }
#line 2865
   /* copy the next block */
#line 2865
#pragma cdir loopcnt=LOOPCNT
#line 2865
#pragma cdir shortloop
#line 2865
    for (i=0; i<ni; i++) {
#line 2865
      /* the normal case: */
#line 2865
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2865
     /* test for range errors (not always needed but do it anyway) */
#line 2865
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2865
    }
#line 2865
   /* copy workspace back if necessary */
#line 2865
    if (realign) {
#line 2865
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2865
      xp = (int *) *xpp;
#line 2865
    }
#line 2865
   /* update xpp and tp */
#line 2865
    xp += ni;
#line 2865
    tp += ni;
#line 2865
    *xpp = (void*)xp;
#line 2865
  }
#line 2865
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2865

#line 2865
#else   /* not SX */
#line 2865

#line 2865
	char *xp = (char *) *xpp;
#line 2865
	int status = ENOERR;
#line 2865

#line 2865
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2865
	{
#line 2865
		int lstatus = ncx_put_int_uint(xp, tp);
#line 2865
		if(lstatus != ENOERR)
#line 2865
			status = lstatus;
#line 2865
	}
#line 2865

#line 2865
	*xpp = (void *)xp;
#line 2865
	return status;
#line 2865
#endif
#line 2865
}
#line 2865

#endif

int
#line 2868
ncx_putn_int_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2868
{
#line 2868
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2868

#line 2868
 /* basic algorithm is:
#line 2868
  *   - ensure sane alignment of output data
#line 2868
  *   - copy (conversion happens automatically) input data
#line 2868
  *     to output
#line 2868
  *   - update tp to point at next unconverted input, and xpp to point
#line 2868
  *     at next location for converted output
#line 2868
  */
#line 2868
  long i, j, ni;
#line 2868
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2868
  int *xp;
#line 2868
  int nrange = 0;         /* number of range errors */
#line 2868
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2868
  long cxp = (long) *((char**)xpp);
#line 2868

#line 2868
  realign = (cxp & 7) % SIZEOF_INT;
#line 2868
  /* sjl: manually stripmine so we can limit amount of
#line 2868
   * vector work space reserved to LOOPCNT elements. Also
#line 2868
   * makes vectorisation easy */
#line 2868
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2868
    ni=Min(nelems-j,LOOPCNT);
#line 2868
    if (realign) {
#line 2868
      xp = tmp;
#line 2868
    } else {
#line 2868
      xp = (int *) *xpp;
#line 2868
    }
#line 2868
   /* copy the next block */
#line 2868
#pragma cdir loopcnt=LOOPCNT
#line 2868
#pragma cdir shortloop
#line 2868
    for (i=0; i<ni; i++) {
#line 2868
      /* the normal case: */
#line 2868
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2868
     /* test for range errors (not always needed but do it anyway) */
#line 2868
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2868
    }
#line 2868
   /* copy workspace back if necessary */
#line 2868
    if (realign) {
#line 2868
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2868
      xp = (int *) *xpp;
#line 2868
    }
#line 2868
   /* update xpp and tp */
#line 2868
    xp += ni;
#line 2868
    tp += ni;
#line 2868
    *xpp = (void*)xp;
#line 2868
  }
#line 2868
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2868

#line 2868
#else   /* not SX */
#line 2868

#line 2868
	char *xp = (char *) *xpp;
#line 2868
	int status = ENOERR;
#line 2868

#line 2868
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2868
	{
#line 2868
		int lstatus = ncx_put_int_longlong(xp, tp);
#line 2868
		if(lstatus != ENOERR)
#line 2868
			status = lstatus;
#line 2868
	}
#line 2868

#line 2868
	*xpp = (void *)xp;
#line 2868
	return status;
#line 2868
#endif
#line 2868
}
#line 2868

int
#line 2869
ncx_putn_int_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2869
{
#line 2869
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2869

#line 2869
 /* basic algorithm is:
#line 2869
  *   - ensure sane alignment of output data
#line 2869
  *   - copy (conversion happens automatically) input data
#line 2869
  *     to output
#line 2869
  *   - update tp to point at next unconverted input, and xpp to point
#line 2869
  *     at next location for converted output
#line 2869
  */
#line 2869
  long i, j, ni;
#line 2869
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2869
  int *xp;
#line 2869
  int nrange = 0;         /* number of range errors */
#line 2869
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2869
  long cxp = (long) *((char**)xpp);
#line 2869

#line 2869
  realign = (cxp & 7) % SIZEOF_INT;
#line 2869
  /* sjl: manually stripmine so we can limit amount of
#line 2869
   * vector work space reserved to LOOPCNT elements. Also
#line 2869
   * makes vectorisation easy */
#line 2869
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2869
    ni=Min(nelems-j,LOOPCNT);
#line 2869
    if (realign) {
#line 2869
      xp = tmp;
#line 2869
    } else {
#line 2869
      xp = (int *) *xpp;
#line 2869
    }
#line 2869
   /* copy the next block */
#line 2869
#pragma cdir loopcnt=LOOPCNT
#line 2869
#pragma cdir shortloop
#line 2869
    for (i=0; i<ni; i++) {
#line 2869
      /* the normal case: */
#line 2869
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2869
     /* test for range errors (not always needed but do it anyway) */
#line 2869
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2869
    }
#line 2869
   /* copy workspace back if necessary */
#line 2869
    if (realign) {
#line 2869
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2869
      xp = (int *) *xpp;
#line 2869
    }
#line 2869
   /* update xpp and tp */
#line 2869
    xp += ni;
#line 2869
    tp += ni;
#line 2869
    *xpp = (void*)xp;
#line 2869
  }
#line 2869
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2869

#line 2869
#else   /* not SX */
#line 2869

#line 2869
	char *xp = (char *) *xpp;
#line 2869
	int status = ENOERR;
#line 2869

#line 2869
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2869
	{
#line 2869
		int lstatus = ncx_put_int_ulonglong(xp, tp);
#line 2869
		if(lstatus != ENOERR)
#line 2869
			status = lstatus;
#line 2869
	}
#line 2869

#line 2869
	*xpp = (void *)xp;
#line 2869
	return status;
#line 2869
#endif
#line 2869
}
#line 2869

int
#line 2870
ncx_putn_int_float(void **xpp, size_t nelems, const float *tp)
#line 2870
{
#line 2870
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2870

#line 2870
 /* basic algorithm is:
#line 2870
  *   - ensure sane alignment of output data
#line 2870
  *   - copy (conversion happens automatically) input data
#line 2870
  *     to output
#line 2870
  *   - update tp to point at next unconverted input, and xpp to point
#line 2870
  *     at next location for converted output
#line 2870
  */
#line 2870
  long i, j, ni;
#line 2870
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2870
  int *xp;
#line 2870
  double d;               /* special case for ncx_putn_int_float */
#line 2870
  int nrange = 0;         /* number of range errors */
#line 2870
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2870
  long cxp = (long) *((char**)xpp);
#line 2870

#line 2870
  realign = (cxp & 7) % SIZEOF_INT;
#line 2870
  /* sjl: manually stripmine so we can limit amount of
#line 2870
   * vector work space reserved to LOOPCNT elements. Also
#line 2870
   * makes vectorisation easy */
#line 2870
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2870
    ni=Min(nelems-j,LOOPCNT);
#line 2870
    if (realign) {
#line 2870
      xp = tmp;
#line 2870
    } else {
#line 2870
      xp = (int *) *xpp;
#line 2870
    }
#line 2870
   /* copy the next block */
#line 2870
#pragma cdir loopcnt=LOOPCNT
#line 2870
#pragma cdir shortloop
#line 2870
    for (i=0; i<ni; i++) {
#line 2870
      /* for some reason int to float, for putn, requires a special case */
#line 2870
      d = tp[i];
#line 2870
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) d));
#line 2870
      nrange += d < X_INT_MIN || d > X_INT_MAX;
#line 2870
    }
#line 2870
   /* copy workspace back if necessary */
#line 2870
    if (realign) {
#line 2870
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2870
      xp = (int *) *xpp;
#line 2870
    }
#line 2870
   /* update xpp and tp */
#line 2870
    xp += ni;
#line 2870
    tp += ni;
#line 2870
    *xpp = (void*)xp;
#line 2870
  }
#line 2870
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2870

#line 2870
#else   /* not SX */
#line 2870

#line 2870
	char *xp = (char *) *xpp;
#line 2870
	int status = ENOERR;
#line 2870

#line 2870
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2870
	{
#line 2870
		int lstatus = ncx_put_int_float(xp, tp);
#line 2870
		if(lstatus != ENOERR)
#line 2870
			status = lstatus;
#line 2870
	}
#line 2870

#line 2870
	*xpp = (void *)xp;
#line 2870
	return status;
#line 2870
#endif
#line 2870
}
#line 2870

int
#line 2871
ncx_putn_int_double(void **xpp, size_t nelems, const double *tp)
#line 2871
{
#line 2871
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2871

#line 2871
 /* basic algorithm is:
#line 2871
  *   - ensure sane alignment of output data
#line 2871
  *   - copy (conversion happens automatically) input data
#line 2871
  *     to output
#line 2871
  *   - update tp to point at next unconverted input, and xpp to point
#line 2871
  *     at next location for converted output
#line 2871
  */
#line 2871
  long i, j, ni;
#line 2871
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2871
  int *xp;
#line 2871
  int nrange = 0;         /* number of range errors */
#line 2871
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2871
  long cxp = (long) *((char**)xpp);
#line 2871

#line 2871
  realign = (cxp & 7) % SIZEOF_INT;
#line 2871
  /* sjl: manually stripmine so we can limit amount of
#line 2871
   * vector work space reserved to LOOPCNT elements. Also
#line 2871
   * makes vectorisation easy */
#line 2871
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2871
    ni=Min(nelems-j,LOOPCNT);
#line 2871
    if (realign) {
#line 2871
      xp = tmp;
#line 2871
    } else {
#line 2871
      xp = (int *) *xpp;
#line 2871
    }
#line 2871
   /* copy the next block */
#line 2871
#pragma cdir loopcnt=LOOPCNT
#line 2871
#pragma cdir shortloop
#line 2871
    for (i=0; i<ni; i++) {
#line 2871
      /* the normal case: */
#line 2871
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2871
     /* test for range errors (not always needed but do it anyway) */
#line 2871
      nrange += tp[i] < X_INT_MIN || tp[i] > X_INT_MAX;
#line 2871
    }
#line 2871
   /* copy workspace back if necessary */
#line 2871
    if (realign) {
#line 2871
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2871
      xp = (int *) *xpp;
#line 2871
    }
#line 2871
   /* update xpp and tp */
#line 2871
    xp += ni;
#line 2871
    tp += ni;
#line 2871
    *xpp = (void*)xp;
#line 2871
  }
#line 2871
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2871

#line 2871
#else   /* not SX */
#line 2871

#line 2871
	char *xp = (char *) *xpp;
#line 2871
	int status = ENOERR;
#line 2871

#line 2871
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2871
	{
#line 2871
		int lstatus = ncx_put_int_double(xp, tp);
#line 2871
		if(lstatus != ENOERR)
#line 2871
			status = lstatus;
#line 2871
	}
#line 2871

#line 2871
	*xpp = (void *)xp;
#line 2871
	return status;
#line 2871
#endif
#line 2871
}
#line 2871



/* float */

int
#line 2876
ncx_getn_float_schar(const void **xpp, size_t nelems, schar *tp)
#line 2876
{
#line 2876
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2876

#line 2876
 /* basic algorithm is:
#line 2876
  *   - ensure sane alignment of input data
#line 2876
  *   - copy (conversion happens automatically) input data
#line 2876
  *     to output
#line 2876
  *   - update xpp to point at next unconverted input, and tp to point
#line 2876
  *     at next location for converted output
#line 2876
  */
#line 2876
  long i, j, ni;
#line 2876
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2876
  float *xp;
#line 2876
  int nrange = 0;         /* number of range errors */
#line 2876
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2876
  long cxp = (long) *((char**)xpp);
#line 2876

#line 2876
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2876
  /* sjl: manually stripmine so we can limit amount of
#line 2876
   * vector work space reserved to LOOPCNT elements. Also
#line 2876
   * makes vectorisation easy */
#line 2876
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2876
    ni=Min(nelems-j,LOOPCNT);
#line 2876
    if (realign) {
#line 2876
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2876
      xp = tmp;
#line 2876
    } else {
#line 2876
      xp = (float *) *xpp;
#line 2876
    }
#line 2876
   /* copy the next block */
#line 2876
#pragma cdir loopcnt=LOOPCNT
#line 2876
#pragma cdir shortloop
#line 2876
    for (i=0; i<ni; i++) {
#line 2876
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2876
     /* test for range errors (not always needed but do it anyway) */
#line 2876
      nrange += xp[i] < SCHAR_MIN || xp[i] > SCHAR_MAX;
#line 2876
    }
#line 2876
   /* update xpp and tp */
#line 2876
    if (realign) xp = (float *) *xpp;
#line 2876
    xp += ni;
#line 2876
    tp += ni;
#line 2876
    *xpp = (void*)xp;
#line 2876
  }
#line 2876
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2876

#line 2876
#else   /* not SX */
#line 2876
	const char *xp = (const char *) *xpp;
#line 2876
	int status = ENOERR;
#line 2876

#line 2876
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2876
	{
#line 2876
		const int lstatus = ncx_get_float_schar(xp, tp);
#line 2876
		if(lstatus != ENOERR)
#line 2876
			status = lstatus;
#line 2876
	}
#line 2876

#line 2876
	*xpp = (const void *)xp;
#line 2876
	return status;
#line 2876
#  endif
#line 2876
}
#line 2876

int
#line 2877
ncx_getn_float_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2877
{
#line 2877
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2877

#line 2877
 /* basic algorithm is:
#line 2877
  *   - ensure sane alignment of input data
#line 2877
  *   - copy (conversion happens automatically) input data
#line 2877
  *     to output
#line 2877
  *   - update xpp to point at next unconverted input, and tp to point
#line 2877
  *     at next location for converted output
#line 2877
  */
#line 2877
  long i, j, ni;
#line 2877
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2877
  float *xp;
#line 2877
  int nrange = 0;         /* number of range errors */
#line 2877
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2877
  long cxp = (long) *((char**)xpp);
#line 2877

#line 2877
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2877
  /* sjl: manually stripmine so we can limit amount of
#line 2877
   * vector work space reserved to LOOPCNT elements. Also
#line 2877
   * makes vectorisation easy */
#line 2877
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2877
    ni=Min(nelems-j,LOOPCNT);
#line 2877
    if (realign) {
#line 2877
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2877
      xp = tmp;
#line 2877
    } else {
#line 2877
      xp = (float *) *xpp;
#line 2877
    }
#line 2877
   /* copy the next block */
#line 2877
#pragma cdir loopcnt=LOOPCNT
#line 2877
#pragma cdir shortloop
#line 2877
    for (i=0; i<ni; i++) {
#line 2877
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2877
     /* test for range errors (not always needed but do it anyway) */
#line 2877
      nrange += xp[i] < UCHAR_MIN || xp[i] > UCHAR_MAX;
#line 2877
    }
#line 2877
   /* update xpp and tp */
#line 2877
    if (realign) xp = (float *) *xpp;
#line 2877
    xp += ni;
#line 2877
    tp += ni;
#line 2877
    *xpp = (void*)xp;
#line 2877
  }
#line 2877
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2877

#line 2877
#else   /* not SX */
#line 2877
	const char *xp = (const char *) *xpp;
#line 2877
	int status = ENOERR;
#line 2877

#line 2877
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2877
	{
#line 2877
		const int lstatus = ncx_get_float_uchar(xp, tp);
#line 2877
		if(lstatus != ENOERR)
#line 2877
			status = lstatus;
#line 2877
	}
#line 2877

#line 2877
	*xpp = (const void *)xp;
#line 2877
	return status;
#line 2877
#  endif
#line 2877
}
#line 2877

int
#line 2878
ncx_getn_float_short(const void **xpp, size_t nelems, short *tp)
#line 2878
{
#line 2878
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2878

#line 2878
 /* basic algorithm is:
#line 2878
  *   - ensure sane alignment of input data
#line 2878
  *   - copy (conversion happens automatically) input data
#line 2878
  *     to output
#line 2878
  *   - update xpp to point at next unconverted input, and tp to point
#line 2878
  *     at next location for converted output
#line 2878
  */
#line 2878
  long i, j, ni;
#line 2878
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2878
  float *xp;
#line 2878
  int nrange = 0;         /* number of range errors */
#line 2878
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2878
  long cxp = (long) *((char**)xpp);
#line 2878

#line 2878
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2878
  /* sjl: manually stripmine so we can limit amount of
#line 2878
   * vector work space reserved to LOOPCNT elements. Also
#line 2878
   * makes vectorisation easy */
#line 2878
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2878
    ni=Min(nelems-j,LOOPCNT);
#line 2878
    if (realign) {
#line 2878
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2878
      xp = tmp;
#line 2878
    } else {
#line 2878
      xp = (float *) *xpp;
#line 2878
    }
#line 2878
   /* copy the next block */
#line 2878
#pragma cdir loopcnt=LOOPCNT
#line 2878
#pragma cdir shortloop
#line 2878
    for (i=0; i<ni; i++) {
#line 2878
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2878
     /* test for range errors (not always needed but do it anyway) */
#line 2878
      nrange += xp[i] < SHORT_MIN || xp[i] > SHORT_MAX;
#line 2878
    }
#line 2878
   /* update xpp and tp */
#line 2878
    if (realign) xp = (float *) *xpp;
#line 2878
    xp += ni;
#line 2878
    tp += ni;
#line 2878
    *xpp = (void*)xp;
#line 2878
  }
#line 2878
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2878

#line 2878
#else   /* not SX */
#line 2878
	const char *xp = (const char *) *xpp;
#line 2878
	int status = ENOERR;
#line 2878

#line 2878
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2878
	{
#line 2878
		const int lstatus = ncx_get_float_short(xp, tp);
#line 2878
		if(lstatus != ENOERR)
#line 2878
			status = lstatus;
#line 2878
	}
#line 2878

#line 2878
	*xpp = (const void *)xp;
#line 2878
	return status;
#line 2878
#  endif
#line 2878
}
#line 2878

int
#line 2879
ncx_getn_float_int(const void **xpp, size_t nelems, int *tp)
#line 2879
{
#line 2879
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2879

#line 2879
 /* basic algorithm is:
#line 2879
  *   - ensure sane alignment of input data
#line 2879
  *   - copy (conversion happens automatically) input data
#line 2879
  *     to output
#line 2879
  *   - update xpp to point at next unconverted input, and tp to point
#line 2879
  *     at next location for converted output
#line 2879
  */
#line 2879
  long i, j, ni;
#line 2879
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2879
  float *xp;
#line 2879
  int nrange = 0;         /* number of range errors */
#line 2879
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2879
  long cxp = (long) *((char**)xpp);
#line 2879

#line 2879
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2879
  /* sjl: manually stripmine so we can limit amount of
#line 2879
   * vector work space reserved to LOOPCNT elements. Also
#line 2879
   * makes vectorisation easy */
#line 2879
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2879
    ni=Min(nelems-j,LOOPCNT);
#line 2879
    if (realign) {
#line 2879
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2879
      xp = tmp;
#line 2879
    } else {
#line 2879
      xp = (float *) *xpp;
#line 2879
    }
#line 2879
   /* copy the next block */
#line 2879
#pragma cdir loopcnt=LOOPCNT
#line 2879
#pragma cdir shortloop
#line 2879
    for (i=0; i<ni; i++) {
#line 2879
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2879
     /* test for range errors (not always needed but do it anyway) */
#line 2879
      nrange += xp[i] < INT_MIN || xp[i] > INT_MAX;
#line 2879
    }
#line 2879
   /* update xpp and tp */
#line 2879
    if (realign) xp = (float *) *xpp;
#line 2879
    xp += ni;
#line 2879
    tp += ni;
#line 2879
    *xpp = (void*)xp;
#line 2879
  }
#line 2879
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2879

#line 2879
#else   /* not SX */
#line 2879
	const char *xp = (const char *) *xpp;
#line 2879
	int status = ENOERR;
#line 2879

#line 2879
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2879
	{
#line 2879
		const int lstatus = ncx_get_float_int(xp, tp);
#line 2879
		if(lstatus != ENOERR)
#line 2879
			status = lstatus;
#line 2879
	}
#line 2879

#line 2879
	*xpp = (const void *)xp;
#line 2879
	return status;
#line 2879
#  endif
#line 2879
}
#line 2879

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(float));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_getn_float_float(const void **xpp, size_t nfloats, float *ip)
{
	float *const end = ip + nfloats;

	while(ip < end)
	{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 2901
		const struct ieee_single *const isp =
#line 2901
			 (const struct ieee_single *) (*xpp);
#line 2901
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 2901

#line 2901
		switch(exp) {
#line 2901
		case 0 :
#line 2901
			/* ieee subnormal */
#line 2901
			if(isp->mant_hi == min.ieee.mant_hi
#line 2901
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 2901
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 2901
			{
#line 2901
				*vsp = min.s;
#line 2901
			}
#line 2901
			else
#line 2901
			{
#line 2901
				unsigned mantissa = (isp->mant_hi << 16)
#line 2901
					 | isp->mant_lo_hi << 8
#line 2901
					 | isp->mant_lo_lo;
#line 2901
				unsigned tmp = mantissa >> 20;
#line 2901
				if(tmp >= 4) {
#line 2901
					vsp->exp = 2;
#line 2901
				} else if (tmp >= 2) {
#line 2901
					vsp->exp = 1;
#line 2901
				} else {
#line 2901
					*vsp = min.s;
#line 2901
					break;
#line 2901
				} /* else */
#line 2901
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 2901
				tmp <<= 3 - vsp->exp;
#line 2901
				vsp->mantissa2 = tmp;
#line 2901
				vsp->mantissa1 = (tmp >> 16);
#line 2901
			}
#line 2901
			break;
#line 2901
		case 0xfe :
#line 2901
		case 0xff :
#line 2901
			*vsp = max.s;
#line 2901
			break;
#line 2901
		default :
#line 2901
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 2901
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 2901
			vsp->mantissa1 = isp->mant_hi;
#line 2901
		}
#line 2901

#line 2901
		vsp->sign = isp->sign;
#line 2901


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		const int lstatus = ncx_get_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}

#endif
int
#line 2927
ncx_getn_float_double(const void **xpp, size_t nelems, double *tp)
#line 2927
{
#line 2927
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2927

#line 2927
 /* basic algorithm is:
#line 2927
  *   - ensure sane alignment of input data
#line 2927
  *   - copy (conversion happens automatically) input data
#line 2927
  *     to output
#line 2927
  *   - update xpp to point at next unconverted input, and tp to point
#line 2927
  *     at next location for converted output
#line 2927
  */
#line 2927
  long i, j, ni;
#line 2927
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2927
  float *xp;
#line 2927
  int nrange = 0;         /* number of range errors */
#line 2927
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2927
  long cxp = (long) *((char**)xpp);
#line 2927

#line 2927
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2927
  /* sjl: manually stripmine so we can limit amount of
#line 2927
   * vector work space reserved to LOOPCNT elements. Also
#line 2927
   * makes vectorisation easy */
#line 2927
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2927
    ni=Min(nelems-j,LOOPCNT);
#line 2927
    if (realign) {
#line 2927
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2927
      xp = tmp;
#line 2927
    } else {
#line 2927
      xp = (float *) *xpp;
#line 2927
    }
#line 2927
   /* copy the next block */
#line 2927
#pragma cdir loopcnt=LOOPCNT
#line 2927
#pragma cdir shortloop
#line 2927
    for (i=0; i<ni; i++) {
#line 2927
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2927
     /* test for range errors (not always needed but do it anyway) */
#line 2927
      nrange += xp[i] < DOUBLE_MIN || xp[i] > DOUBLE_MAX;
#line 2927
    }
#line 2927
   /* update xpp and tp */
#line 2927
    if (realign) xp = (float *) *xpp;
#line 2927
    xp += ni;
#line 2927
    tp += ni;
#line 2927
    *xpp = (void*)xp;
#line 2927
  }
#line 2927
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2927

#line 2927
#else   /* not SX */
#line 2927
	const char *xp = (const char *) *xpp;
#line 2927
	int status = ENOERR;
#line 2927

#line 2927
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2927
	{
#line 2927
		const int lstatus = ncx_get_float_double(xp, tp);
#line 2927
		if(lstatus != ENOERR)
#line 2927
			status = lstatus;
#line 2927
	}
#line 2927

#line 2927
	*xpp = (const void *)xp;
#line 2927
	return status;
#line 2927
#  endif
#line 2927
}
#line 2927

int
#line 2928
ncx_getn_float_uint(const void **xpp, size_t nelems, uint *tp)
#line 2928
{
#line 2928
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2928

#line 2928
 /* basic algorithm is:
#line 2928
  *   - ensure sane alignment of input data
#line 2928
  *   - copy (conversion happens automatically) input data
#line 2928
  *     to output
#line 2928
  *   - update xpp to point at next unconverted input, and tp to point
#line 2928
  *     at next location for converted output
#line 2928
  */
#line 2928
  long i, j, ni;
#line 2928
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2928
  float *xp;
#line 2928
  int nrange = 0;         /* number of range errors */
#line 2928
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2928
  long cxp = (long) *((char**)xpp);
#line 2928

#line 2928
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2928
  /* sjl: manually stripmine so we can limit amount of
#line 2928
   * vector work space reserved to LOOPCNT elements. Also
#line 2928
   * makes vectorisation easy */
#line 2928
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2928
    ni=Min(nelems-j,LOOPCNT);
#line 2928
    if (realign) {
#line 2928
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2928
      xp = tmp;
#line 2928
    } else {
#line 2928
      xp = (float *) *xpp;
#line 2928
    }
#line 2928
   /* copy the next block */
#line 2928
#pragma cdir loopcnt=LOOPCNT
#line 2928
#pragma cdir shortloop
#line 2928
    for (i=0; i<ni; i++) {
#line 2928
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2928
     /* test for range errors (not always needed but do it anyway) */
#line 2928
      nrange += xp[i] < UINT_MIN || xp[i] > UINT_MAX;
#line 2928
    }
#line 2928
   /* update xpp and tp */
#line 2928
    if (realign) xp = (float *) *xpp;
#line 2928
    xp += ni;
#line 2928
    tp += ni;
#line 2928
    *xpp = (void*)xp;
#line 2928
  }
#line 2928
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2928

#line 2928
#else   /* not SX */
#line 2928
	const char *xp = (const char *) *xpp;
#line 2928
	int status = ENOERR;
#line 2928

#line 2928
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2928
	{
#line 2928
		const int lstatus = ncx_get_float_uint(xp, tp);
#line 2928
		if(lstatus != ENOERR)
#line 2928
			status = lstatus;
#line 2928
	}
#line 2928

#line 2928
	*xpp = (const void *)xp;
#line 2928
	return status;
#line 2928
#  endif
#line 2928
}
#line 2928

int
#line 2929
ncx_getn_float_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2929
{
#line 2929
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2929

#line 2929
 /* basic algorithm is:
#line 2929
  *   - ensure sane alignment of input data
#line 2929
  *   - copy (conversion happens automatically) input data
#line 2929
  *     to output
#line 2929
  *   - update xpp to point at next unconverted input, and tp to point
#line 2929
  *     at next location for converted output
#line 2929
  */
#line 2929
  long i, j, ni;
#line 2929
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2929
  float *xp;
#line 2929
  int nrange = 0;         /* number of range errors */
#line 2929
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2929
  long cxp = (long) *((char**)xpp);
#line 2929

#line 2929
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2929
  /* sjl: manually stripmine so we can limit amount of
#line 2929
   * vector work space reserved to LOOPCNT elements. Also
#line 2929
   * makes vectorisation easy */
#line 2929
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2929
    ni=Min(nelems-j,LOOPCNT);
#line 2929
    if (realign) {
#line 2929
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2929
      xp = tmp;
#line 2929
    } else {
#line 2929
      xp = (float *) *xpp;
#line 2929
    }
#line 2929
   /* copy the next block */
#line 2929
#pragma cdir loopcnt=LOOPCNT
#line 2929
#pragma cdir shortloop
#line 2929
    for (i=0; i<ni; i++) {
#line 2929
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2929
     /* test for range errors (not always needed but do it anyway) */
#line 2929
      nrange += xp[i] < LONGLONG_MIN || xp[i] > LONGLONG_MAX;
#line 2929
    }
#line 2929
   /* update xpp and tp */
#line 2929
    if (realign) xp = (float *) *xpp;
#line 2929
    xp += ni;
#line 2929
    tp += ni;
#line 2929
    *xpp = (void*)xp;
#line 2929
  }
#line 2929
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2929

#line 2929
#else   /* not SX */
#line 2929
	const char *xp = (const char *) *xpp;
#line 2929
	int status = ENOERR;
#line 2929

#line 2929
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2929
	{
#line 2929
		const int lstatus = ncx_get_float_longlong(xp, tp);
#line 2929
		if(lstatus != ENOERR)
#line 2929
			status = lstatus;
#line 2929
	}
#line 2929

#line 2929
	*xpp = (const void *)xp;
#line 2929
	return status;
#line 2929
#  endif
#line 2929
}
#line 2929

int
#line 2930
ncx_getn_float_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2930
{
#line 2930
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2930

#line 2930
 /* basic algorithm is:
#line 2930
  *   - ensure sane alignment of input data
#line 2930
  *   - copy (conversion happens automatically) input data
#line 2930
  *     to output
#line 2930
  *   - update xpp to point at next unconverted input, and tp to point
#line 2930
  *     at next location for converted output
#line 2930
  */
#line 2930
  long i, j, ni;
#line 2930
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2930
  float *xp;
#line 2930
  int nrange = 0;         /* number of range errors */
#line 2930
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2930
  long cxp = (long) *((char**)xpp);
#line 2930

#line 2930
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2930
  /* sjl: manually stripmine so we can limit amount of
#line 2930
   * vector work space reserved to LOOPCNT elements. Also
#line 2930
   * makes vectorisation easy */
#line 2930
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2930
    ni=Min(nelems-j,LOOPCNT);
#line 2930
    if (realign) {
#line 2930
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 2930
      xp = tmp;
#line 2930
    } else {
#line 2930
      xp = (float *) *xpp;
#line 2930
    }
#line 2930
   /* copy the next block */
#line 2930
#pragma cdir loopcnt=LOOPCNT
#line 2930
#pragma cdir shortloop
#line 2930
    for (i=0; i<ni; i++) {
#line 2930
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2930
     /* test for range errors (not always needed but do it anyway) */
#line 2930
      nrange += xp[i] < ULONGLONG_MIN || xp[i] > ULONGLONG_MAX;
#line 2930
    }
#line 2930
   /* update xpp and tp */
#line 2930
    if (realign) xp = (float *) *xpp;
#line 2930
    xp += ni;
#line 2930
    tp += ni;
#line 2930
    *xpp = (void*)xp;
#line 2930
  }
#line 2930
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2930

#line 2930
#else   /* not SX */
#line 2930
	const char *xp = (const char *) *xpp;
#line 2930
	int status = ENOERR;
#line 2930

#line 2930
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2930
	{
#line 2930
		const int lstatus = ncx_get_float_ulonglong(xp, tp);
#line 2930
		if(lstatus != ENOERR)
#line 2930
			status = lstatus;
#line 2930
	}
#line 2930

#line 2930
	*xpp = (const void *)xp;
#line 2930
	return status;
#line 2930
#  endif
#line 2930
}
#line 2930


int
#line 2932
ncx_putn_float_schar(void **xpp, size_t nelems, const schar *tp)
#line 2932
{
#line 2932
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2932

#line 2932
 /* basic algorithm is:
#line 2932
  *   - ensure sane alignment of output data
#line 2932
  *   - copy (conversion happens automatically) input data
#line 2932
  *     to output
#line 2932
  *   - update tp to point at next unconverted input, and xpp to point
#line 2932
  *     at next location for converted output
#line 2932
  */
#line 2932
  long i, j, ni;
#line 2932
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2932
  float *xp;
#line 2932
  int nrange = 0;         /* number of range errors */
#line 2932
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2932
  long cxp = (long) *((char**)xpp);
#line 2932

#line 2932
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2932
  /* sjl: manually stripmine so we can limit amount of
#line 2932
   * vector work space reserved to LOOPCNT elements. Also
#line 2932
   * makes vectorisation easy */
#line 2932
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2932
    ni=Min(nelems-j,LOOPCNT);
#line 2932
    if (realign) {
#line 2932
      xp = tmp;
#line 2932
    } else {
#line 2932
      xp = (float *) *xpp;
#line 2932
    }
#line 2932
   /* copy the next block */
#line 2932
#pragma cdir loopcnt=LOOPCNT
#line 2932
#pragma cdir shortloop
#line 2932
    for (i=0; i<ni; i++) {
#line 2932
      /* the normal case: */
#line 2932
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2932
     /* test for range errors (not always needed but do it anyway) */
#line 2932
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2932
    }
#line 2932
   /* copy workspace back if necessary */
#line 2932
    if (realign) {
#line 2932
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2932
      xp = (float *) *xpp;
#line 2932
    }
#line 2932
   /* update xpp and tp */
#line 2932
    xp += ni;
#line 2932
    tp += ni;
#line 2932
    *xpp = (void*)xp;
#line 2932
  }
#line 2932
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2932

#line 2932
#else   /* not SX */
#line 2932

#line 2932
	char *xp = (char *) *xpp;
#line 2932
	int status = ENOERR;
#line 2932

#line 2932
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2932
	{
#line 2932
		int lstatus = ncx_put_float_schar(xp, tp);
#line 2932
		if(lstatus != ENOERR)
#line 2932
			status = lstatus;
#line 2932
	}
#line 2932

#line 2932
	*xpp = (void *)xp;
#line 2932
	return status;
#line 2932
#endif
#line 2932
}
#line 2932

int
#line 2933
ncx_putn_float_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2933
{
#line 2933
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2933

#line 2933
 /* basic algorithm is:
#line 2933
  *   - ensure sane alignment of output data
#line 2933
  *   - copy (conversion happens automatically) input data
#line 2933
  *     to output
#line 2933
  *   - update tp to point at next unconverted input, and xpp to point
#line 2933
  *     at next location for converted output
#line 2933
  */
#line 2933
  long i, j, ni;
#line 2933
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2933
  float *xp;
#line 2933
  int nrange = 0;         /* number of range errors */
#line 2933
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2933
  long cxp = (long) *((char**)xpp);
#line 2933

#line 2933
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2933
  /* sjl: manually stripmine so we can limit amount of
#line 2933
   * vector work space reserved to LOOPCNT elements. Also
#line 2933
   * makes vectorisation easy */
#line 2933
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2933
    ni=Min(nelems-j,LOOPCNT);
#line 2933
    if (realign) {
#line 2933
      xp = tmp;
#line 2933
    } else {
#line 2933
      xp = (float *) *xpp;
#line 2933
    }
#line 2933
   /* copy the next block */
#line 2933
#pragma cdir loopcnt=LOOPCNT
#line 2933
#pragma cdir shortloop
#line 2933
    for (i=0; i<ni; i++) {
#line 2933
      /* the normal case: */
#line 2933
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2933
     /* test for range errors (not always needed but do it anyway) */
#line 2933
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2933
    }
#line 2933
   /* copy workspace back if necessary */
#line 2933
    if (realign) {
#line 2933
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2933
      xp = (float *) *xpp;
#line 2933
    }
#line 2933
   /* update xpp and tp */
#line 2933
    xp += ni;
#line 2933
    tp += ni;
#line 2933
    *xpp = (void*)xp;
#line 2933
  }
#line 2933
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2933

#line 2933
#else   /* not SX */
#line 2933

#line 2933
	char *xp = (char *) *xpp;
#line 2933
	int status = ENOERR;
#line 2933

#line 2933
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2933
	{
#line 2933
		int lstatus = ncx_put_float_uchar(xp, tp);
#line 2933
		if(lstatus != ENOERR)
#line 2933
			status = lstatus;
#line 2933
	}
#line 2933

#line 2933
	*xpp = (void *)xp;
#line 2933
	return status;
#line 2933
#endif
#line 2933
}
#line 2933

int
#line 2934
ncx_putn_float_short(void **xpp, size_t nelems, const short *tp)
#line 2934
{
#line 2934
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2934

#line 2934
 /* basic algorithm is:
#line 2934
  *   - ensure sane alignment of output data
#line 2934
  *   - copy (conversion happens automatically) input data
#line 2934
  *     to output
#line 2934
  *   - update tp to point at next unconverted input, and xpp to point
#line 2934
  *     at next location for converted output
#line 2934
  */
#line 2934
  long i, j, ni;
#line 2934
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2934
  float *xp;
#line 2934
  int nrange = 0;         /* number of range errors */
#line 2934
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2934
  long cxp = (long) *((char**)xpp);
#line 2934

#line 2934
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2934
  /* sjl: manually stripmine so we can limit amount of
#line 2934
   * vector work space reserved to LOOPCNT elements. Also
#line 2934
   * makes vectorisation easy */
#line 2934
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2934
    ni=Min(nelems-j,LOOPCNT);
#line 2934
    if (realign) {
#line 2934
      xp = tmp;
#line 2934
    } else {
#line 2934
      xp = (float *) *xpp;
#line 2934
    }
#line 2934
   /* copy the next block */
#line 2934
#pragma cdir loopcnt=LOOPCNT
#line 2934
#pragma cdir shortloop
#line 2934
    for (i=0; i<ni; i++) {
#line 2934
      /* the normal case: */
#line 2934
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2934
     /* test for range errors (not always needed but do it anyway) */
#line 2934
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2934
    }
#line 2934
   /* copy workspace back if necessary */
#line 2934
    if (realign) {
#line 2934
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2934
      xp = (float *) *xpp;
#line 2934
    }
#line 2934
   /* update xpp and tp */
#line 2934
    xp += ni;
#line 2934
    tp += ni;
#line 2934
    *xpp = (void*)xp;
#line 2934
  }
#line 2934
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2934

#line 2934
#else   /* not SX */
#line 2934

#line 2934
	char *xp = (char *) *xpp;
#line 2934
	int status = ENOERR;
#line 2934

#line 2934
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2934
	{
#line 2934
		int lstatus = ncx_put_float_short(xp, tp);
#line 2934
		if(lstatus != ENOERR)
#line 2934
			status = lstatus;
#line 2934
	}
#line 2934

#line 2934
	*xpp = (void *)xp;
#line 2934
	return status;
#line 2934
#endif
#line 2934
}
#line 2934

int
#line 2935
ncx_putn_float_int(void **xpp, size_t nelems, const int *tp)
#line 2935
{
#line 2935
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2935

#line 2935
 /* basic algorithm is:
#line 2935
  *   - ensure sane alignment of output data
#line 2935
  *   - copy (conversion happens automatically) input data
#line 2935
  *     to output
#line 2935
  *   - update tp to point at next unconverted input, and xpp to point
#line 2935
  *     at next location for converted output
#line 2935
  */
#line 2935
  long i, j, ni;
#line 2935
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2935
  float *xp;
#line 2935
  int nrange = 0;         /* number of range errors */
#line 2935
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2935
  long cxp = (long) *((char**)xpp);
#line 2935

#line 2935
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2935
  /* sjl: manually stripmine so we can limit amount of
#line 2935
   * vector work space reserved to LOOPCNT elements. Also
#line 2935
   * makes vectorisation easy */
#line 2935
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2935
    ni=Min(nelems-j,LOOPCNT);
#line 2935
    if (realign) {
#line 2935
      xp = tmp;
#line 2935
    } else {
#line 2935
      xp = (float *) *xpp;
#line 2935
    }
#line 2935
   /* copy the next block */
#line 2935
#pragma cdir loopcnt=LOOPCNT
#line 2935
#pragma cdir shortloop
#line 2935
    for (i=0; i<ni; i++) {
#line 2935
      /* the normal case: */
#line 2935
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2935
     /* test for range errors (not always needed but do it anyway) */
#line 2935
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2935
    }
#line 2935
   /* copy workspace back if necessary */
#line 2935
    if (realign) {
#line 2935
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2935
      xp = (float *) *xpp;
#line 2935
    }
#line 2935
   /* update xpp and tp */
#line 2935
    xp += ni;
#line 2935
    tp += ni;
#line 2935
    *xpp = (void*)xp;
#line 2935
  }
#line 2935
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2935

#line 2935
#else   /* not SX */
#line 2935

#line 2935
	char *xp = (char *) *xpp;
#line 2935
	int status = ENOERR;
#line 2935

#line 2935
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2935
	{
#line 2935
		int lstatus = ncx_put_float_int(xp, tp);
#line 2935
		if(lstatus != ENOERR)
#line 2935
			status = lstatus;
#line 2935
	}
#line 2935

#line 2935
	*xpp = (void *)xp;
#line 2935
	return status;
#line 2935
#endif
#line 2935
}
#line 2935

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_FLOAT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_putn_float_float(void **xpp, size_t nfloats, const float *ip)
{
	const float *const end = ip + nfloats;

	while(ip < end)
	{
		const struct vax_single *const vsp =
#line 2957
			 (const struct vax_single *)ip;
#line 2957
		struct ieee_single *const isp = (struct ieee_single *) (*xpp);
#line 2957

#line 2957
		switch(vsp->exp){
#line 2957
		case 0 :
#line 2957
			/* all vax float with zero exponent map to zero */
#line 2957
			*isp = min.ieee;
#line 2957
			break;
#line 2957
		case 2 :
#line 2957
		case 1 :
#line 2957
		{
#line 2957
			/* These will map to subnormals */
#line 2957
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 2957
					 | vsp->mantissa2;
#line 2957
			mantissa >>= 3 - vsp->exp;
#line 2957
			mantissa += (1 << (20 + vsp->exp));
#line 2957
			isp->mant_lo_lo = mantissa;
#line 2957
			isp->mant_lo_hi = mantissa >> 8;
#line 2957
			isp->mant_hi = mantissa >> 16;
#line 2957
			isp->exp_lo = 0;
#line 2957
			isp->exp_hi = 0;
#line 2957
		}
#line 2957
			break;
#line 2957
		case 0xff : /* max.s.exp */
#line 2957
			if( vsp->mantissa2 == max.s.mantissa2
#line 2957
				&& vsp->mantissa1 == max.s.mantissa1)
#line 2957
			{
#line 2957
				/* map largest vax float to ieee infinity */
#line 2957
				*isp = max.ieee;
#line 2957
				break;
#line 2957
			} /* else, fall thru */
#line 2957
		default :
#line 2957
		{
#line 2957
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 2957
			isp->exp_hi = exp >> 1;
#line 2957
			isp->exp_lo = exp;
#line 2957
			isp->mant_lo_lo = vsp->mantissa2;
#line 2957
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 2957
			isp->mant_hi = vsp->mantissa1;
#line 2957
		}
#line 2957
		}
#line 2957

#line 2957
		isp->sign = vsp->sign;
#line 2957


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		int lstatus = ncx_put_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}

#endif
int
#line 2983
ncx_putn_float_double(void **xpp, size_t nelems, const double *tp)
#line 2983
{
#line 2983
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2983

#line 2983
 /* basic algorithm is:
#line 2983
  *   - ensure sane alignment of output data
#line 2983
  *   - copy (conversion happens automatically) input data
#line 2983
  *     to output
#line 2983
  *   - update tp to point at next unconverted input, and xpp to point
#line 2983
  *     at next location for converted output
#line 2983
  */
#line 2983
  long i, j, ni;
#line 2983
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2983
  float *xp;
#line 2983
  int nrange = 0;         /* number of range errors */
#line 2983
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2983
  long cxp = (long) *((char**)xpp);
#line 2983

#line 2983
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2983
  /* sjl: manually stripmine so we can limit amount of
#line 2983
   * vector work space reserved to LOOPCNT elements. Also
#line 2983
   * makes vectorisation easy */
#line 2983
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2983
    ni=Min(nelems-j,LOOPCNT);
#line 2983
    if (realign) {
#line 2983
      xp = tmp;
#line 2983
    } else {
#line 2983
      xp = (float *) *xpp;
#line 2983
    }
#line 2983
   /* copy the next block */
#line 2983
#pragma cdir loopcnt=LOOPCNT
#line 2983
#pragma cdir shortloop
#line 2983
    for (i=0; i<ni; i++) {
#line 2983
      /* the normal case: */
#line 2983
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2983
     /* test for range errors (not always needed but do it anyway) */
#line 2983
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2983
    }
#line 2983
   /* copy workspace back if necessary */
#line 2983
    if (realign) {
#line 2983
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2983
      xp = (float *) *xpp;
#line 2983
    }
#line 2983
   /* update xpp and tp */
#line 2983
    xp += ni;
#line 2983
    tp += ni;
#line 2983
    *xpp = (void*)xp;
#line 2983
  }
#line 2983
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2983

#line 2983
#else   /* not SX */
#line 2983

#line 2983
	char *xp = (char *) *xpp;
#line 2983
	int status = ENOERR;
#line 2983

#line 2983
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2983
	{
#line 2983
		int lstatus = ncx_put_float_double(xp, tp);
#line 2983
		if(lstatus != ENOERR)
#line 2983
			status = lstatus;
#line 2983
	}
#line 2983

#line 2983
	*xpp = (void *)xp;
#line 2983
	return status;
#line 2983
#endif
#line 2983
}
#line 2983

int
#line 2984
ncx_putn_float_uint(void **xpp, size_t nelems, const uint *tp)
#line 2984
{
#line 2984
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2984

#line 2984
 /* basic algorithm is:
#line 2984
  *   - ensure sane alignment of output data
#line 2984
  *   - copy (conversion happens automatically) input data
#line 2984
  *     to output
#line 2984
  *   - update tp to point at next unconverted input, and xpp to point
#line 2984
  *     at next location for converted output
#line 2984
  */
#line 2984
  long i, j, ni;
#line 2984
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2984
  float *xp;
#line 2984
  int nrange = 0;         /* number of range errors */
#line 2984
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2984
  long cxp = (long) *((char**)xpp);
#line 2984

#line 2984
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2984
  /* sjl: manually stripmine so we can limit amount of
#line 2984
   * vector work space reserved to LOOPCNT elements. Also
#line 2984
   * makes vectorisation easy */
#line 2984
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2984
    ni=Min(nelems-j,LOOPCNT);
#line 2984
    if (realign) {
#line 2984
      xp = tmp;
#line 2984
    } else {
#line 2984
      xp = (float *) *xpp;
#line 2984
    }
#line 2984
   /* copy the next block */
#line 2984
#pragma cdir loopcnt=LOOPCNT
#line 2984
#pragma cdir shortloop
#line 2984
    for (i=0; i<ni; i++) {
#line 2984
      /* the normal case: */
#line 2984
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2984
     /* test for range errors (not always needed but do it anyway) */
#line 2984
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2984
    }
#line 2984
   /* copy workspace back if necessary */
#line 2984
    if (realign) {
#line 2984
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2984
      xp = (float *) *xpp;
#line 2984
    }
#line 2984
   /* update xpp and tp */
#line 2984
    xp += ni;
#line 2984
    tp += ni;
#line 2984
    *xpp = (void*)xp;
#line 2984
  }
#line 2984
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2984

#line 2984
#else   /* not SX */
#line 2984

#line 2984
	char *xp = (char *) *xpp;
#line 2984
	int status = ENOERR;
#line 2984

#line 2984
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2984
	{
#line 2984
		int lstatus = ncx_put_float_uint(xp, tp);
#line 2984
		if(lstatus != ENOERR)
#line 2984
			status = lstatus;
#line 2984
	}
#line 2984

#line 2984
	*xpp = (void *)xp;
#line 2984
	return status;
#line 2984
#endif
#line 2984
}
#line 2984

int
#line 2985
ncx_putn_float_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2985
{
#line 2985
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2985

#line 2985
 /* basic algorithm is:
#line 2985
  *   - ensure sane alignment of output data
#line 2985
  *   - copy (conversion happens automatically) input data
#line 2985
  *     to output
#line 2985
  *   - update tp to point at next unconverted input, and xpp to point
#line 2985
  *     at next location for converted output
#line 2985
  */
#line 2985
  long i, j, ni;
#line 2985
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2985
  float *xp;
#line 2985
  int nrange = 0;         /* number of range errors */
#line 2985
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2985
  long cxp = (long) *((char**)xpp);
#line 2985

#line 2985
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2985
  /* sjl: manually stripmine so we can limit amount of
#line 2985
   * vector work space reserved to LOOPCNT elements. Also
#line 2985
   * makes vectorisation easy */
#line 2985
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2985
    ni=Min(nelems-j,LOOPCNT);
#line 2985
    if (realign) {
#line 2985
      xp = tmp;
#line 2985
    } else {
#line 2985
      xp = (float *) *xpp;
#line 2985
    }
#line 2985
   /* copy the next block */
#line 2985
#pragma cdir loopcnt=LOOPCNT
#line 2985
#pragma cdir shortloop
#line 2985
    for (i=0; i<ni; i++) {
#line 2985
      /* the normal case: */
#line 2985
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2985
     /* test for range errors (not always needed but do it anyway) */
#line 2985
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2985
    }
#line 2985
   /* copy workspace back if necessary */
#line 2985
    if (realign) {
#line 2985
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2985
      xp = (float *) *xpp;
#line 2985
    }
#line 2985
   /* update xpp and tp */
#line 2985
    xp += ni;
#line 2985
    tp += ni;
#line 2985
    *xpp = (void*)xp;
#line 2985
  }
#line 2985
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2985

#line 2985
#else   /* not SX */
#line 2985

#line 2985
	char *xp = (char *) *xpp;
#line 2985
	int status = ENOERR;
#line 2985

#line 2985
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2985
	{
#line 2985
		int lstatus = ncx_put_float_longlong(xp, tp);
#line 2985
		if(lstatus != ENOERR)
#line 2985
			status = lstatus;
#line 2985
	}
#line 2985

#line 2985
	*xpp = (void *)xp;
#line 2985
	return status;
#line 2985
#endif
#line 2985
}
#line 2985

int
#line 2986
ncx_putn_float_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2986
{
#line 2986
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 2986

#line 2986
 /* basic algorithm is:
#line 2986
  *   - ensure sane alignment of output data
#line 2986
  *   - copy (conversion happens automatically) input data
#line 2986
  *     to output
#line 2986
  *   - update tp to point at next unconverted input, and xpp to point
#line 2986
  *     at next location for converted output
#line 2986
  */
#line 2986
  long i, j, ni;
#line 2986
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 2986
  float *xp;
#line 2986
  int nrange = 0;         /* number of range errors */
#line 2986
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2986
  long cxp = (long) *((char**)xpp);
#line 2986

#line 2986
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 2986
  /* sjl: manually stripmine so we can limit amount of
#line 2986
   * vector work space reserved to LOOPCNT elements. Also
#line 2986
   * makes vectorisation easy */
#line 2986
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2986
    ni=Min(nelems-j,LOOPCNT);
#line 2986
    if (realign) {
#line 2986
      xp = tmp;
#line 2986
    } else {
#line 2986
      xp = (float *) *xpp;
#line 2986
    }
#line 2986
   /* copy the next block */
#line 2986
#pragma cdir loopcnt=LOOPCNT
#line 2986
#pragma cdir shortloop
#line 2986
    for (i=0; i<ni; i++) {
#line 2986
      /* the normal case: */
#line 2986
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 2986
     /* test for range errors (not always needed but do it anyway) */
#line 2986
      nrange += tp[i] < X_FLOAT_MIN || tp[i] > X_FLOAT_MAX;
#line 2986
    }
#line 2986
   /* copy workspace back if necessary */
#line 2986
    if (realign) {
#line 2986
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 2986
      xp = (float *) *xpp;
#line 2986
    }
#line 2986
   /* update xpp and tp */
#line 2986
    xp += ni;
#line 2986
    tp += ni;
#line 2986
    *xpp = (void*)xp;
#line 2986
  }
#line 2986
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2986

#line 2986
#else   /* not SX */
#line 2986

#line 2986
	char *xp = (char *) *xpp;
#line 2986
	int status = ENOERR;
#line 2986

#line 2986
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 2986
	{
#line 2986
		int lstatus = ncx_put_float_ulonglong(xp, tp);
#line 2986
		if(lstatus != ENOERR)
#line 2986
			status = lstatus;
#line 2986
	}
#line 2986

#line 2986
	*xpp = (void *)xp;
#line 2986
	return status;
#line 2986
#endif
#line 2986
}
#line 2986


/* double */

int
#line 2990
ncx_getn_double_schar(const void **xpp, size_t nelems, schar *tp)
#line 2990
{
#line 2990
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2990

#line 2990
 /* basic algorithm is:
#line 2990
  *   - ensure sane alignment of input data
#line 2990
  *   - copy (conversion happens automatically) input data
#line 2990
  *     to output
#line 2990
  *   - update xpp to point at next unconverted input, and tp to point
#line 2990
  *     at next location for converted output
#line 2990
  */
#line 2990
  long i, j, ni;
#line 2990
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2990
  double *xp;
#line 2990
  int nrange = 0;         /* number of range errors */
#line 2990
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2990
  long cxp = (long) *((char**)xpp);
#line 2990

#line 2990
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2990
  /* sjl: manually stripmine so we can limit amount of
#line 2990
   * vector work space reserved to LOOPCNT elements. Also
#line 2990
   * makes vectorisation easy */
#line 2990
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2990
    ni=Min(nelems-j,LOOPCNT);
#line 2990
    if (realign) {
#line 2990
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2990
      xp = tmp;
#line 2990
    } else {
#line 2990
      xp = (double *) *xpp;
#line 2990
    }
#line 2990
   /* copy the next block */
#line 2990
#pragma cdir loopcnt=LOOPCNT
#line 2990
#pragma cdir shortloop
#line 2990
    for (i=0; i<ni; i++) {
#line 2990
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2990
     /* test for range errors (not always needed but do it anyway) */
#line 2990
      nrange += xp[i] < SCHAR_MIN || xp[i] > SCHAR_MAX;
#line 2990
    }
#line 2990
   /* update xpp and tp */
#line 2990
    if (realign) xp = (double *) *xpp;
#line 2990
    xp += ni;
#line 2990
    tp += ni;
#line 2990
    *xpp = (void*)xp;
#line 2990
  }
#line 2990
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2990

#line 2990
#else   /* not SX */
#line 2990
	const char *xp = (const char *) *xpp;
#line 2990
	int status = ENOERR;
#line 2990

#line 2990
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2990
	{
#line 2990
		const int lstatus = ncx_get_double_schar(xp, tp);
#line 2990
		if(lstatus != ENOERR)
#line 2990
			status = lstatus;
#line 2990
	}
#line 2990

#line 2990
	*xpp = (const void *)xp;
#line 2990
	return status;
#line 2990
#  endif
#line 2990
}
#line 2990

int
#line 2991
ncx_getn_double_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2991
{
#line 2991
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2991

#line 2991
 /* basic algorithm is:
#line 2991
  *   - ensure sane alignment of input data
#line 2991
  *   - copy (conversion happens automatically) input data
#line 2991
  *     to output
#line 2991
  *   - update xpp to point at next unconverted input, and tp to point
#line 2991
  *     at next location for converted output
#line 2991
  */
#line 2991
  long i, j, ni;
#line 2991
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2991
  double *xp;
#line 2991
  int nrange = 0;         /* number of range errors */
#line 2991
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2991
  long cxp = (long) *((char**)xpp);
#line 2991

#line 2991
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2991
  /* sjl: manually stripmine so we can limit amount of
#line 2991
   * vector work space reserved to LOOPCNT elements. Also
#line 2991
   * makes vectorisation easy */
#line 2991
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2991
    ni=Min(nelems-j,LOOPCNT);
#line 2991
    if (realign) {
#line 2991
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2991
      xp = tmp;
#line 2991
    } else {
#line 2991
      xp = (double *) *xpp;
#line 2991
    }
#line 2991
   /* copy the next block */
#line 2991
#pragma cdir loopcnt=LOOPCNT
#line 2991
#pragma cdir shortloop
#line 2991
    for (i=0; i<ni; i++) {
#line 2991
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2991
     /* test for range errors (not always needed but do it anyway) */
#line 2991
      nrange += xp[i] < UCHAR_MIN || xp[i] > UCHAR_MAX;
#line 2991
    }
#line 2991
   /* update xpp and tp */
#line 2991
    if (realign) xp = (double *) *xpp;
#line 2991
    xp += ni;
#line 2991
    tp += ni;
#line 2991
    *xpp = (void*)xp;
#line 2991
  }
#line 2991
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2991

#line 2991
#else   /* not SX */
#line 2991
	const char *xp = (const char *) *xpp;
#line 2991
	int status = ENOERR;
#line 2991

#line 2991
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2991
	{
#line 2991
		const int lstatus = ncx_get_double_uchar(xp, tp);
#line 2991
		if(lstatus != ENOERR)
#line 2991
			status = lstatus;
#line 2991
	}
#line 2991

#line 2991
	*xpp = (const void *)xp;
#line 2991
	return status;
#line 2991
#  endif
#line 2991
}
#line 2991

int
#line 2992
ncx_getn_double_short(const void **xpp, size_t nelems, short *tp)
#line 2992
{
#line 2992
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2992

#line 2992
 /* basic algorithm is:
#line 2992
  *   - ensure sane alignment of input data
#line 2992
  *   - copy (conversion happens automatically) input data
#line 2992
  *     to output
#line 2992
  *   - update xpp to point at next unconverted input, and tp to point
#line 2992
  *     at next location for converted output
#line 2992
  */
#line 2992
  long i, j, ni;
#line 2992
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2992
  double *xp;
#line 2992
  int nrange = 0;         /* number of range errors */
#line 2992
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2992
  long cxp = (long) *((char**)xpp);
#line 2992

#line 2992
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2992
  /* sjl: manually stripmine so we can limit amount of
#line 2992
   * vector work space reserved to LOOPCNT elements. Also
#line 2992
   * makes vectorisation easy */
#line 2992
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2992
    ni=Min(nelems-j,LOOPCNT);
#line 2992
    if (realign) {
#line 2992
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2992
      xp = tmp;
#line 2992
    } else {
#line 2992
      xp = (double *) *xpp;
#line 2992
    }
#line 2992
   /* copy the next block */
#line 2992
#pragma cdir loopcnt=LOOPCNT
#line 2992
#pragma cdir shortloop
#line 2992
    for (i=0; i<ni; i++) {
#line 2992
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2992
     /* test for range errors (not always needed but do it anyway) */
#line 2992
      nrange += xp[i] < SHORT_MIN || xp[i] > SHORT_MAX;
#line 2992
    }
#line 2992
   /* update xpp and tp */
#line 2992
    if (realign) xp = (double *) *xpp;
#line 2992
    xp += ni;
#line 2992
    tp += ni;
#line 2992
    *xpp = (void*)xp;
#line 2992
  }
#line 2992
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2992

#line 2992
#else   /* not SX */
#line 2992
	const char *xp = (const char *) *xpp;
#line 2992
	int status = ENOERR;
#line 2992

#line 2992
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2992
	{
#line 2992
		const int lstatus = ncx_get_double_short(xp, tp);
#line 2992
		if(lstatus != ENOERR)
#line 2992
			status = lstatus;
#line 2992
	}
#line 2992

#line 2992
	*xpp = (const void *)xp;
#line 2992
	return status;
#line 2992
#  endif
#line 2992
}
#line 2992

int
#line 2993
ncx_getn_double_int(const void **xpp, size_t nelems, int *tp)
#line 2993
{
#line 2993
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2993

#line 2993
 /* basic algorithm is:
#line 2993
  *   - ensure sane alignment of input data
#line 2993
  *   - copy (conversion happens automatically) input data
#line 2993
  *     to output
#line 2993
  *   - update xpp to point at next unconverted input, and tp to point
#line 2993
  *     at next location for converted output
#line 2993
  */
#line 2993
  long i, j, ni;
#line 2993
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2993
  double *xp;
#line 2993
  int nrange = 0;         /* number of range errors */
#line 2993
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2993
  long cxp = (long) *((char**)xpp);
#line 2993

#line 2993
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2993
  /* sjl: manually stripmine so we can limit amount of
#line 2993
   * vector work space reserved to LOOPCNT elements. Also
#line 2993
   * makes vectorisation easy */
#line 2993
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2993
    ni=Min(nelems-j,LOOPCNT);
#line 2993
    if (realign) {
#line 2993
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2993
      xp = tmp;
#line 2993
    } else {
#line 2993
      xp = (double *) *xpp;
#line 2993
    }
#line 2993
   /* copy the next block */
#line 2993
#pragma cdir loopcnt=LOOPCNT
#line 2993
#pragma cdir shortloop
#line 2993
    for (i=0; i<ni; i++) {
#line 2993
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2993
     /* test for range errors (not always needed but do it anyway) */
#line 2993
      nrange += xp[i] < INT_MIN || xp[i] > INT_MAX;
#line 2993
    }
#line 2993
   /* update xpp and tp */
#line 2993
    if (realign) xp = (double *) *xpp;
#line 2993
    xp += ni;
#line 2993
    tp += ni;
#line 2993
    *xpp = (void*)xp;
#line 2993
  }
#line 2993
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2993

#line 2993
#else   /* not SX */
#line 2993
	const char *xp = (const char *) *xpp;
#line 2993
	int status = ENOERR;
#line 2993

#line 2993
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2993
	{
#line 2993
		const int lstatus = ncx_get_double_int(xp, tp);
#line 2993
		if(lstatus != ENOERR)
#line 2993
			status = lstatus;
#line 2993
	}
#line 2993

#line 2993
	*xpp = (const void *)xp;
#line 2993
	return status;
#line 2993
#  endif
#line 2993
}
#line 2993

int
#line 2994
ncx_getn_double_float(const void **xpp, size_t nelems, float *tp)
#line 2994
{
#line 2994
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2994

#line 2994
 /* basic algorithm is:
#line 2994
  *   - ensure sane alignment of input data
#line 2994
  *   - copy (conversion happens automatically) input data
#line 2994
  *     to output
#line 2994
  *   - update xpp to point at next unconverted input, and tp to point
#line 2994
  *     at next location for converted output
#line 2994
  */
#line 2994
  long i, j, ni;
#line 2994
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2994
  double *xp;
#line 2994
  int nrange = 0;         /* number of range errors */
#line 2994
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2994
  long cxp = (long) *((char**)xpp);
#line 2994

#line 2994
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2994
  /* sjl: manually stripmine so we can limit amount of
#line 2994
   * vector work space reserved to LOOPCNT elements. Also
#line 2994
   * makes vectorisation easy */
#line 2994
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2994
    ni=Min(nelems-j,LOOPCNT);
#line 2994
    if (realign) {
#line 2994
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2994
      xp = tmp;
#line 2994
    } else {
#line 2994
      xp = (double *) *xpp;
#line 2994
    }
#line 2994
   /* copy the next block */
#line 2994
#pragma cdir loopcnt=LOOPCNT
#line 2994
#pragma cdir shortloop
#line 2994
    for (i=0; i<ni; i++) {
#line 2994
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2994
     /* test for range errors (not always needed but do it anyway) */
#line 2994
      nrange += xp[i] < FLOAT_MIN || xp[i] > FLOAT_MAX;
#line 2994
    }
#line 2994
   /* update xpp and tp */
#line 2994
    if (realign) xp = (double *) *xpp;
#line 2994
    xp += ni;
#line 2994
    tp += ni;
#line 2994
    *xpp = (void*)xp;
#line 2994
  }
#line 2994
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2994

#line 2994
#else   /* not SX */
#line 2994
	const char *xp = (const char *) *xpp;
#line 2994
	int status = ENOERR;
#line 2994

#line 2994
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2994
	{
#line 2994
		const int lstatus = ncx_get_double_float(xp, tp);
#line 2994
		if(lstatus != ENOERR)
#line 2994
			status = lstatus;
#line 2994
	}
#line 2994

#line 2994
	*xpp = (const void *)xp;
#line 2994
	return status;
#line 2994
#  endif
#line 2994
}
#line 2994

#line 2996
int
#line 2996
ncx_getn_double_uint(const void **xpp, size_t nelems, uint *tp)
#line 2996
{
#line 2996
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2996

#line 2996
 /* basic algorithm is:
#line 2996
  *   - ensure sane alignment of input data
#line 2996
  *   - copy (conversion happens automatically) input data
#line 2996
  *     to output
#line 2996
  *   - update xpp to point at next unconverted input, and tp to point
#line 2996
  *     at next location for converted output
#line 2996
  */
#line 2996
  long i, j, ni;
#line 2996
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2996
  double *xp;
#line 2996
  int nrange = 0;         /* number of range errors */
#line 2996
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2996
  long cxp = (long) *((char**)xpp);
#line 2996

#line 2996
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2996
  /* sjl: manually stripmine so we can limit amount of
#line 2996
   * vector work space reserved to LOOPCNT elements. Also
#line 2996
   * makes vectorisation easy */
#line 2996
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2996
    ni=Min(nelems-j,LOOPCNT);
#line 2996
    if (realign) {
#line 2996
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2996
      xp = tmp;
#line 2996
    } else {
#line 2996
      xp = (double *) *xpp;
#line 2996
    }
#line 2996
   /* copy the next block */
#line 2996
#pragma cdir loopcnt=LOOPCNT
#line 2996
#pragma cdir shortloop
#line 2996
    for (i=0; i<ni; i++) {
#line 2996
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2996
     /* test for range errors (not always needed but do it anyway) */
#line 2996
      nrange += xp[i] < UINT_MIN || xp[i] > UINT_MAX;
#line 2996
    }
#line 2996
   /* update xpp and tp */
#line 2996
    if (realign) xp = (double *) *xpp;
#line 2996
    xp += ni;
#line 2996
    tp += ni;
#line 2996
    *xpp = (void*)xp;
#line 2996
  }
#line 2996
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2996

#line 2996
#else   /* not SX */
#line 2996
	const char *xp = (const char *) *xpp;
#line 2996
	int status = ENOERR;
#line 2996

#line 2996
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2996
	{
#line 2996
		const int lstatus = ncx_get_double_uint(xp, tp);
#line 2996
		if(lstatus != ENOERR)
#line 2996
			status = lstatus;
#line 2996
	}
#line 2996

#line 2996
	*xpp = (const void *)xp;
#line 2996
	return status;
#line 2996
#  endif
#line 2996
}
#line 2996

int
#line 2997
ncx_getn_double_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2997
{
#line 2997
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2997

#line 2997
 /* basic algorithm is:
#line 2997
  *   - ensure sane alignment of input data
#line 2997
  *   - copy (conversion happens automatically) input data
#line 2997
  *     to output
#line 2997
  *   - update xpp to point at next unconverted input, and tp to point
#line 2997
  *     at next location for converted output
#line 2997
  */
#line 2997
  long i, j, ni;
#line 2997
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2997
  double *xp;
#line 2997
  int nrange = 0;         /* number of range errors */
#line 2997
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2997
  long cxp = (long) *((char**)xpp);
#line 2997

#line 2997
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2997
  /* sjl: manually stripmine so we can limit amount of
#line 2997
   * vector work space reserved to LOOPCNT elements. Also
#line 2997
   * makes vectorisation easy */
#line 2997
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2997
    ni=Min(nelems-j,LOOPCNT);
#line 2997
    if (realign) {
#line 2997
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2997
      xp = tmp;
#line 2997
    } else {
#line 2997
      xp = (double *) *xpp;
#line 2997
    }
#line 2997
   /* copy the next block */
#line 2997
#pragma cdir loopcnt=LOOPCNT
#line 2997
#pragma cdir shortloop
#line 2997
    for (i=0; i<ni; i++) {
#line 2997
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2997
     /* test for range errors (not always needed but do it anyway) */
#line 2997
      nrange += xp[i] < LONGLONG_MIN || xp[i] > LONGLONG_MAX;
#line 2997
    }
#line 2997
   /* update xpp and tp */
#line 2997
    if (realign) xp = (double *) *xpp;
#line 2997
    xp += ni;
#line 2997
    tp += ni;
#line 2997
    *xpp = (void*)xp;
#line 2997
  }
#line 2997
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2997

#line 2997
#else   /* not SX */
#line 2997
	const char *xp = (const char *) *xpp;
#line 2997
	int status = ENOERR;
#line 2997

#line 2997
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2997
	{
#line 2997
		const int lstatus = ncx_get_double_longlong(xp, tp);
#line 2997
		if(lstatus != ENOERR)
#line 2997
			status = lstatus;
#line 2997
	}
#line 2997

#line 2997
	*xpp = (const void *)xp;
#line 2997
	return status;
#line 2997
#  endif
#line 2997
}
#line 2997

int
#line 2998
ncx_getn_double_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2998
{
#line 2998
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 2998

#line 2998
 /* basic algorithm is:
#line 2998
  *   - ensure sane alignment of input data
#line 2998
  *   - copy (conversion happens automatically) input data
#line 2998
  *     to output
#line 2998
  *   - update xpp to point at next unconverted input, and tp to point
#line 2998
  *     at next location for converted output
#line 2998
  */
#line 2998
  long i, j, ni;
#line 2998
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 2998
  double *xp;
#line 2998
  int nrange = 0;         /* number of range errors */
#line 2998
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2998
  long cxp = (long) *((char**)xpp);
#line 2998

#line 2998
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 2998
  /* sjl: manually stripmine so we can limit amount of
#line 2998
   * vector work space reserved to LOOPCNT elements. Also
#line 2998
   * makes vectorisation easy */
#line 2998
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2998
    ni=Min(nelems-j,LOOPCNT);
#line 2998
    if (realign) {
#line 2998
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 2998
      xp = tmp;
#line 2998
    } else {
#line 2998
      xp = (double *) *xpp;
#line 2998
    }
#line 2998
   /* copy the next block */
#line 2998
#pragma cdir loopcnt=LOOPCNT
#line 2998
#pragma cdir shortloop
#line 2998
    for (i=0; i<ni; i++) {
#line 2998
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2998
     /* test for range errors (not always needed but do it anyway) */
#line 2998
      nrange += xp[i] < ULONGLONG_MIN || xp[i] > ULONGLONG_MAX;
#line 2998
    }
#line 2998
   /* update xpp and tp */
#line 2998
    if (realign) xp = (double *) *xpp;
#line 2998
    xp += ni;
#line 2998
    tp += ni;
#line 2998
    *xpp = (void*)xp;
#line 2998
  }
#line 2998
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2998

#line 2998
#else   /* not SX */
#line 2998
	const char *xp = (const char *) *xpp;
#line 2998
	int status = ENOERR;
#line 2998

#line 2998
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 2998
	{
#line 2998
		const int lstatus = ncx_get_double_ulonglong(xp, tp);
#line 2998
		if(lstatus != ENOERR)
#line 2998
			status = lstatus;
#line 2998
	}
#line 2998

#line 2998
	*xpp = (const void *)xp;
#line 2998
	return status;
#line 2998
#  endif
#line 2998
}
#line 2998

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(double));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_getn_double_double(const void **xpp, size_t ndoubles, double *ip)
{
	double *const end = ip + ndoubles;

	while(ip < end)
	{
	struct vax_double *const vdp =
#line 3020
			 (struct vax_double *)ip;
#line 3020
	const struct ieee_double *const idp =
#line 3020
			 (const struct ieee_double *) (*xpp);
#line 3020
	{
#line 3020
		const struct dbl_limits *lim;
#line 3020
		int ii;
#line 3020
		for (ii = 0, lim = dbl_limits;
#line 3020
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 3020
			ii++, lim++)
#line 3020
		{
#line 3020
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 3020
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 3020
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 3020
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 3020
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 3020
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 3020
				)
#line 3020
			{
#line 3020
				*vdp = lim->d;
#line 3020
				goto doneit;
#line 3020
			}
#line 3020
		}
#line 3020
	}
#line 3020
	{
#line 3020
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 3020
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 3020
	}
#line 3020
	{
#line 3020
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 3020
				 | (idp->mant_5 << 8)
#line 3020
				 | idp->mant_4);
#line 3020
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 3020
		vdp->mantissa1 = (mant_hi >> 13);
#line 3020
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 3020
				| (mant_lo >> 29);
#line 3020
		vdp->mantissa3 = (mant_lo >> 13);
#line 3020
		vdp->mantissa4 = (mant_lo << 3);
#line 3020
	}
#line 3020
	doneit:
#line 3020
		vdp->sign = idp->sign;
#line 3020

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		const int lstatus = ncx_get_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}

#endif

int
#line 3047
ncx_putn_double_schar(void **xpp, size_t nelems, const schar *tp)
#line 3047
{
#line 3047
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3047

#line 3047
 /* basic algorithm is:
#line 3047
  *   - ensure sane alignment of output data
#line 3047
  *   - copy (conversion happens automatically) input data
#line 3047
  *     to output
#line 3047
  *   - update tp to point at next unconverted input, and xpp to point
#line 3047
  *     at next location for converted output
#line 3047
  */
#line 3047
  long i, j, ni;
#line 3047
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3047
  double *xp;
#line 3047
  int nrange = 0;         /* number of range errors */
#line 3047
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3047
  long cxp = (long) *((char**)xpp);
#line 3047

#line 3047
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3047
  /* sjl: manually stripmine so we can limit amount of
#line 3047
   * vector work space reserved to LOOPCNT elements. Also
#line 3047
   * makes vectorisation easy */
#line 3047
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3047
    ni=Min(nelems-j,LOOPCNT);
#line 3047
    if (realign) {
#line 3047
      xp = tmp;
#line 3047
    } else {
#line 3047
      xp = (double *) *xpp;
#line 3047
    }
#line 3047
   /* copy the next block */
#line 3047
#pragma cdir loopcnt=LOOPCNT
#line 3047
#pragma cdir shortloop
#line 3047
    for (i=0; i<ni; i++) {
#line 3047
      /* the normal case: */
#line 3047
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3047
     /* test for range errors (not always needed but do it anyway) */
#line 3047
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3047
    }
#line 3047
   /* copy workspace back if necessary */
#line 3047
    if (realign) {
#line 3047
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3047
      xp = (double *) *xpp;
#line 3047
    }
#line 3047
   /* update xpp and tp */
#line 3047
    xp += ni;
#line 3047
    tp += ni;
#line 3047
    *xpp = (void*)xp;
#line 3047
  }
#line 3047
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3047

#line 3047
#else   /* not SX */
#line 3047

#line 3047
	char *xp = (char *) *xpp;
#line 3047
	int status = ENOERR;
#line 3047

#line 3047
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3047
	{
#line 3047
		int lstatus = ncx_put_double_schar(xp, tp);
#line 3047
		if(lstatus != ENOERR)
#line 3047
			status = lstatus;
#line 3047
	}
#line 3047

#line 3047
	*xpp = (void *)xp;
#line 3047
	return status;
#line 3047
#endif
#line 3047
}
#line 3047

int
#line 3048
ncx_putn_double_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3048
{
#line 3048
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3048

#line 3048
 /* basic algorithm is:
#line 3048
  *   - ensure sane alignment of output data
#line 3048
  *   - copy (conversion happens automatically) input data
#line 3048
  *     to output
#line 3048
  *   - update tp to point at next unconverted input, and xpp to point
#line 3048
  *     at next location for converted output
#line 3048
  */
#line 3048
  long i, j, ni;
#line 3048
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3048
  double *xp;
#line 3048
  int nrange = 0;         /* number of range errors */
#line 3048
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3048
  long cxp = (long) *((char**)xpp);
#line 3048

#line 3048
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3048
  /* sjl: manually stripmine so we can limit amount of
#line 3048
   * vector work space reserved to LOOPCNT elements. Also
#line 3048
   * makes vectorisation easy */
#line 3048
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3048
    ni=Min(nelems-j,LOOPCNT);
#line 3048
    if (realign) {
#line 3048
      xp = tmp;
#line 3048
    } else {
#line 3048
      xp = (double *) *xpp;
#line 3048
    }
#line 3048
   /* copy the next block */
#line 3048
#pragma cdir loopcnt=LOOPCNT
#line 3048
#pragma cdir shortloop
#line 3048
    for (i=0; i<ni; i++) {
#line 3048
      /* the normal case: */
#line 3048
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3048
     /* test for range errors (not always needed but do it anyway) */
#line 3048
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3048
    }
#line 3048
   /* copy workspace back if necessary */
#line 3048
    if (realign) {
#line 3048
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3048
      xp = (double *) *xpp;
#line 3048
    }
#line 3048
   /* update xpp and tp */
#line 3048
    xp += ni;
#line 3048
    tp += ni;
#line 3048
    *xpp = (void*)xp;
#line 3048
  }
#line 3048
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3048

#line 3048
#else   /* not SX */
#line 3048

#line 3048
	char *xp = (char *) *xpp;
#line 3048
	int status = ENOERR;
#line 3048

#line 3048
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3048
	{
#line 3048
		int lstatus = ncx_put_double_uchar(xp, tp);
#line 3048
		if(lstatus != ENOERR)
#line 3048
			status = lstatus;
#line 3048
	}
#line 3048

#line 3048
	*xpp = (void *)xp;
#line 3048
	return status;
#line 3048
#endif
#line 3048
}
#line 3048

int
#line 3049
ncx_putn_double_short(void **xpp, size_t nelems, const short *tp)
#line 3049
{
#line 3049
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3049

#line 3049
 /* basic algorithm is:
#line 3049
  *   - ensure sane alignment of output data
#line 3049
  *   - copy (conversion happens automatically) input data
#line 3049
  *     to output
#line 3049
  *   - update tp to point at next unconverted input, and xpp to point
#line 3049
  *     at next location for converted output
#line 3049
  */
#line 3049
  long i, j, ni;
#line 3049
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3049
  double *xp;
#line 3049
  int nrange = 0;         /* number of range errors */
#line 3049
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3049
  long cxp = (long) *((char**)xpp);
#line 3049

#line 3049
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3049
  /* sjl: manually stripmine so we can limit amount of
#line 3049
   * vector work space reserved to LOOPCNT elements. Also
#line 3049
   * makes vectorisation easy */
#line 3049
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3049
    ni=Min(nelems-j,LOOPCNT);
#line 3049
    if (realign) {
#line 3049
      xp = tmp;
#line 3049
    } else {
#line 3049
      xp = (double *) *xpp;
#line 3049
    }
#line 3049
   /* copy the next block */
#line 3049
#pragma cdir loopcnt=LOOPCNT
#line 3049
#pragma cdir shortloop
#line 3049
    for (i=0; i<ni; i++) {
#line 3049
      /* the normal case: */
#line 3049
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3049
     /* test for range errors (not always needed but do it anyway) */
#line 3049
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3049
    }
#line 3049
   /* copy workspace back if necessary */
#line 3049
    if (realign) {
#line 3049
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3049
      xp = (double *) *xpp;
#line 3049
    }
#line 3049
   /* update xpp and tp */
#line 3049
    xp += ni;
#line 3049
    tp += ni;
#line 3049
    *xpp = (void*)xp;
#line 3049
  }
#line 3049
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3049

#line 3049
#else   /* not SX */
#line 3049

#line 3049
	char *xp = (char *) *xpp;
#line 3049
	int status = ENOERR;
#line 3049

#line 3049
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3049
	{
#line 3049
		int lstatus = ncx_put_double_short(xp, tp);
#line 3049
		if(lstatus != ENOERR)
#line 3049
			status = lstatus;
#line 3049
	}
#line 3049

#line 3049
	*xpp = (void *)xp;
#line 3049
	return status;
#line 3049
#endif
#line 3049
}
#line 3049

int
#line 3050
ncx_putn_double_int(void **xpp, size_t nelems, const int *tp)
#line 3050
{
#line 3050
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3050

#line 3050
 /* basic algorithm is:
#line 3050
  *   - ensure sane alignment of output data
#line 3050
  *   - copy (conversion happens automatically) input data
#line 3050
  *     to output
#line 3050
  *   - update tp to point at next unconverted input, and xpp to point
#line 3050
  *     at next location for converted output
#line 3050
  */
#line 3050
  long i, j, ni;
#line 3050
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3050
  double *xp;
#line 3050
  int nrange = 0;         /* number of range errors */
#line 3050
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3050
  long cxp = (long) *((char**)xpp);
#line 3050

#line 3050
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3050
  /* sjl: manually stripmine so we can limit amount of
#line 3050
   * vector work space reserved to LOOPCNT elements. Also
#line 3050
   * makes vectorisation easy */
#line 3050
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3050
    ni=Min(nelems-j,LOOPCNT);
#line 3050
    if (realign) {
#line 3050
      xp = tmp;
#line 3050
    } else {
#line 3050
      xp = (double *) *xpp;
#line 3050
    }
#line 3050
   /* copy the next block */
#line 3050
#pragma cdir loopcnt=LOOPCNT
#line 3050
#pragma cdir shortloop
#line 3050
    for (i=0; i<ni; i++) {
#line 3050
      /* the normal case: */
#line 3050
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3050
     /* test for range errors (not always needed but do it anyway) */
#line 3050
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3050
    }
#line 3050
   /* copy workspace back if necessary */
#line 3050
    if (realign) {
#line 3050
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3050
      xp = (double *) *xpp;
#line 3050
    }
#line 3050
   /* update xpp and tp */
#line 3050
    xp += ni;
#line 3050
    tp += ni;
#line 3050
    *xpp = (void*)xp;
#line 3050
  }
#line 3050
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3050

#line 3050
#else   /* not SX */
#line 3050

#line 3050
	char *xp = (char *) *xpp;
#line 3050
	int status = ENOERR;
#line 3050

#line 3050
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3050
	{
#line 3050
		int lstatus = ncx_put_double_int(xp, tp);
#line 3050
		if(lstatus != ENOERR)
#line 3050
			status = lstatus;
#line 3050
	}
#line 3050

#line 3050
	*xpp = (void *)xp;
#line 3050
	return status;
#line 3050
#endif
#line 3050
}
#line 3050

int
#line 3051
ncx_putn_double_float(void **xpp, size_t nelems, const float *tp)
#line 3051
{
#line 3051
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3051

#line 3051
 /* basic algorithm is:
#line 3051
  *   - ensure sane alignment of output data
#line 3051
  *   - copy (conversion happens automatically) input data
#line 3051
  *     to output
#line 3051
  *   - update tp to point at next unconverted input, and xpp to point
#line 3051
  *     at next location for converted output
#line 3051
  */
#line 3051
  long i, j, ni;
#line 3051
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3051
  double *xp;
#line 3051
  int nrange = 0;         /* number of range errors */
#line 3051
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3051
  long cxp = (long) *((char**)xpp);
#line 3051

#line 3051
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3051
  /* sjl: manually stripmine so we can limit amount of
#line 3051
   * vector work space reserved to LOOPCNT elements. Also
#line 3051
   * makes vectorisation easy */
#line 3051
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3051
    ni=Min(nelems-j,LOOPCNT);
#line 3051
    if (realign) {
#line 3051
      xp = tmp;
#line 3051
    } else {
#line 3051
      xp = (double *) *xpp;
#line 3051
    }
#line 3051
   /* copy the next block */
#line 3051
#pragma cdir loopcnt=LOOPCNT
#line 3051
#pragma cdir shortloop
#line 3051
    for (i=0; i<ni; i++) {
#line 3051
      /* the normal case: */
#line 3051
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3051
     /* test for range errors (not always needed but do it anyway) */
#line 3051
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3051
    }
#line 3051
   /* copy workspace back if necessary */
#line 3051
    if (realign) {
#line 3051
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3051
      xp = (double *) *xpp;
#line 3051
    }
#line 3051
   /* update xpp and tp */
#line 3051
    xp += ni;
#line 3051
    tp += ni;
#line 3051
    *xpp = (void*)xp;
#line 3051
  }
#line 3051
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3051

#line 3051
#else   /* not SX */
#line 3051

#line 3051
	char *xp = (char *) *xpp;
#line 3051
	int status = ENOERR;
#line 3051

#line 3051
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3051
	{
#line 3051
		int lstatus = ncx_put_double_float(xp, tp);
#line 3051
		if(lstatus != ENOERR)
#line 3051
			status = lstatus;
#line 3051
	}
#line 3051

#line 3051
	*xpp = (void *)xp;
#line 3051
	return status;
#line 3051
#endif
#line 3051
}
#line 3051

#line 3053
int
#line 3053
ncx_putn_double_uint(void **xpp, size_t nelems, const uint *tp)
#line 3053
{
#line 3053
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3053

#line 3053
 /* basic algorithm is:
#line 3053
  *   - ensure sane alignment of output data
#line 3053
  *   - copy (conversion happens automatically) input data
#line 3053
  *     to output
#line 3053
  *   - update tp to point at next unconverted input, and xpp to point
#line 3053
  *     at next location for converted output
#line 3053
  */
#line 3053
  long i, j, ni;
#line 3053
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3053
  double *xp;
#line 3053
  int nrange = 0;         /* number of range errors */
#line 3053
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3053
  long cxp = (long) *((char**)xpp);
#line 3053

#line 3053
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3053
  /* sjl: manually stripmine so we can limit amount of
#line 3053
   * vector work space reserved to LOOPCNT elements. Also
#line 3053
   * makes vectorisation easy */
#line 3053
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3053
    ni=Min(nelems-j,LOOPCNT);
#line 3053
    if (realign) {
#line 3053
      xp = tmp;
#line 3053
    } else {
#line 3053
      xp = (double *) *xpp;
#line 3053
    }
#line 3053
   /* copy the next block */
#line 3053
#pragma cdir loopcnt=LOOPCNT
#line 3053
#pragma cdir shortloop
#line 3053
    for (i=0; i<ni; i++) {
#line 3053
      /* the normal case: */
#line 3053
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3053
     /* test for range errors (not always needed but do it anyway) */
#line 3053
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3053
    }
#line 3053
   /* copy workspace back if necessary */
#line 3053
    if (realign) {
#line 3053
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3053
      xp = (double *) *xpp;
#line 3053
    }
#line 3053
   /* update xpp and tp */
#line 3053
    xp += ni;
#line 3053
    tp += ni;
#line 3053
    *xpp = (void*)xp;
#line 3053
  }
#line 3053
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3053

#line 3053
#else   /* not SX */
#line 3053

#line 3053
	char *xp = (char *) *xpp;
#line 3053
	int status = ENOERR;
#line 3053

#line 3053
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3053
	{
#line 3053
		int lstatus = ncx_put_double_uint(xp, tp);
#line 3053
		if(lstatus != ENOERR)
#line 3053
			status = lstatus;
#line 3053
	}
#line 3053

#line 3053
	*xpp = (void *)xp;
#line 3053
	return status;
#line 3053
#endif
#line 3053
}
#line 3053

int
#line 3054
ncx_putn_double_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3054
{
#line 3054
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3054

#line 3054
 /* basic algorithm is:
#line 3054
  *   - ensure sane alignment of output data
#line 3054
  *   - copy (conversion happens automatically) input data
#line 3054
  *     to output
#line 3054
  *   - update tp to point at next unconverted input, and xpp to point
#line 3054
  *     at next location for converted output
#line 3054
  */
#line 3054
  long i, j, ni;
#line 3054
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3054
  double *xp;
#line 3054
  int nrange = 0;         /* number of range errors */
#line 3054
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3054
  long cxp = (long) *((char**)xpp);
#line 3054

#line 3054
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3054
  /* sjl: manually stripmine so we can limit amount of
#line 3054
   * vector work space reserved to LOOPCNT elements. Also
#line 3054
   * makes vectorisation easy */
#line 3054
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3054
    ni=Min(nelems-j,LOOPCNT);
#line 3054
    if (realign) {
#line 3054
      xp = tmp;
#line 3054
    } else {
#line 3054
      xp = (double *) *xpp;
#line 3054
    }
#line 3054
   /* copy the next block */
#line 3054
#pragma cdir loopcnt=LOOPCNT
#line 3054
#pragma cdir shortloop
#line 3054
    for (i=0; i<ni; i++) {
#line 3054
      /* the normal case: */
#line 3054
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3054
     /* test for range errors (not always needed but do it anyway) */
#line 3054
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3054
    }
#line 3054
   /* copy workspace back if necessary */
#line 3054
    if (realign) {
#line 3054
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3054
      xp = (double *) *xpp;
#line 3054
    }
#line 3054
   /* update xpp and tp */
#line 3054
    xp += ni;
#line 3054
    tp += ni;
#line 3054
    *xpp = (void*)xp;
#line 3054
  }
#line 3054
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3054

#line 3054
#else   /* not SX */
#line 3054

#line 3054
	char *xp = (char *) *xpp;
#line 3054
	int status = ENOERR;
#line 3054

#line 3054
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3054
	{
#line 3054
		int lstatus = ncx_put_double_longlong(xp, tp);
#line 3054
		if(lstatus != ENOERR)
#line 3054
			status = lstatus;
#line 3054
	}
#line 3054

#line 3054
	*xpp = (void *)xp;
#line 3054
	return status;
#line 3054
#endif
#line 3054
}
#line 3054

int
#line 3055
ncx_putn_double_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3055
{
#line 3055
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3055

#line 3055
 /* basic algorithm is:
#line 3055
  *   - ensure sane alignment of output data
#line 3055
  *   - copy (conversion happens automatically) input data
#line 3055
  *     to output
#line 3055
  *   - update tp to point at next unconverted input, and xpp to point
#line 3055
  *     at next location for converted output
#line 3055
  */
#line 3055
  long i, j, ni;
#line 3055
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3055
  double *xp;
#line 3055
  int nrange = 0;         /* number of range errors */
#line 3055
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3055
  long cxp = (long) *((char**)xpp);
#line 3055

#line 3055
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3055
  /* sjl: manually stripmine so we can limit amount of
#line 3055
   * vector work space reserved to LOOPCNT elements. Also
#line 3055
   * makes vectorisation easy */
#line 3055
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3055
    ni=Min(nelems-j,LOOPCNT);
#line 3055
    if (realign) {
#line 3055
      xp = tmp;
#line 3055
    } else {
#line 3055
      xp = (double *) *xpp;
#line 3055
    }
#line 3055
   /* copy the next block */
#line 3055
#pragma cdir loopcnt=LOOPCNT
#line 3055
#pragma cdir shortloop
#line 3055
    for (i=0; i<ni; i++) {
#line 3055
      /* the normal case: */
#line 3055
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3055
     /* test for range errors (not always needed but do it anyway) */
#line 3055
      nrange += tp[i] < X_DOUBLE_MIN || tp[i] > X_DOUBLE_MAX;
#line 3055
    }
#line 3055
   /* copy workspace back if necessary */
#line 3055
    if (realign) {
#line 3055
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3055
      xp = (double *) *xpp;
#line 3055
    }
#line 3055
   /* update xpp and tp */
#line 3055
    xp += ni;
#line 3055
    tp += ni;
#line 3055
    *xpp = (void*)xp;
#line 3055
  }
#line 3055
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3055

#line 3055
#else   /* not SX */
#line 3055

#line 3055
	char *xp = (char *) *xpp;
#line 3055
	int status = ENOERR;
#line 3055

#line 3055
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3055
	{
#line 3055
		int lstatus = ncx_put_double_ulonglong(xp, tp);
#line 3055
		if(lstatus != ENOERR)
#line 3055
			status = lstatus;
#line 3055
	}
#line 3055

#line 3055
	*xpp = (void *)xp;
#line 3055
	return status;
#line 3055
#endif
#line 3055
}
#line 3055

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_DOUBLE);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_putn_double_double(void **xpp, size_t ndoubles, const double *ip)
{
	const double *const end = ip + ndoubles;

	while(ip < end)
	{
	const struct vax_double *const vdp =
#line 3077
			(const struct vax_double *)ip;
#line 3077
	struct ieee_double *const idp =
#line 3077
			 (struct ieee_double *) (*xpp);
#line 3077

#line 3077
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 3077
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 3077
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 3077
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 3077
		(vdp->exp == dbl_limits[0].d.exp))
#line 3077
	{
#line 3077
		*idp = dbl_limits[0].ieee;
#line 3077
		goto shipit;
#line 3077
	}
#line 3077
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 3077
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 3077
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 3077
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 3077
		(vdp->exp == dbl_limits[1].d.exp))
#line 3077
	{
#line 3077
		*idp = dbl_limits[1].ieee;
#line 3077
		goto shipit;
#line 3077
	}
#line 3077

#line 3077
	{
#line 3077
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 3077

#line 3077
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 3077
			(vdp->mantissa3 << 13) |
#line 3077
			((vdp->mantissa4 >> 3) & MASK(13));
#line 3077

#line 3077
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 3077
				 | (vdp->mantissa2 >> 3);
#line 3077

#line 3077
		if((vdp->mantissa4 & 7) > 4)
#line 3077
		{
#line 3077
			/* round up */
#line 3077
			mant_lo++;
#line 3077
			if(mant_lo == 0)
#line 3077
			{
#line 3077
				mant_hi++;
#line 3077
				if(mant_hi > 0xffffff)
#line 3077
				{
#line 3077
					mant_hi = 0;
#line 3077
					exp++;
#line 3077
				}
#line 3077
			}
#line 3077
		}
#line 3077

#line 3077
		idp->mant_lo = SWAP4(mant_lo);
#line 3077
		idp->mant_6 = mant_hi >> 16;
#line 3077
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 3077
		idp->mant_4 = mant_hi;
#line 3077
		idp->exp_hi = exp >> 4;
#line 3077
		idp->exp_lo = exp;
#line 3077
	}
#line 3077

#line 3077
	shipit:
#line 3077
		idp->sign = vdp->sign;
#line 3077

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		int lstatus = ncx_put_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}

#endif


/*
 * Other aggregate conversion functions.
 */

/* text */

int
ncx_getn_text(const void **xpp, size_t nelems, char *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3114
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3114
	return ENOERR;
#line 3114

}

int
ncx_pad_getn_text(const void **xpp, size_t nelems, char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3120

#line 3120
	if(rndup)
#line 3120
		rndup = X_ALIGN - rndup;
#line 3120

#line 3120
	(void) memcpy(tp, *xpp, nelems);
#line 3120
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3120

#line 3120
	return ENOERR;
#line 3120

}

int
ncx_putn_text(void **xpp, size_t nelems, const char *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3126
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3126

#line 3126
	return ENOERR;
#line 3126

}

int
ncx_pad_putn_text(void **xpp, size_t nelems, const char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3132

#line 3132
	if(rndup)
#line 3132
		rndup = X_ALIGN - rndup;
#line 3132

#line 3132
	(void) memcpy(*xpp, tp, nelems);
#line 3132
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3132

#line 3132
	if(rndup)
#line 3132
	{
#line 3132
		(void) memcpy(*xpp, nada, rndup);
#line 3132
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3132
	}
#line 3132

#line 3132
	return ENOERR;
#line 3132

}


/* opaque */

int
ncx_getn_void(const void **xpp, size_t nelems, void *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3141
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3141
	return ENOERR;
#line 3141

}

int
ncx_pad_getn_void(const void **xpp, size_t nelems, void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3147

#line 3147
	if(rndup)
#line 3147
		rndup = X_ALIGN - rndup;
#line 3147

#line 3147
	(void) memcpy(tp, *xpp, nelems);
#line 3147
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3147

#line 3147
	return ENOERR;
#line 3147

}

int
ncx_putn_void(void **xpp, size_t nelems, const void *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3153
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3153

#line 3153
	return ENOERR;
#line 3153

}

int
ncx_pad_putn_void(void **xpp, size_t nelems, const void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3159

#line 3159
	if(rndup)
#line 3159
		rndup = X_ALIGN - rndup;
#line 3159

#line 3159
	(void) memcpy(*xpp, tp, nelems);
#line 3159
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3159

#line 3159
	if(rndup)
#line 3159
	{
#line 3159
		(void) memcpy(*xpp, nada, rndup);
#line 3159
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3159
	}
#line 3159

#line 3159
	return ENOERR;
#line 3159

}
