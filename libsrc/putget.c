#line 9 "putget.m4"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 11
/*
 *	Copyright 2018, University Corporation for Atmospheric Research
 *      See netcdf/COPYRIGHT file for copying and redistribution conditions.
 */
/* $Id: putget.m4 2783 2014-10-26 05:19:35Z wkliao $ */

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "netcdf.h"
#include "nc3dispatch.h"
#include "nc3internal.h"
#include "ncx.h"
#include "fbits.h"
#include "onstack.h"

#undef MIN  /* system may define MIN somewhere and complain */
#define MIN(mm,nn) (((mm) < (nn)) ? (mm) : (nn))

static int
readNCv(const NC3_INFO* ncp, const NC_var* varp, const size_t* start,
        const size_t nelems, void* value, const nc_type memtype);
static int
writeNCv(NC3_INFO* ncp, const NC_var* varp, const size_t* start,
         const size_t nelems, const void* value, const nc_type memtype);


/* #define ODEBUG 1 */

#if ODEBUG
#include <stdio.h>
/*
 * Print the values of an array of size_t
 */
void
arrayp(const char *label, size_t count, const size_t *array)
{
	(void) fprintf(stderr, "%s", label);
	(void) fputc('\t',stderr);
	for(; count > 0; count--, array++)
		(void) fprintf(stderr," %lu", (unsigned long)*array);
	(void) fputc('\n',stderr);
}
#endif /* ODEBUG */


/* Begin fill */
/*
 * This is tunable parameter.
 * It essentially controls the tradeoff between the number of times
 * memcpy() gets called to copy the external data to fill
 * a large buffer vs the number of times its called to
 * prepare the external data.
 */
#if	_SX
/* NEC SX specific optimization */
#define	NFILL	2048
#else
#define	NFILL	16
#endif


#line 103

/*
 * Next 6 type specific functions
 * Fill a some memory with the default special value.
 * Formerly
NC_arrayfill()
 */
static int
#line 110
NC_fill_schar(
#line 110
	void **xpp,
#line 110
	size_t nelems)	/* how many */
#line 110
{
#line 110
	schar fillp[NFILL * sizeof(double)/X_SIZEOF_CHAR];
#line 110

#line 110
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 110

#line 110
	{
#line 110
		schar *vp = fillp;	/* lower bound of area to be filled */
#line 110
		const schar *const end = vp + nelems;
#line 110
		while(vp < end)
#line 110
		{
#line 110
			*vp++ = NC_FILL_BYTE;
#line 110
		}
#line 110
	}
#line 110
	return ncx_putn_schar_schar(xpp, nelems, fillp ,NULL);
#line 110
}
#line 110

static int
#line 111
NC_fill_char(
#line 111
	void **xpp,
#line 111
	size_t nelems)	/* how many */
#line 111
{
#line 111
	char fillp[NFILL * sizeof(double)/X_SIZEOF_CHAR];
#line 111

#line 111
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 111

#line 111
	{
#line 111
		char *vp = fillp;	/* lower bound of area to be filled */
#line 111
		const char *const end = vp + nelems;
#line 111
		while(vp < end)
#line 111
		{
#line 111
			*vp++ = NC_FILL_CHAR;
#line 111
		}
#line 111
	}
#line 111
	return ncx_putn_char_char(xpp, nelems, fillp );
#line 111
}
#line 111

static int
#line 112
NC_fill_short(
#line 112
	void **xpp,
#line 112
	size_t nelems)	/* how many */
#line 112
{
#line 112
	short fillp[NFILL * sizeof(double)/X_SIZEOF_SHORT];
#line 112

#line 112
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 112

#line 112
	{
#line 112
		short *vp = fillp;	/* lower bound of area to be filled */
#line 112
		const short *const end = vp + nelems;
#line 112
		while(vp < end)
#line 112
		{
#line 112
			*vp++ = NC_FILL_SHORT;
#line 112
		}
#line 112
	}
#line 112
	return ncx_putn_short_short(xpp, nelems, fillp ,NULL);
#line 112
}
#line 112


#if (SIZEOF_INT >= X_SIZEOF_INT)
static int
#line 115
NC_fill_int(
#line 115
	void **xpp,
#line 115
	size_t nelems)	/* how many */
#line 115
{
#line 115
	int fillp[NFILL * sizeof(double)/X_SIZEOF_INT];
#line 115

#line 115
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 115

#line 115
	{
#line 115
		int *vp = fillp;	/* lower bound of area to be filled */
#line 115
		const int *const end = vp + nelems;
#line 115
		while(vp < end)
#line 115
		{
#line 115
			*vp++ = NC_FILL_INT;
#line 115
		}
#line 115
	}
#line 115
	return ncx_putn_int_int(xpp, nelems, fillp ,NULL);
#line 115
}
#line 115

#elif SIZEOF_LONG == X_SIZEOF_INT
static int
#line 117
NC_fill_int(
#line 117
	void **xpp,
#line 117
	size_t nelems)	/* how many */
#line 117
{
#line 117
	long fillp[NFILL * sizeof(double)/X_SIZEOF_INT];
#line 117

#line 117
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 117

#line 117
	{
#line 117
		long *vp = fillp;	/* lower bound of area to be filled */
#line 117
		const long *const end = vp + nelems;
#line 117
		while(vp < end)
#line 117
		{
#line 117
			*vp++ = NC_FILL_INT;
#line 117
		}
#line 117
	}
#line 117
	return ncx_putn_int_long(xpp, nelems, fillp ,NULL);
#line 117
}
#line 117

#else
#error "NC_fill_int implementation"
#endif

static int
#line 122
NC_fill_float(
#line 122
	void **xpp,
#line 122
	size_t nelems)	/* how many */
#line 122
{
#line 122
	float fillp[NFILL * sizeof(double)/X_SIZEOF_FLOAT];
#line 122

#line 122
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 122

#line 122
	{
#line 122
		float *vp = fillp;	/* lower bound of area to be filled */
#line 122
		const float *const end = vp + nelems;
#line 122
		while(vp < end)
#line 122
		{
#line 122
			*vp++ = NC_FILL_FLOAT;
#line 122
		}
#line 122
	}
#line 122
	return ncx_putn_float_float(xpp, nelems, fillp ,NULL);
#line 122
}
#line 122

static int
#line 123
NC_fill_double(
#line 123
	void **xpp,
#line 123
	size_t nelems)	/* how many */
#line 123
{
#line 123
	double fillp[NFILL * sizeof(double)/X_SIZEOF_DOUBLE];
#line 123

#line 123
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 123

#line 123
	{
#line 123
		double *vp = fillp;	/* lower bound of area to be filled */
#line 123
		const double *const end = vp + nelems;
#line 123
		while(vp < end)
#line 123
		{
#line 123
			*vp++ = NC_FILL_DOUBLE;
#line 123
		}
#line 123
	}
#line 123
	return ncx_putn_double_double(xpp, nelems, fillp ,NULL);
#line 123
}
#line 123


static int
#line 125
NC_fill_uchar(
#line 125
	void **xpp,
#line 125
	size_t nelems)	/* how many */
#line 125
{
#line 125
	uchar fillp[NFILL * sizeof(double)/X_SIZEOF_UBYTE];
#line 125

#line 125
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 125

#line 125
	{
#line 125
		uchar *vp = fillp;	/* lower bound of area to be filled */
#line 125
		const uchar *const end = vp + nelems;
#line 125
		while(vp < end)
#line 125
		{
#line 125
			*vp++ = NC_FILL_UBYTE;
#line 125
		}
#line 125
	}
#line 125
	return ncx_putn_uchar_uchar(xpp, nelems, fillp ,NULL);
#line 125
}
#line 125

static int
#line 126
NC_fill_ushort(
#line 126
	void **xpp,
#line 126
	size_t nelems)	/* how many */
#line 126
{
#line 126
	ushort fillp[NFILL * sizeof(double)/X_SIZEOF_USHORT];
#line 126

#line 126
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 126

#line 126
	{
#line 126
		ushort *vp = fillp;	/* lower bound of area to be filled */
#line 126
		const ushort *const end = vp + nelems;
#line 126
		while(vp < end)
#line 126
		{
#line 126
			*vp++ = NC_FILL_USHORT;
#line 126
		}
#line 126
	}
#line 126
	return ncx_putn_ushort_ushort(xpp, nelems, fillp ,NULL);
#line 126
}
#line 126

static int
#line 127
NC_fill_uint(
#line 127
	void **xpp,
#line 127
	size_t nelems)	/* how many */
#line 127
{
#line 127
	uint fillp[NFILL * sizeof(double)/X_SIZEOF_UINT];
#line 127

#line 127
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 127

#line 127
	{
#line 127
		uint *vp = fillp;	/* lower bound of area to be filled */
#line 127
		const uint *const end = vp + nelems;
#line 127
		while(vp < end)
#line 127
		{
#line 127
			*vp++ = NC_FILL_UINT;
#line 127
		}
#line 127
	}
#line 127
	return ncx_putn_uint_uint(xpp, nelems, fillp ,NULL);
#line 127
}
#line 127

static int
#line 128
NC_fill_longlong(
#line 128
	void **xpp,
#line 128
	size_t nelems)	/* how many */
#line 128
{
#line 128
	longlong fillp[NFILL * sizeof(double)/X_SIZEOF_LONGLONG];
#line 128

#line 128
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 128

#line 128
	{
#line 128
		longlong *vp = fillp;	/* lower bound of area to be filled */
#line 128
		const longlong *const end = vp + nelems;
#line 128
		while(vp < end)
#line 128
		{
#line 128
			*vp++ = NC_FILL_INT64;
#line 128
		}
#line 128
	}
#line 128
	return ncx_putn_longlong_longlong(xpp, nelems, fillp ,NULL);
#line 128
}
#line 128

static int
#line 129
NC_fill_ulonglong(
#line 129
	void **xpp,
#line 129
	size_t nelems)	/* how many */
#line 129
{
#line 129
	ulonglong fillp[NFILL * sizeof(double)/X_SIZEOF_ULONGLONG];
#line 129

#line 129
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 129

#line 129
	{
#line 129
		ulonglong *vp = fillp;	/* lower bound of area to be filled */
#line 129
		const ulonglong *const end = vp + nelems;
#line 129
		while(vp < end)
#line 129
		{
#line 129
			*vp++ = NC_FILL_UINT64;
#line 129
		}
#line 129
	}
#line 129
	return ncx_putn_ulonglong_ulonglong(xpp, nelems, fillp ,NULL);
#line 129
}
#line 129




/*
 * Fill the external space for variable 'varp' values at 'recno' with
 * the appropriate value. If 'varp' is not a record variable, fill the
 * whole thing.  For the special case when 'varp' is the only record
 * variable and it is of type byte, char, or short, varsize should be
 * ncp->recsize, otherwise it should be varp->len.
 * Formerly
xdr_NC_fill()
 */
int
fill_NC_var(NC3_INFO* ncp, const NC_var *varp, long long varsize, size_t recno)
{
	char xfillp[NFILL * X_SIZEOF_DOUBLE];
	const size_t step = varp->xsz;
	const size_t nelems = sizeof(xfillp)/step;
	const size_t xsz = varp->xsz * nelems;
	NC_attr **attrpp = NULL;
	off_t offset;
	long long remaining = varsize;

	void *xp;
	int status = NC_NOERR;

	/*
	 * Set up fill value
	 */
	attrpp = NC_findattr(&varp->attrs, _FillValue);
	if( attrpp != NULL )
	{
		/* User defined fill value */
		if( (*attrpp)->type != varp->type || (*attrpp)->nelems != 1 )
		{
			return NC_EBADTYPE;
		}
		else
		{
			/* Use the user defined value */
			char *cp = xfillp;
			const char *const end = &xfillp[sizeof(xfillp)];

			assert(step <= (*attrpp)->xsz);

			for( /*NADA*/; cp < end; cp += step)
			{
				(void) memcpy(cp, (*attrpp)->xvalue, step);
			}
		}
	}
	else
	{
		/* use the default */

		assert(xsz % X_ALIGN == 0);
		assert(xsz <= sizeof(xfillp));

		xp = xfillp;

		switch(varp->type){
		case NC_BYTE :
			status = NC_fill_schar(&xp, nelems);
			break;
		case NC_CHAR :
			status = NC_fill_char(&xp, nelems);
			break;
		case NC_SHORT :
			status = NC_fill_short(&xp, nelems);
			break;
		case NC_INT :
			status = NC_fill_int(&xp, nelems);
			break;
		case NC_FLOAT :
			status = NC_fill_float(&xp, nelems);
			break;
		case NC_DOUBLE :
			status = NC_fill_double(&xp, nelems);
			break;
                case NC_UBYTE :
                        status = NC_fill_uchar(&xp, nelems);
                        break;
                case NC_USHORT :
                        status = NC_fill_ushort(&xp, nelems);
                        break;
                case NC_UINT :
                        status = NC_fill_uint(&xp, nelems);
                        break;
                case NC_INT64 :
                        status = NC_fill_longlong(&xp, nelems);
                        break;
                case NC_UINT64 :
                        status = NC_fill_ulonglong(&xp, nelems);
                        break;
		default :
			assert("fill_NC_var invalid type" == 0);
			status = NC_EBADTYPE;
			break;
		}
		if(status != NC_NOERR)
			return status;

		assert(xp == xfillp + xsz);
	}

	/*
	 * copyout:
	 * xfillp now contains 'nelems' elements of the fill value
	 * in external representation.
	 */

	/*
	 * Copy it out.
	 */

	offset = varp->begin;
	if(IS_RECVAR(varp))
	{
		offset += (off_t)ncp->recsize * recno;
	}

	assert(remaining > 0);
	for(;;)
	{
		const size_t chunksz = MIN(remaining, ncp->chunk);
		size_t ii;

		status = ncio_get(ncp->nciop, offset, chunksz,
				 RGN_WRITE, &xp);
		if(status != NC_NOERR)
		{
			return status;
		}

		/*
		 * fill the chunksz buffer in units  of xsz
		 */
		for(ii = 0; ii < chunksz/xsz; ii++)
		{
			(void) memcpy(xp, xfillp, xsz);
			xp = (char *)xp + xsz;
		}
		/*
		 * Deal with any remainder
		 */
		{
			const size_t rem = chunksz % xsz;
			if(rem != 0)
			{
				(void) memcpy(xp, xfillp, rem);
				/* xp = (char *)xp + xsz; */
			}

		}

		status = ncio_rel(ncp->nciop, offset, RGN_MODIFIED);

		if(status != NC_NOERR)
		{
			break;
		}

		remaining -= chunksz;
		if(remaining == 0)
			break;	/* normal loop exit */
		offset += chunksz;

	}

	return status;
}
/* End fill */


/*
 * Add a record containing the fill values.
 */
static int
NCfillrecord(NC3_INFO* ncp, const NC_var *const *varpp, size_t recno)
{
	size_t ii = 0;
	for(; ii < ncp->vars.nelems; ii++, varpp++)
	{
		if( !IS_RECVAR(*varpp) )
		{
			continue;	/* skip non-record variables */
		}
		{
		const int status = fill_NC_var(ncp, *varpp, (*varpp)->len, recno);
		if(status != NC_NOERR)
			return status;
		}
	}
	return NC_NOERR;
}


/*
 * Add a record containing the fill values in the special case when
 * there is exactly one record variable, where we don't require each
 * record to be four-byte aligned (no record padding).
 */
static int
NCfillspecialrecord(NC3_INFO* ncp, const NC_var *varp, size_t recno)
{
    int status;
    assert(IS_RECVAR(varp));
    status = fill_NC_var(ncp, varp, ncp->recsize, recno);
    if(status != NC_NOERR)
	return status;
    return NC_NOERR;
}


/*
 * It is advantageous to
 * #define TOUCH_LAST
 * when using memory mapped io.
 */
#if TOUCH_LAST
/*
 * Grow the file to a size which can contain recno
 */
static int
NCtouchlast(NC3_INFO* ncp, const NC_var *const *varpp, size_t recno)
{
	int status = NC_NOERR;
	const NC_var *varp = NULL;

	{
	size_t ii = 0;
	for(; ii < ncp->vars.nelems; ii++, varpp++)
	{
		if( !IS_RECVAR(*varpp) )
		{
			continue;	/* skip non-record variables */
		}
		varp = *varpp;
	}
	}
	assert(varp != NULL);
	assert( IS_RECVAR(varp) );
	{
		const off_t offset = varp->begin
				+ (off_t)(recno-1) * (off_t)ncp->recsize
				+ (off_t)(varp->len - varp->xsz);
		void *xp;


		status = ncio_get(ncp->nciop, offset, varp->xsz,
				 RGN_WRITE, &xp);
		if(status != NC_NOERR)
			return status;
		(void)memset(xp, 0, varp->xsz);
		status = ncio_rel(ncp->nciop, offset, RGN_MODIFIED);
	}
	return status;
}
#endif /* TOUCH_LAST */


/*
 * Ensure that the netcdf file has 'numrecs' records,
 * add records and fill as necessary.
 */
static int
NCvnrecs(NC3_INFO* ncp, size_t numrecs)
{
	int status = NC_NOERR;

	if(numrecs > NC_get_numrecs(ncp))
	{


#if TOUCH_LAST
		status = NCtouchlast(ncp,
			(const NC_var *const*)ncp->vars.value,
			numrecs);
		if(status != NC_NOERR)
			goto common_return;
#endif /* TOUCH_LAST */

		set_NC_ndirty(ncp);

		if(!NC_dofill(ncp))
		{
			/* Simply set the new numrecs value */
			NC_set_numrecs(ncp, numrecs);
		}
		else
		{
		    /* Treat two cases differently:
		        - exactly one record variable (no padding)
                        - multiple record variables (each record padded
                          to 4-byte alignment)
		    */
		    NC_var **vpp = (NC_var **)ncp->vars.value;
		    NC_var *const *const end = &vpp[ncp->vars.nelems];
		    NC_var *recvarp = NULL;	/* last record var */
		    int numrecvars = 0;
		    size_t cur_nrecs;

		    /* determine how many record variables */
		    for( /*NADA*/; vpp < end; vpp++) {
			if(IS_RECVAR(*vpp)) {
			    recvarp = *vpp;
			    numrecvars++;
			}
		    }

		    if (numrecvars != 1) { /* usual case */
			/* Fill each record out to numrecs */
			while((cur_nrecs = NC_get_numrecs(ncp)) < numrecs)
			    {
				status = NCfillrecord(ncp,
					(const NC_var *const*)ncp->vars.value,
					cur_nrecs);
				if(status != NC_NOERR)
				{
					break;
				}
				NC_increase_numrecs(ncp, cur_nrecs +1);
			}
			if(status != NC_NOERR)
				goto common_return;
		    } else {	/* special case */
			/* Fill each record out to numrecs */
			while((cur_nrecs = NC_get_numrecs(ncp)) < numrecs)
			    {
				status = NCfillspecialrecord(ncp,
					recvarp,
					cur_nrecs);
				if(status != NC_NOERR)
				{
					break;
				}
				NC_increase_numrecs(ncp, cur_nrecs +1);
			}
			if(status != NC_NOERR)
				goto common_return;

		    }
		}

		if(NC_doNsync(ncp))
		{
			status = write_numrecs(ncp);
		}

	}
common_return:
	return status;
}


/*
 * Check whether 'coord' values are valid for the variable.
 */
static int
NCcoordck(NC3_INFO* ncp, const NC_var *varp, const size_t *coord)
{
	const size_t *ip;
	size_t *up;

	if(varp->ndims == 0)
		return NC_NOERR;	/* 'scalar' variable */

	if(IS_RECVAR(varp))
	{
		if(*coord > X_UINT_MAX) /* rkr: bug fix from previous X_INT_MAX */
			return NC_EINVALCOORDS; /* sanity check */
#ifdef RELAX_COORD_BOUND
		if(NC_readonly(ncp) && *coord > NC_get_numrecs(ncp))
#else
		if(NC_readonly(ncp) && *coord >= NC_get_numrecs(ncp))
#endif
		{
			if(!NC_doNsync(ncp))
				return NC_EINVALCOORDS;
			/* else */
			{
				/* Update from disk and check again */
				const int status = read_numrecs(ncp);
				if(status != NC_NOERR)
					return status;
#ifdef RELAX_COORD_BOUND
				if(*coord > NC_get_numrecs(ncp))
#else
				if(*coord >= NC_get_numrecs(ncp))
#endif
					return NC_EINVALCOORDS;
			}
		}
		ip = coord + 1;
		up = varp->shape + 1;
	}
	else
	{
		ip = coord;
		up = varp->shape;
	}

#ifdef CDEBUG
fprintf(stderr,"	NCcoordck: coord %ld, count %d, ip %ld\n",
		coord, varp->ndims, ip );
#endif /* CDEBUG */

	for(; ip < coord + varp->ndims; ip++, up++)
	{

#ifdef CDEBUG
fprintf(stderr,"	NCcoordck: ip %p, *ip %ld, up %p, *up %lu\n",
			ip, *ip, up, *up );
#endif /* CDEBUG */

		/* cast needed for braindead systems with signed size_t */
#ifdef RELAX_COORD_BOUND
		if((unsigned long) *ip > (unsigned long) *up )
#else
		if((unsigned long) *ip >= (unsigned long) *up )
#endif
			return NC_EINVALCOORDS;
	}

	return NC_NOERR;
}


/*
 * Check whether 'edges' are valid for the variable and 'start'
 */
/*ARGSUSED*/
static int
NCedgeck(const NC3_INFO* ncp, const NC_var *varp,
	 const size_t *start, const size_t *edges)
{
	const size_t *const end = start + varp->ndims;
	const size_t *shp = varp->shape;

	if(varp->ndims == 0)
		return NC_NOERR;	/* 'scalar' variable */

	if(IS_RECVAR(varp))
	{
#ifdef RELAX_COORD_BOUND
		if (NC_readonly(ncp) &&
                    (start[0] == NC_get_numrecs(ncp) && edges[0] > 0))
			return(NC_EINVALCOORDS);
#endif
		start++;
		edges++;
		shp++;
	}

	for(; start < end; start++, edges++, shp++)
	{
#ifdef RELAX_COORD_BOUND
		if ((unsigned long) *start == *shp && *edges > 0)
			return(NC_EINVALCOORDS);
#endif
		/* cast needed for braindead systems with signed size_t */
		if((unsigned long) *edges > *shp ||
			(unsigned long) *start + (unsigned long) *edges > *shp)
		{
			return(NC_EEDGE);
		}
	}
	return NC_NOERR;
}


/*
 * Translate the (variable, coord) pair into a seek index
 */
static off_t
NC_varoffset(const NC3_INFO* ncp, const NC_var *varp, const size_t *coord)
{
	if(varp->ndims == 0) /* 'scalar' variable */
		return varp->begin;

	if(varp->ndims == 1)
	{
		if(IS_RECVAR(varp))
			return varp->begin +
				 (off_t)(*coord) * (off_t)ncp->recsize;
		/* else */
		return varp->begin + (off_t)(*coord) * (off_t)varp->xsz;
	}
	/* else */
	{
		off_t lcoord = (off_t)coord[varp->ndims -1];

		off_t *up = varp->dsizes +1;
		const size_t *ip = coord;
		const off_t *const end = varp->dsizes + varp->ndims;

		if(IS_RECVAR(varp))
			up++, ip++;

		for(; up < end; up++, ip++)
			lcoord += (off_t)(*up) * (off_t)(*ip);

		lcoord *= varp->xsz;

		if(IS_RECVAR(varp))
			lcoord += (off_t)(*coord) * ncp->recsize;

		lcoord += varp->begin;
		return lcoord;
	}
}


#line 707

static int
#line 708
putNCvx_char_char(NC3_INFO* ncp, const NC_var *varp,
#line 708
		 const size_t *start, size_t nelems, const char *value)
#line 708
{
#line 708
	off_t offset = NC_varoffset(ncp, varp, start);
#line 708
	size_t remaining = varp->xsz * nelems;
#line 708
	int status = NC_NOERR;
#line 708
	void *xp;
#line 708
        void *fillp=NULL;
#line 708

#line 708
	if(nelems == 0)
#line 708
		return NC_NOERR;
#line 708

#line 708
	assert(value != NULL);
#line 708

#line 708
#ifdef ERANGE_FILL
#line 708
        fillp = malloc(varp->xsz);
#line 708
        status = NC3_inq_var_fill(varp, fillp);
#line 708
#endif
#line 708

#line 708
	for(;;)
#line 708
	{
#line 708
		size_t extent = MIN(remaining, ncp->chunk);
#line 708
		size_t nput = ncx_howmany(varp->type, extent);
#line 708

#line 708
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 708
				 RGN_WRITE, &xp);
#line 708
		if(lstatus != NC_NOERR)
#line 708
			return lstatus;
#line 708

#line 708
		lstatus = ncx_putn_char_char(&xp, nput, value );
#line 708
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 708
		{
#line 708
			/* not fatal to the loop */
#line 708
			status = lstatus;
#line 708
		}
#line 708

#line 708
		(void) ncio_rel(ncp->nciop, offset,
#line 708
				 RGN_MODIFIED);
#line 708

#line 708
		remaining -= extent;
#line 708
		if(remaining == 0)
#line 708
			break; /* normal loop exit */
#line 708
		offset += (off_t)extent;
#line 708
		value += nput;
#line 708

#line 708
	}
#line 708
#ifdef ERANGE_FILL
#line 708
        free(fillp);
#line 708
#endif
#line 708

#line 708
	return status;
#line 708
}
#line 708


static int
#line 710
putNCvx_schar_schar(NC3_INFO* ncp, const NC_var *varp,
#line 710
		 const size_t *start, size_t nelems, const schar *value)
#line 710
{
#line 710
	off_t offset = NC_varoffset(ncp, varp, start);
#line 710
	size_t remaining = varp->xsz * nelems;
#line 710
	int status = NC_NOERR;
#line 710
	void *xp;
#line 710
        void *fillp=NULL;
#line 710

#line 710
	if(nelems == 0)
#line 710
		return NC_NOERR;
#line 710

#line 710
	assert(value != NULL);
#line 710

#line 710
#ifdef ERANGE_FILL
#line 710
        fillp = malloc(varp->xsz);
#line 710
        status = NC3_inq_var_fill(varp, fillp);
#line 710
#endif
#line 710

#line 710
	for(;;)
#line 710
	{
#line 710
		size_t extent = MIN(remaining, ncp->chunk);
#line 710
		size_t nput = ncx_howmany(varp->type, extent);
#line 710

#line 710
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 710
				 RGN_WRITE, &xp);
#line 710
		if(lstatus != NC_NOERR)
#line 710
			return lstatus;
#line 710

#line 710
		lstatus = ncx_putn_schar_schar(&xp, nput, value ,fillp);
#line 710
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 710
		{
#line 710
			/* not fatal to the loop */
#line 710
			status = lstatus;
#line 710
		}
#line 710

#line 710
		(void) ncio_rel(ncp->nciop, offset,
#line 710
				 RGN_MODIFIED);
#line 710

#line 710
		remaining -= extent;
#line 710
		if(remaining == 0)
#line 710
			break; /* normal loop exit */
#line 710
		offset += (off_t)extent;
#line 710
		value += nput;
#line 710

#line 710
	}
#line 710
#ifdef ERANGE_FILL
#line 710
        free(fillp);
#line 710
#endif
#line 710

#line 710
	return status;
#line 710
}
#line 710

static int
#line 711
putNCvx_schar_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 711
		 const size_t *start, size_t nelems, const uchar *value)
#line 711
{
#line 711
	off_t offset = NC_varoffset(ncp, varp, start);
#line 711
	size_t remaining = varp->xsz * nelems;
#line 711
	int status = NC_NOERR;
#line 711
	void *xp;
#line 711
        void *fillp=NULL;
#line 711

#line 711
	if(nelems == 0)
#line 711
		return NC_NOERR;
#line 711

#line 711
	assert(value != NULL);
#line 711

#line 711
#ifdef ERANGE_FILL
#line 711
        fillp = malloc(varp->xsz);
#line 711
        status = NC3_inq_var_fill(varp, fillp);
#line 711
#endif
#line 711

#line 711
	for(;;)
#line 711
	{
#line 711
		size_t extent = MIN(remaining, ncp->chunk);
#line 711
		size_t nput = ncx_howmany(varp->type, extent);
#line 711

#line 711
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 711
				 RGN_WRITE, &xp);
#line 711
		if(lstatus != NC_NOERR)
#line 711
			return lstatus;
#line 711

#line 711
		lstatus = ncx_putn_schar_uchar(&xp, nput, value ,fillp);
#line 711
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 711
		{
#line 711
			/* not fatal to the loop */
#line 711
			status = lstatus;
#line 711
		}
#line 711

#line 711
		(void) ncio_rel(ncp->nciop, offset,
#line 711
				 RGN_MODIFIED);
#line 711

#line 711
		remaining -= extent;
#line 711
		if(remaining == 0)
#line 711
			break; /* normal loop exit */
#line 711
		offset += (off_t)extent;
#line 711
		value += nput;
#line 711

#line 711
	}
#line 711
#ifdef ERANGE_FILL
#line 711
        free(fillp);
#line 711
#endif
#line 711

#line 711
	return status;
#line 711
}
#line 711

static int
#line 712
putNCvx_schar_short(NC3_INFO* ncp, const NC_var *varp,
#line 712
		 const size_t *start, size_t nelems, const short *value)
#line 712
{
#line 712
	off_t offset = NC_varoffset(ncp, varp, start);
#line 712
	size_t remaining = varp->xsz * nelems;
#line 712
	int status = NC_NOERR;
#line 712
	void *xp;
#line 712
        void *fillp=NULL;
#line 712

#line 712
	if(nelems == 0)
#line 712
		return NC_NOERR;
#line 712

#line 712
	assert(value != NULL);
#line 712

#line 712
#ifdef ERANGE_FILL
#line 712
        fillp = malloc(varp->xsz);
#line 712
        status = NC3_inq_var_fill(varp, fillp);
#line 712
#endif
#line 712

#line 712
	for(;;)
#line 712
	{
#line 712
		size_t extent = MIN(remaining, ncp->chunk);
#line 712
		size_t nput = ncx_howmany(varp->type, extent);
#line 712

#line 712
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 712
				 RGN_WRITE, &xp);
#line 712
		if(lstatus != NC_NOERR)
#line 712
			return lstatus;
#line 712

#line 712
		lstatus = ncx_putn_schar_short(&xp, nput, value ,fillp);
#line 712
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 712
		{
#line 712
			/* not fatal to the loop */
#line 712
			status = lstatus;
#line 712
		}
#line 712

#line 712
		(void) ncio_rel(ncp->nciop, offset,
#line 712
				 RGN_MODIFIED);
#line 712

#line 712
		remaining -= extent;
#line 712
		if(remaining == 0)
#line 712
			break; /* normal loop exit */
#line 712
		offset += (off_t)extent;
#line 712
		value += nput;
#line 712

#line 712
	}
#line 712
#ifdef ERANGE_FILL
#line 712
        free(fillp);
#line 712
#endif
#line 712

#line 712
	return status;
#line 712
}
#line 712

static int
#line 713
putNCvx_schar_int(NC3_INFO* ncp, const NC_var *varp,
#line 713
		 const size_t *start, size_t nelems, const int *value)
#line 713
{
#line 713
	off_t offset = NC_varoffset(ncp, varp, start);
#line 713
	size_t remaining = varp->xsz * nelems;
#line 713
	int status = NC_NOERR;
#line 713
	void *xp;
#line 713
        void *fillp=NULL;
#line 713

#line 713
	if(nelems == 0)
#line 713
		return NC_NOERR;
#line 713

#line 713
	assert(value != NULL);
#line 713

#line 713
#ifdef ERANGE_FILL
#line 713
        fillp = malloc(varp->xsz);
#line 713
        status = NC3_inq_var_fill(varp, fillp);
#line 713
#endif
#line 713

#line 713
	for(;;)
#line 713
	{
#line 713
		size_t extent = MIN(remaining, ncp->chunk);
#line 713
		size_t nput = ncx_howmany(varp->type, extent);
#line 713

#line 713
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 713
				 RGN_WRITE, &xp);
#line 713
		if(lstatus != NC_NOERR)
#line 713
			return lstatus;
#line 713

#line 713
		lstatus = ncx_putn_schar_int(&xp, nput, value ,fillp);
#line 713
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 713
		{
#line 713
			/* not fatal to the loop */
#line 713
			status = lstatus;
#line 713
		}
#line 713

#line 713
		(void) ncio_rel(ncp->nciop, offset,
#line 713
				 RGN_MODIFIED);
#line 713

#line 713
		remaining -= extent;
#line 713
		if(remaining == 0)
#line 713
			break; /* normal loop exit */
#line 713
		offset += (off_t)extent;
#line 713
		value += nput;
#line 713

#line 713
	}
#line 713
#ifdef ERANGE_FILL
#line 713
        free(fillp);
#line 713
#endif
#line 713

#line 713
	return status;
#line 713
}
#line 713

static int
#line 714
putNCvx_schar_float(NC3_INFO* ncp, const NC_var *varp,
#line 714
		 const size_t *start, size_t nelems, const float *value)
#line 714
{
#line 714
	off_t offset = NC_varoffset(ncp, varp, start);
#line 714
	size_t remaining = varp->xsz * nelems;
#line 714
	int status = NC_NOERR;
#line 714
	void *xp;
#line 714
        void *fillp=NULL;
#line 714

#line 714
	if(nelems == 0)
#line 714
		return NC_NOERR;
#line 714

#line 714
	assert(value != NULL);
#line 714

#line 714
#ifdef ERANGE_FILL
#line 714
        fillp = malloc(varp->xsz);
#line 714
        status = NC3_inq_var_fill(varp, fillp);
#line 714
#endif
#line 714

#line 714
	for(;;)
#line 714
	{
#line 714
		size_t extent = MIN(remaining, ncp->chunk);
#line 714
		size_t nput = ncx_howmany(varp->type, extent);
#line 714

#line 714
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 714
				 RGN_WRITE, &xp);
#line 714
		if(lstatus != NC_NOERR)
#line 714
			return lstatus;
#line 714

#line 714
		lstatus = ncx_putn_schar_float(&xp, nput, value ,fillp);
#line 714
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 714
		{
#line 714
			/* not fatal to the loop */
#line 714
			status = lstatus;
#line 714
		}
#line 714

#line 714
		(void) ncio_rel(ncp->nciop, offset,
#line 714
				 RGN_MODIFIED);
#line 714

#line 714
		remaining -= extent;
#line 714
		if(remaining == 0)
#line 714
			break; /* normal loop exit */
#line 714
		offset += (off_t)extent;
#line 714
		value += nput;
#line 714

#line 714
	}
#line 714
#ifdef ERANGE_FILL
#line 714
        free(fillp);
#line 714
#endif
#line 714

#line 714
	return status;
#line 714
}
#line 714

static int
#line 715
putNCvx_schar_double(NC3_INFO* ncp, const NC_var *varp,
#line 715
		 const size_t *start, size_t nelems, const double *value)
#line 715
{
#line 715
	off_t offset = NC_varoffset(ncp, varp, start);
#line 715
	size_t remaining = varp->xsz * nelems;
#line 715
	int status = NC_NOERR;
#line 715
	void *xp;
#line 715
        void *fillp=NULL;
#line 715

#line 715
	if(nelems == 0)
#line 715
		return NC_NOERR;
#line 715

#line 715
	assert(value != NULL);
#line 715

#line 715
#ifdef ERANGE_FILL
#line 715
        fillp = malloc(varp->xsz);
#line 715
        status = NC3_inq_var_fill(varp, fillp);
#line 715
#endif
#line 715

#line 715
	for(;;)
#line 715
	{
#line 715
		size_t extent = MIN(remaining, ncp->chunk);
#line 715
		size_t nput = ncx_howmany(varp->type, extent);
#line 715

#line 715
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 715
				 RGN_WRITE, &xp);
#line 715
		if(lstatus != NC_NOERR)
#line 715
			return lstatus;
#line 715

#line 715
		lstatus = ncx_putn_schar_double(&xp, nput, value ,fillp);
#line 715
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 715
		{
#line 715
			/* not fatal to the loop */
#line 715
			status = lstatus;
#line 715
		}
#line 715

#line 715
		(void) ncio_rel(ncp->nciop, offset,
#line 715
				 RGN_MODIFIED);
#line 715

#line 715
		remaining -= extent;
#line 715
		if(remaining == 0)
#line 715
			break; /* normal loop exit */
#line 715
		offset += (off_t)extent;
#line 715
		value += nput;
#line 715

#line 715
	}
#line 715
#ifdef ERANGE_FILL
#line 715
        free(fillp);
#line 715
#endif
#line 715

#line 715
	return status;
#line 715
}
#line 715

static int
#line 716
putNCvx_schar_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 716
		 const size_t *start, size_t nelems, const longlong *value)
#line 716
{
#line 716
	off_t offset = NC_varoffset(ncp, varp, start);
#line 716
	size_t remaining = varp->xsz * nelems;
#line 716
	int status = NC_NOERR;
#line 716
	void *xp;
#line 716
        void *fillp=NULL;
#line 716

#line 716
	if(nelems == 0)
#line 716
		return NC_NOERR;
#line 716

#line 716
	assert(value != NULL);
#line 716

#line 716
#ifdef ERANGE_FILL
#line 716
        fillp = malloc(varp->xsz);
#line 716
        status = NC3_inq_var_fill(varp, fillp);
#line 716
#endif
#line 716

#line 716
	for(;;)
#line 716
	{
#line 716
		size_t extent = MIN(remaining, ncp->chunk);
#line 716
		size_t nput = ncx_howmany(varp->type, extent);
#line 716

#line 716
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 716
				 RGN_WRITE, &xp);
#line 716
		if(lstatus != NC_NOERR)
#line 716
			return lstatus;
#line 716

#line 716
		lstatus = ncx_putn_schar_longlong(&xp, nput, value ,fillp);
#line 716
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 716
		{
#line 716
			/* not fatal to the loop */
#line 716
			status = lstatus;
#line 716
		}
#line 716

#line 716
		(void) ncio_rel(ncp->nciop, offset,
#line 716
				 RGN_MODIFIED);
#line 716

#line 716
		remaining -= extent;
#line 716
		if(remaining == 0)
#line 716
			break; /* normal loop exit */
#line 716
		offset += (off_t)extent;
#line 716
		value += nput;
#line 716

#line 716
	}
#line 716
#ifdef ERANGE_FILL
#line 716
        free(fillp);
#line 716
#endif
#line 716

#line 716
	return status;
#line 716
}
#line 716

static int
#line 717
putNCvx_schar_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 717
		 const size_t *start, size_t nelems, const ushort *value)
#line 717
{
#line 717
	off_t offset = NC_varoffset(ncp, varp, start);
#line 717
	size_t remaining = varp->xsz * nelems;
#line 717
	int status = NC_NOERR;
#line 717
	void *xp;
#line 717
        void *fillp=NULL;
#line 717

#line 717
	if(nelems == 0)
#line 717
		return NC_NOERR;
#line 717

#line 717
	assert(value != NULL);
#line 717

#line 717
#ifdef ERANGE_FILL
#line 717
        fillp = malloc(varp->xsz);
#line 717
        status = NC3_inq_var_fill(varp, fillp);
#line 717
#endif
#line 717

#line 717
	for(;;)
#line 717
	{
#line 717
		size_t extent = MIN(remaining, ncp->chunk);
#line 717
		size_t nput = ncx_howmany(varp->type, extent);
#line 717

#line 717
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 717
				 RGN_WRITE, &xp);
#line 717
		if(lstatus != NC_NOERR)
#line 717
			return lstatus;
#line 717

#line 717
		lstatus = ncx_putn_schar_ushort(&xp, nput, value ,fillp);
#line 717
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 717
		{
#line 717
			/* not fatal to the loop */
#line 717
			status = lstatus;
#line 717
		}
#line 717

#line 717
		(void) ncio_rel(ncp->nciop, offset,
#line 717
				 RGN_MODIFIED);
#line 717

#line 717
		remaining -= extent;
#line 717
		if(remaining == 0)
#line 717
			break; /* normal loop exit */
#line 717
		offset += (off_t)extent;
#line 717
		value += nput;
#line 717

#line 717
	}
#line 717
#ifdef ERANGE_FILL
#line 717
        free(fillp);
#line 717
#endif
#line 717

#line 717
	return status;
#line 717
}
#line 717

static int
#line 718
putNCvx_schar_uint(NC3_INFO* ncp, const NC_var *varp,
#line 718
		 const size_t *start, size_t nelems, const uint *value)
#line 718
{
#line 718
	off_t offset = NC_varoffset(ncp, varp, start);
#line 718
	size_t remaining = varp->xsz * nelems;
#line 718
	int status = NC_NOERR;
#line 718
	void *xp;
#line 718
        void *fillp=NULL;
#line 718

#line 718
	if(nelems == 0)
#line 718
		return NC_NOERR;
#line 718

#line 718
	assert(value != NULL);
#line 718

#line 718
#ifdef ERANGE_FILL
#line 718
        fillp = malloc(varp->xsz);
#line 718
        status = NC3_inq_var_fill(varp, fillp);
#line 718
#endif
#line 718

#line 718
	for(;;)
#line 718
	{
#line 718
		size_t extent = MIN(remaining, ncp->chunk);
#line 718
		size_t nput = ncx_howmany(varp->type, extent);
#line 718

#line 718
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 718
				 RGN_WRITE, &xp);
#line 718
		if(lstatus != NC_NOERR)
#line 718
			return lstatus;
#line 718

#line 718
		lstatus = ncx_putn_schar_uint(&xp, nput, value ,fillp);
#line 718
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 718
		{
#line 718
			/* not fatal to the loop */
#line 718
			status = lstatus;
#line 718
		}
#line 718

#line 718
		(void) ncio_rel(ncp->nciop, offset,
#line 718
				 RGN_MODIFIED);
#line 718

#line 718
		remaining -= extent;
#line 718
		if(remaining == 0)
#line 718
			break; /* normal loop exit */
#line 718
		offset += (off_t)extent;
#line 718
		value += nput;
#line 718

#line 718
	}
#line 718
#ifdef ERANGE_FILL
#line 718
        free(fillp);
#line 718
#endif
#line 718

#line 718
	return status;
#line 718
}
#line 718

static int
#line 719
putNCvx_schar_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 719
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 719
{
#line 719
	off_t offset = NC_varoffset(ncp, varp, start);
#line 719
	size_t remaining = varp->xsz * nelems;
#line 719
	int status = NC_NOERR;
#line 719
	void *xp;
#line 719
        void *fillp=NULL;
#line 719

#line 719
	if(nelems == 0)
#line 719
		return NC_NOERR;
#line 719

#line 719
	assert(value != NULL);
#line 719

#line 719
#ifdef ERANGE_FILL
#line 719
        fillp = malloc(varp->xsz);
#line 719
        status = NC3_inq_var_fill(varp, fillp);
#line 719
#endif
#line 719

#line 719
	for(;;)
#line 719
	{
#line 719
		size_t extent = MIN(remaining, ncp->chunk);
#line 719
		size_t nput = ncx_howmany(varp->type, extent);
#line 719

#line 719
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 719
				 RGN_WRITE, &xp);
#line 719
		if(lstatus != NC_NOERR)
#line 719
			return lstatus;
#line 719

#line 719
		lstatus = ncx_putn_schar_ulonglong(&xp, nput, value ,fillp);
#line 719
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 719
		{
#line 719
			/* not fatal to the loop */
#line 719
			status = lstatus;
#line 719
		}
#line 719

#line 719
		(void) ncio_rel(ncp->nciop, offset,
#line 719
				 RGN_MODIFIED);
#line 719

#line 719
		remaining -= extent;
#line 719
		if(remaining == 0)
#line 719
			break; /* normal loop exit */
#line 719
		offset += (off_t)extent;
#line 719
		value += nput;
#line 719

#line 719
	}
#line 719
#ifdef ERANGE_FILL
#line 719
        free(fillp);
#line 719
#endif
#line 719

#line 719
	return status;
#line 719
}
#line 719


static int
#line 721
putNCvx_short_schar(NC3_INFO* ncp, const NC_var *varp,
#line 721
		 const size_t *start, size_t nelems, const schar *value)
#line 721
{
#line 721
	off_t offset = NC_varoffset(ncp, varp, start);
#line 721
	size_t remaining = varp->xsz * nelems;
#line 721
	int status = NC_NOERR;
#line 721
	void *xp;
#line 721
        void *fillp=NULL;
#line 721

#line 721
	if(nelems == 0)
#line 721
		return NC_NOERR;
#line 721

#line 721
	assert(value != NULL);
#line 721

#line 721
#ifdef ERANGE_FILL
#line 721
        fillp = malloc(varp->xsz);
#line 721
        status = NC3_inq_var_fill(varp, fillp);
#line 721
#endif
#line 721

#line 721
	for(;;)
#line 721
	{
#line 721
		size_t extent = MIN(remaining, ncp->chunk);
#line 721
		size_t nput = ncx_howmany(varp->type, extent);
#line 721

#line 721
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 721
				 RGN_WRITE, &xp);
#line 721
		if(lstatus != NC_NOERR)
#line 721
			return lstatus;
#line 721

#line 721
		lstatus = ncx_putn_short_schar(&xp, nput, value ,fillp);
#line 721
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 721
		{
#line 721
			/* not fatal to the loop */
#line 721
			status = lstatus;
#line 721
		}
#line 721

#line 721
		(void) ncio_rel(ncp->nciop, offset,
#line 721
				 RGN_MODIFIED);
#line 721

#line 721
		remaining -= extent;
#line 721
		if(remaining == 0)
#line 721
			break; /* normal loop exit */
#line 721
		offset += (off_t)extent;
#line 721
		value += nput;
#line 721

#line 721
	}
#line 721
#ifdef ERANGE_FILL
#line 721
        free(fillp);
#line 721
#endif
#line 721

#line 721
	return status;
#line 721
}
#line 721

static int
#line 722
putNCvx_short_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 722
		 const size_t *start, size_t nelems, const uchar *value)
#line 722
{
#line 722
	off_t offset = NC_varoffset(ncp, varp, start);
#line 722
	size_t remaining = varp->xsz * nelems;
#line 722
	int status = NC_NOERR;
#line 722
	void *xp;
#line 722
        void *fillp=NULL;
#line 722

#line 722
	if(nelems == 0)
#line 722
		return NC_NOERR;
#line 722

#line 722
	assert(value != NULL);
#line 722

#line 722
#ifdef ERANGE_FILL
#line 722
        fillp = malloc(varp->xsz);
#line 722
        status = NC3_inq_var_fill(varp, fillp);
#line 722
#endif
#line 722

#line 722
	for(;;)
#line 722
	{
#line 722
		size_t extent = MIN(remaining, ncp->chunk);
#line 722
		size_t nput = ncx_howmany(varp->type, extent);
#line 722

#line 722
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 722
				 RGN_WRITE, &xp);
#line 722
		if(lstatus != NC_NOERR)
#line 722
			return lstatus;
#line 722

#line 722
		lstatus = ncx_putn_short_uchar(&xp, nput, value ,fillp);
#line 722
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 722
		{
#line 722
			/* not fatal to the loop */
#line 722
			status = lstatus;
#line 722
		}
#line 722

#line 722
		(void) ncio_rel(ncp->nciop, offset,
#line 722
				 RGN_MODIFIED);
#line 722

#line 722
		remaining -= extent;
#line 722
		if(remaining == 0)
#line 722
			break; /* normal loop exit */
#line 722
		offset += (off_t)extent;
#line 722
		value += nput;
#line 722

#line 722
	}
#line 722
#ifdef ERANGE_FILL
#line 722
        free(fillp);
#line 722
#endif
#line 722

#line 722
	return status;
#line 722
}
#line 722

static int
#line 723
putNCvx_short_short(NC3_INFO* ncp, const NC_var *varp,
#line 723
		 const size_t *start, size_t nelems, const short *value)
#line 723
{
#line 723
	off_t offset = NC_varoffset(ncp, varp, start);
#line 723
	size_t remaining = varp->xsz * nelems;
#line 723
	int status = NC_NOERR;
#line 723
	void *xp;
#line 723
        void *fillp=NULL;
#line 723

#line 723
	if(nelems == 0)
#line 723
		return NC_NOERR;
#line 723

#line 723
	assert(value != NULL);
#line 723

#line 723
#ifdef ERANGE_FILL
#line 723
        fillp = malloc(varp->xsz);
#line 723
        status = NC3_inq_var_fill(varp, fillp);
#line 723
#endif
#line 723

#line 723
	for(;;)
#line 723
	{
#line 723
		size_t extent = MIN(remaining, ncp->chunk);
#line 723
		size_t nput = ncx_howmany(varp->type, extent);
#line 723

#line 723
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 723
				 RGN_WRITE, &xp);
#line 723
		if(lstatus != NC_NOERR)
#line 723
			return lstatus;
#line 723

#line 723
		lstatus = ncx_putn_short_short(&xp, nput, value ,fillp);
#line 723
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 723
		{
#line 723
			/* not fatal to the loop */
#line 723
			status = lstatus;
#line 723
		}
#line 723

#line 723
		(void) ncio_rel(ncp->nciop, offset,
#line 723
				 RGN_MODIFIED);
#line 723

#line 723
		remaining -= extent;
#line 723
		if(remaining == 0)
#line 723
			break; /* normal loop exit */
#line 723
		offset += (off_t)extent;
#line 723
		value += nput;
#line 723

#line 723
	}
#line 723
#ifdef ERANGE_FILL
#line 723
        free(fillp);
#line 723
#endif
#line 723

#line 723
	return status;
#line 723
}
#line 723

static int
#line 724
putNCvx_short_int(NC3_INFO* ncp, const NC_var *varp,
#line 724
		 const size_t *start, size_t nelems, const int *value)
#line 724
{
#line 724
	off_t offset = NC_varoffset(ncp, varp, start);
#line 724
	size_t remaining = varp->xsz * nelems;
#line 724
	int status = NC_NOERR;
#line 724
	void *xp;
#line 724
        void *fillp=NULL;
#line 724

#line 724
	if(nelems == 0)
#line 724
		return NC_NOERR;
#line 724

#line 724
	assert(value != NULL);
#line 724

#line 724
#ifdef ERANGE_FILL
#line 724
        fillp = malloc(varp->xsz);
#line 724
        status = NC3_inq_var_fill(varp, fillp);
#line 724
#endif
#line 724

#line 724
	for(;;)
#line 724
	{
#line 724
		size_t extent = MIN(remaining, ncp->chunk);
#line 724
		size_t nput = ncx_howmany(varp->type, extent);
#line 724

#line 724
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 724
				 RGN_WRITE, &xp);
#line 724
		if(lstatus != NC_NOERR)
#line 724
			return lstatus;
#line 724

#line 724
		lstatus = ncx_putn_short_int(&xp, nput, value ,fillp);
#line 724
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 724
		{
#line 724
			/* not fatal to the loop */
#line 724
			status = lstatus;
#line 724
		}
#line 724

#line 724
		(void) ncio_rel(ncp->nciop, offset,
#line 724
				 RGN_MODIFIED);
#line 724

#line 724
		remaining -= extent;
#line 724
		if(remaining == 0)
#line 724
			break; /* normal loop exit */
#line 724
		offset += (off_t)extent;
#line 724
		value += nput;
#line 724

#line 724
	}
#line 724
#ifdef ERANGE_FILL
#line 724
        free(fillp);
#line 724
#endif
#line 724

#line 724
	return status;
#line 724
}
#line 724

static int
#line 725
putNCvx_short_float(NC3_INFO* ncp, const NC_var *varp,
#line 725
		 const size_t *start, size_t nelems, const float *value)
#line 725
{
#line 725
	off_t offset = NC_varoffset(ncp, varp, start);
#line 725
	size_t remaining = varp->xsz * nelems;
#line 725
	int status = NC_NOERR;
#line 725
	void *xp;
#line 725
        void *fillp=NULL;
#line 725

#line 725
	if(nelems == 0)
#line 725
		return NC_NOERR;
#line 725

#line 725
	assert(value != NULL);
#line 725

#line 725
#ifdef ERANGE_FILL
#line 725
        fillp = malloc(varp->xsz);
#line 725
        status = NC3_inq_var_fill(varp, fillp);
#line 725
#endif
#line 725

#line 725
	for(;;)
#line 725
	{
#line 725
		size_t extent = MIN(remaining, ncp->chunk);
#line 725
		size_t nput = ncx_howmany(varp->type, extent);
#line 725

#line 725
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 725
				 RGN_WRITE, &xp);
#line 725
		if(lstatus != NC_NOERR)
#line 725
			return lstatus;
#line 725

#line 725
		lstatus = ncx_putn_short_float(&xp, nput, value ,fillp);
#line 725
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 725
		{
#line 725
			/* not fatal to the loop */
#line 725
			status = lstatus;
#line 725
		}
#line 725

#line 725
		(void) ncio_rel(ncp->nciop, offset,
#line 725
				 RGN_MODIFIED);
#line 725

#line 725
		remaining -= extent;
#line 725
		if(remaining == 0)
#line 725
			break; /* normal loop exit */
#line 725
		offset += (off_t)extent;
#line 725
		value += nput;
#line 725

#line 725
	}
#line 725
#ifdef ERANGE_FILL
#line 725
        free(fillp);
#line 725
#endif
#line 725

#line 725
	return status;
#line 725
}
#line 725

static int
#line 726
putNCvx_short_double(NC3_INFO* ncp, const NC_var *varp,
#line 726
		 const size_t *start, size_t nelems, const double *value)
#line 726
{
#line 726
	off_t offset = NC_varoffset(ncp, varp, start);
#line 726
	size_t remaining = varp->xsz * nelems;
#line 726
	int status = NC_NOERR;
#line 726
	void *xp;
#line 726
        void *fillp=NULL;
#line 726

#line 726
	if(nelems == 0)
#line 726
		return NC_NOERR;
#line 726

#line 726
	assert(value != NULL);
#line 726

#line 726
#ifdef ERANGE_FILL
#line 726
        fillp = malloc(varp->xsz);
#line 726
        status = NC3_inq_var_fill(varp, fillp);
#line 726
#endif
#line 726

#line 726
	for(;;)
#line 726
	{
#line 726
		size_t extent = MIN(remaining, ncp->chunk);
#line 726
		size_t nput = ncx_howmany(varp->type, extent);
#line 726

#line 726
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 726
				 RGN_WRITE, &xp);
#line 726
		if(lstatus != NC_NOERR)
#line 726
			return lstatus;
#line 726

#line 726
		lstatus = ncx_putn_short_double(&xp, nput, value ,fillp);
#line 726
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 726
		{
#line 726
			/* not fatal to the loop */
#line 726
			status = lstatus;
#line 726
		}
#line 726

#line 726
		(void) ncio_rel(ncp->nciop, offset,
#line 726
				 RGN_MODIFIED);
#line 726

#line 726
		remaining -= extent;
#line 726
		if(remaining == 0)
#line 726
			break; /* normal loop exit */
#line 726
		offset += (off_t)extent;
#line 726
		value += nput;
#line 726

#line 726
	}
#line 726
#ifdef ERANGE_FILL
#line 726
        free(fillp);
#line 726
#endif
#line 726

#line 726
	return status;
#line 726
}
#line 726

static int
#line 727
putNCvx_short_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 727
		 const size_t *start, size_t nelems, const longlong *value)
#line 727
{
#line 727
	off_t offset = NC_varoffset(ncp, varp, start);
#line 727
	size_t remaining = varp->xsz * nelems;
#line 727
	int status = NC_NOERR;
#line 727
	void *xp;
#line 727
        void *fillp=NULL;
#line 727

#line 727
	if(nelems == 0)
#line 727
		return NC_NOERR;
#line 727

#line 727
	assert(value != NULL);
#line 727

#line 727
#ifdef ERANGE_FILL
#line 727
        fillp = malloc(varp->xsz);
#line 727
        status = NC3_inq_var_fill(varp, fillp);
#line 727
#endif
#line 727

#line 727
	for(;;)
#line 727
	{
#line 727
		size_t extent = MIN(remaining, ncp->chunk);
#line 727
		size_t nput = ncx_howmany(varp->type, extent);
#line 727

#line 727
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 727
				 RGN_WRITE, &xp);
#line 727
		if(lstatus != NC_NOERR)
#line 727
			return lstatus;
#line 727

#line 727
		lstatus = ncx_putn_short_longlong(&xp, nput, value ,fillp);
#line 727
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 727
		{
#line 727
			/* not fatal to the loop */
#line 727
			status = lstatus;
#line 727
		}
#line 727

#line 727
		(void) ncio_rel(ncp->nciop, offset,
#line 727
				 RGN_MODIFIED);
#line 727

#line 727
		remaining -= extent;
#line 727
		if(remaining == 0)
#line 727
			break; /* normal loop exit */
#line 727
		offset += (off_t)extent;
#line 727
		value += nput;
#line 727

#line 727
	}
#line 727
#ifdef ERANGE_FILL
#line 727
        free(fillp);
#line 727
#endif
#line 727

#line 727
	return status;
#line 727
}
#line 727

static int
#line 728
putNCvx_short_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 728
		 const size_t *start, size_t nelems, const ushort *value)
#line 728
{
#line 728
	off_t offset = NC_varoffset(ncp, varp, start);
#line 728
	size_t remaining = varp->xsz * nelems;
#line 728
	int status = NC_NOERR;
#line 728
	void *xp;
#line 728
        void *fillp=NULL;
#line 728

#line 728
	if(nelems == 0)
#line 728
		return NC_NOERR;
#line 728

#line 728
	assert(value != NULL);
#line 728

#line 728
#ifdef ERANGE_FILL
#line 728
        fillp = malloc(varp->xsz);
#line 728
        status = NC3_inq_var_fill(varp, fillp);
#line 728
#endif
#line 728

#line 728
	for(;;)
#line 728
	{
#line 728
		size_t extent = MIN(remaining, ncp->chunk);
#line 728
		size_t nput = ncx_howmany(varp->type, extent);
#line 728

#line 728
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 728
				 RGN_WRITE, &xp);
#line 728
		if(lstatus != NC_NOERR)
#line 728
			return lstatus;
#line 728

#line 728
		lstatus = ncx_putn_short_ushort(&xp, nput, value ,fillp);
#line 728
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 728
		{
#line 728
			/* not fatal to the loop */
#line 728
			status = lstatus;
#line 728
		}
#line 728

#line 728
		(void) ncio_rel(ncp->nciop, offset,
#line 728
				 RGN_MODIFIED);
#line 728

#line 728
		remaining -= extent;
#line 728
		if(remaining == 0)
#line 728
			break; /* normal loop exit */
#line 728
		offset += (off_t)extent;
#line 728
		value += nput;
#line 728

#line 728
	}
#line 728
#ifdef ERANGE_FILL
#line 728
        free(fillp);
#line 728
#endif
#line 728

#line 728
	return status;
#line 728
}
#line 728

static int
#line 729
putNCvx_short_uint(NC3_INFO* ncp, const NC_var *varp,
#line 729
		 const size_t *start, size_t nelems, const uint *value)
#line 729
{
#line 729
	off_t offset = NC_varoffset(ncp, varp, start);
#line 729
	size_t remaining = varp->xsz * nelems;
#line 729
	int status = NC_NOERR;
#line 729
	void *xp;
#line 729
        void *fillp=NULL;
#line 729

#line 729
	if(nelems == 0)
#line 729
		return NC_NOERR;
#line 729

#line 729
	assert(value != NULL);
#line 729

#line 729
#ifdef ERANGE_FILL
#line 729
        fillp = malloc(varp->xsz);
#line 729
        status = NC3_inq_var_fill(varp, fillp);
#line 729
#endif
#line 729

#line 729
	for(;;)
#line 729
	{
#line 729
		size_t extent = MIN(remaining, ncp->chunk);
#line 729
		size_t nput = ncx_howmany(varp->type, extent);
#line 729

#line 729
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 729
				 RGN_WRITE, &xp);
#line 729
		if(lstatus != NC_NOERR)
#line 729
			return lstatus;
#line 729

#line 729
		lstatus = ncx_putn_short_uint(&xp, nput, value ,fillp);
#line 729
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 729
		{
#line 729
			/* not fatal to the loop */
#line 729
			status = lstatus;
#line 729
		}
#line 729

#line 729
		(void) ncio_rel(ncp->nciop, offset,
#line 729
				 RGN_MODIFIED);
#line 729

#line 729
		remaining -= extent;
#line 729
		if(remaining == 0)
#line 729
			break; /* normal loop exit */
#line 729
		offset += (off_t)extent;
#line 729
		value += nput;
#line 729

#line 729
	}
#line 729
#ifdef ERANGE_FILL
#line 729
        free(fillp);
#line 729
#endif
#line 729

#line 729
	return status;
#line 729
}
#line 729

static int
#line 730
putNCvx_short_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 730
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 730
{
#line 730
	off_t offset = NC_varoffset(ncp, varp, start);
#line 730
	size_t remaining = varp->xsz * nelems;
#line 730
	int status = NC_NOERR;
#line 730
	void *xp;
#line 730
        void *fillp=NULL;
#line 730

#line 730
	if(nelems == 0)
#line 730
		return NC_NOERR;
#line 730

#line 730
	assert(value != NULL);
#line 730

#line 730
#ifdef ERANGE_FILL
#line 730
        fillp = malloc(varp->xsz);
#line 730
        status = NC3_inq_var_fill(varp, fillp);
#line 730
#endif
#line 730

#line 730
	for(;;)
#line 730
	{
#line 730
		size_t extent = MIN(remaining, ncp->chunk);
#line 730
		size_t nput = ncx_howmany(varp->type, extent);
#line 730

#line 730
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 730
				 RGN_WRITE, &xp);
#line 730
		if(lstatus != NC_NOERR)
#line 730
			return lstatus;
#line 730

#line 730
		lstatus = ncx_putn_short_ulonglong(&xp, nput, value ,fillp);
#line 730
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 730
		{
#line 730
			/* not fatal to the loop */
#line 730
			status = lstatus;
#line 730
		}
#line 730

#line 730
		(void) ncio_rel(ncp->nciop, offset,
#line 730
				 RGN_MODIFIED);
#line 730

#line 730
		remaining -= extent;
#line 730
		if(remaining == 0)
#line 730
			break; /* normal loop exit */
#line 730
		offset += (off_t)extent;
#line 730
		value += nput;
#line 730

#line 730
	}
#line 730
#ifdef ERANGE_FILL
#line 730
        free(fillp);
#line 730
#endif
#line 730

#line 730
	return status;
#line 730
}
#line 730


static int
#line 732
putNCvx_int_schar(NC3_INFO* ncp, const NC_var *varp,
#line 732
		 const size_t *start, size_t nelems, const schar *value)
#line 732
{
#line 732
	off_t offset = NC_varoffset(ncp, varp, start);
#line 732
	size_t remaining = varp->xsz * nelems;
#line 732
	int status = NC_NOERR;
#line 732
	void *xp;
#line 732
        void *fillp=NULL;
#line 732

#line 732
	if(nelems == 0)
#line 732
		return NC_NOERR;
#line 732

#line 732
	assert(value != NULL);
#line 732

#line 732
#ifdef ERANGE_FILL
#line 732
        fillp = malloc(varp->xsz);
#line 732
        status = NC3_inq_var_fill(varp, fillp);
#line 732
#endif
#line 732

#line 732
	for(;;)
#line 732
	{
#line 732
		size_t extent = MIN(remaining, ncp->chunk);
#line 732
		size_t nput = ncx_howmany(varp->type, extent);
#line 732

#line 732
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 732
				 RGN_WRITE, &xp);
#line 732
		if(lstatus != NC_NOERR)
#line 732
			return lstatus;
#line 732

#line 732
		lstatus = ncx_putn_int_schar(&xp, nput, value ,fillp);
#line 732
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 732
		{
#line 732
			/* not fatal to the loop */
#line 732
			status = lstatus;
#line 732
		}
#line 732

#line 732
		(void) ncio_rel(ncp->nciop, offset,
#line 732
				 RGN_MODIFIED);
#line 732

#line 732
		remaining -= extent;
#line 732
		if(remaining == 0)
#line 732
			break; /* normal loop exit */
#line 732
		offset += (off_t)extent;
#line 732
		value += nput;
#line 732

#line 732
	}
#line 732
#ifdef ERANGE_FILL
#line 732
        free(fillp);
#line 732
#endif
#line 732

#line 732
	return status;
#line 732
}
#line 732

static int
#line 733
putNCvx_int_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 733
		 const size_t *start, size_t nelems, const uchar *value)
#line 733
{
#line 733
	off_t offset = NC_varoffset(ncp, varp, start);
#line 733
	size_t remaining = varp->xsz * nelems;
#line 733
	int status = NC_NOERR;
#line 733
	void *xp;
#line 733
        void *fillp=NULL;
#line 733

#line 733
	if(nelems == 0)
#line 733
		return NC_NOERR;
#line 733

#line 733
	assert(value != NULL);
#line 733

#line 733
#ifdef ERANGE_FILL
#line 733
        fillp = malloc(varp->xsz);
#line 733
        status = NC3_inq_var_fill(varp, fillp);
#line 733
#endif
#line 733

#line 733
	for(;;)
#line 733
	{
#line 733
		size_t extent = MIN(remaining, ncp->chunk);
#line 733
		size_t nput = ncx_howmany(varp->type, extent);
#line 733

#line 733
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 733
				 RGN_WRITE, &xp);
#line 733
		if(lstatus != NC_NOERR)
#line 733
			return lstatus;
#line 733

#line 733
		lstatus = ncx_putn_int_uchar(&xp, nput, value ,fillp);
#line 733
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 733
		{
#line 733
			/* not fatal to the loop */
#line 733
			status = lstatus;
#line 733
		}
#line 733

#line 733
		(void) ncio_rel(ncp->nciop, offset,
#line 733
				 RGN_MODIFIED);
#line 733

#line 733
		remaining -= extent;
#line 733
		if(remaining == 0)
#line 733
			break; /* normal loop exit */
#line 733
		offset += (off_t)extent;
#line 733
		value += nput;
#line 733

#line 733
	}
#line 733
#ifdef ERANGE_FILL
#line 733
        free(fillp);
#line 733
#endif
#line 733

#line 733
	return status;
#line 733
}
#line 733

static int
#line 734
putNCvx_int_short(NC3_INFO* ncp, const NC_var *varp,
#line 734
		 const size_t *start, size_t nelems, const short *value)
#line 734
{
#line 734
	off_t offset = NC_varoffset(ncp, varp, start);
#line 734
	size_t remaining = varp->xsz * nelems;
#line 734
	int status = NC_NOERR;
#line 734
	void *xp;
#line 734
        void *fillp=NULL;
#line 734

#line 734
	if(nelems == 0)
#line 734
		return NC_NOERR;
#line 734

#line 734
	assert(value != NULL);
#line 734

#line 734
#ifdef ERANGE_FILL
#line 734
        fillp = malloc(varp->xsz);
#line 734
        status = NC3_inq_var_fill(varp, fillp);
#line 734
#endif
#line 734

#line 734
	for(;;)
#line 734
	{
#line 734
		size_t extent = MIN(remaining, ncp->chunk);
#line 734
		size_t nput = ncx_howmany(varp->type, extent);
#line 734

#line 734
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 734
				 RGN_WRITE, &xp);
#line 734
		if(lstatus != NC_NOERR)
#line 734
			return lstatus;
#line 734

#line 734
		lstatus = ncx_putn_int_short(&xp, nput, value ,fillp);
#line 734
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 734
		{
#line 734
			/* not fatal to the loop */
#line 734
			status = lstatus;
#line 734
		}
#line 734

#line 734
		(void) ncio_rel(ncp->nciop, offset,
#line 734
				 RGN_MODIFIED);
#line 734

#line 734
		remaining -= extent;
#line 734
		if(remaining == 0)
#line 734
			break; /* normal loop exit */
#line 734
		offset += (off_t)extent;
#line 734
		value += nput;
#line 734

#line 734
	}
#line 734
#ifdef ERANGE_FILL
#line 734
        free(fillp);
#line 734
#endif
#line 734

#line 734
	return status;
#line 734
}
#line 734

static int
#line 735
putNCvx_int_int(NC3_INFO* ncp, const NC_var *varp,
#line 735
		 const size_t *start, size_t nelems, const int *value)
#line 735
{
#line 735
	off_t offset = NC_varoffset(ncp, varp, start);
#line 735
	size_t remaining = varp->xsz * nelems;
#line 735
	int status = NC_NOERR;
#line 735
	void *xp;
#line 735
        void *fillp=NULL;
#line 735

#line 735
	if(nelems == 0)
#line 735
		return NC_NOERR;
#line 735

#line 735
	assert(value != NULL);
#line 735

#line 735
#ifdef ERANGE_FILL
#line 735
        fillp = malloc(varp->xsz);
#line 735
        status = NC3_inq_var_fill(varp, fillp);
#line 735
#endif
#line 735

#line 735
	for(;;)
#line 735
	{
#line 735
		size_t extent = MIN(remaining, ncp->chunk);
#line 735
		size_t nput = ncx_howmany(varp->type, extent);
#line 735

#line 735
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 735
				 RGN_WRITE, &xp);
#line 735
		if(lstatus != NC_NOERR)
#line 735
			return lstatus;
#line 735

#line 735
		lstatus = ncx_putn_int_int(&xp, nput, value ,fillp);
#line 735
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 735
		{
#line 735
			/* not fatal to the loop */
#line 735
			status = lstatus;
#line 735
		}
#line 735

#line 735
		(void) ncio_rel(ncp->nciop, offset,
#line 735
				 RGN_MODIFIED);
#line 735

#line 735
		remaining -= extent;
#line 735
		if(remaining == 0)
#line 735
			break; /* normal loop exit */
#line 735
		offset += (off_t)extent;
#line 735
		value += nput;
#line 735

#line 735
	}
#line 735
#ifdef ERANGE_FILL
#line 735
        free(fillp);
#line 735
#endif
#line 735

#line 735
	return status;
#line 735
}
#line 735

static int
#line 736
putNCvx_int_float(NC3_INFO* ncp, const NC_var *varp,
#line 736
		 const size_t *start, size_t nelems, const float *value)
#line 736
{
#line 736
	off_t offset = NC_varoffset(ncp, varp, start);
#line 736
	size_t remaining = varp->xsz * nelems;
#line 736
	int status = NC_NOERR;
#line 736
	void *xp;
#line 736
        void *fillp=NULL;
#line 736

#line 736
	if(nelems == 0)
#line 736
		return NC_NOERR;
#line 736

#line 736
	assert(value != NULL);
#line 736

#line 736
#ifdef ERANGE_FILL
#line 736
        fillp = malloc(varp->xsz);
#line 736
        status = NC3_inq_var_fill(varp, fillp);
#line 736
#endif
#line 736

#line 736
	for(;;)
#line 736
	{
#line 736
		size_t extent = MIN(remaining, ncp->chunk);
#line 736
		size_t nput = ncx_howmany(varp->type, extent);
#line 736

#line 736
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 736
				 RGN_WRITE, &xp);
#line 736
		if(lstatus != NC_NOERR)
#line 736
			return lstatus;
#line 736

#line 736
		lstatus = ncx_putn_int_float(&xp, nput, value ,fillp);
#line 736
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 736
		{
#line 736
			/* not fatal to the loop */
#line 736
			status = lstatus;
#line 736
		}
#line 736

#line 736
		(void) ncio_rel(ncp->nciop, offset,
#line 736
				 RGN_MODIFIED);
#line 736

#line 736
		remaining -= extent;
#line 736
		if(remaining == 0)
#line 736
			break; /* normal loop exit */
#line 736
		offset += (off_t)extent;
#line 736
		value += nput;
#line 736

#line 736
	}
#line 736
#ifdef ERANGE_FILL
#line 736
        free(fillp);
#line 736
#endif
#line 736

#line 736
	return status;
#line 736
}
#line 736

static int
#line 737
putNCvx_int_double(NC3_INFO* ncp, const NC_var *varp,
#line 737
		 const size_t *start, size_t nelems, const double *value)
#line 737
{
#line 737
	off_t offset = NC_varoffset(ncp, varp, start);
#line 737
	size_t remaining = varp->xsz * nelems;
#line 737
	int status = NC_NOERR;
#line 737
	void *xp;
#line 737
        void *fillp=NULL;
#line 737

#line 737
	if(nelems == 0)
#line 737
		return NC_NOERR;
#line 737

#line 737
	assert(value != NULL);
#line 737

#line 737
#ifdef ERANGE_FILL
#line 737
        fillp = malloc(varp->xsz);
#line 737
        status = NC3_inq_var_fill(varp, fillp);
#line 737
#endif
#line 737

#line 737
	for(;;)
#line 737
	{
#line 737
		size_t extent = MIN(remaining, ncp->chunk);
#line 737
		size_t nput = ncx_howmany(varp->type, extent);
#line 737

#line 737
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 737
				 RGN_WRITE, &xp);
#line 737
		if(lstatus != NC_NOERR)
#line 737
			return lstatus;
#line 737

#line 737
		lstatus = ncx_putn_int_double(&xp, nput, value ,fillp);
#line 737
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 737
		{
#line 737
			/* not fatal to the loop */
#line 737
			status = lstatus;
#line 737
		}
#line 737

#line 737
		(void) ncio_rel(ncp->nciop, offset,
#line 737
				 RGN_MODIFIED);
#line 737

#line 737
		remaining -= extent;
#line 737
		if(remaining == 0)
#line 737
			break; /* normal loop exit */
#line 737
		offset += (off_t)extent;
#line 737
		value += nput;
#line 737

#line 737
	}
#line 737
#ifdef ERANGE_FILL
#line 737
        free(fillp);
#line 737
#endif
#line 737

#line 737
	return status;
#line 737
}
#line 737

static int
#line 738
putNCvx_int_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 738
		 const size_t *start, size_t nelems, const longlong *value)
#line 738
{
#line 738
	off_t offset = NC_varoffset(ncp, varp, start);
#line 738
	size_t remaining = varp->xsz * nelems;
#line 738
	int status = NC_NOERR;
#line 738
	void *xp;
#line 738
        void *fillp=NULL;
#line 738

#line 738
	if(nelems == 0)
#line 738
		return NC_NOERR;
#line 738

#line 738
	assert(value != NULL);
#line 738

#line 738
#ifdef ERANGE_FILL
#line 738
        fillp = malloc(varp->xsz);
#line 738
        status = NC3_inq_var_fill(varp, fillp);
#line 738
#endif
#line 738

#line 738
	for(;;)
#line 738
	{
#line 738
		size_t extent = MIN(remaining, ncp->chunk);
#line 738
		size_t nput = ncx_howmany(varp->type, extent);
#line 738

#line 738
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 738
				 RGN_WRITE, &xp);
#line 738
		if(lstatus != NC_NOERR)
#line 738
			return lstatus;
#line 738

#line 738
		lstatus = ncx_putn_int_longlong(&xp, nput, value ,fillp);
#line 738
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 738
		{
#line 738
			/* not fatal to the loop */
#line 738
			status = lstatus;
#line 738
		}
#line 738

#line 738
		(void) ncio_rel(ncp->nciop, offset,
#line 738
				 RGN_MODIFIED);
#line 738

#line 738
		remaining -= extent;
#line 738
		if(remaining == 0)
#line 738
			break; /* normal loop exit */
#line 738
		offset += (off_t)extent;
#line 738
		value += nput;
#line 738

#line 738
	}
#line 738
#ifdef ERANGE_FILL
#line 738
        free(fillp);
#line 738
#endif
#line 738

#line 738
	return status;
#line 738
}
#line 738

static int
#line 739
putNCvx_int_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 739
		 const size_t *start, size_t nelems, const ushort *value)
#line 739
{
#line 739
	off_t offset = NC_varoffset(ncp, varp, start);
#line 739
	size_t remaining = varp->xsz * nelems;
#line 739
	int status = NC_NOERR;
#line 739
	void *xp;
#line 739
        void *fillp=NULL;
#line 739

#line 739
	if(nelems == 0)
#line 739
		return NC_NOERR;
#line 739

#line 739
	assert(value != NULL);
#line 739

#line 739
#ifdef ERANGE_FILL
#line 739
        fillp = malloc(varp->xsz);
#line 739
        status = NC3_inq_var_fill(varp, fillp);
#line 739
#endif
#line 739

#line 739
	for(;;)
#line 739
	{
#line 739
		size_t extent = MIN(remaining, ncp->chunk);
#line 739
		size_t nput = ncx_howmany(varp->type, extent);
#line 739

#line 739
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 739
				 RGN_WRITE, &xp);
#line 739
		if(lstatus != NC_NOERR)
#line 739
			return lstatus;
#line 739

#line 739
		lstatus = ncx_putn_int_ushort(&xp, nput, value ,fillp);
#line 739
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 739
		{
#line 739
			/* not fatal to the loop */
#line 739
			status = lstatus;
#line 739
		}
#line 739

#line 739
		(void) ncio_rel(ncp->nciop, offset,
#line 739
				 RGN_MODIFIED);
#line 739

#line 739
		remaining -= extent;
#line 739
		if(remaining == 0)
#line 739
			break; /* normal loop exit */
#line 739
		offset += (off_t)extent;
#line 739
		value += nput;
#line 739

#line 739
	}
#line 739
#ifdef ERANGE_FILL
#line 739
        free(fillp);
#line 739
#endif
#line 739

#line 739
	return status;
#line 739
}
#line 739

static int
#line 740
putNCvx_int_uint(NC3_INFO* ncp, const NC_var *varp,
#line 740
		 const size_t *start, size_t nelems, const uint *value)
#line 740
{
#line 740
	off_t offset = NC_varoffset(ncp, varp, start);
#line 740
	size_t remaining = varp->xsz * nelems;
#line 740
	int status = NC_NOERR;
#line 740
	void *xp;
#line 740
        void *fillp=NULL;
#line 740

#line 740
	if(nelems == 0)
#line 740
		return NC_NOERR;
#line 740

#line 740
	assert(value != NULL);
#line 740

#line 740
#ifdef ERANGE_FILL
#line 740
        fillp = malloc(varp->xsz);
#line 740
        status = NC3_inq_var_fill(varp, fillp);
#line 740
#endif
#line 740

#line 740
	for(;;)
#line 740
	{
#line 740
		size_t extent = MIN(remaining, ncp->chunk);
#line 740
		size_t nput = ncx_howmany(varp->type, extent);
#line 740

#line 740
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 740
				 RGN_WRITE, &xp);
#line 740
		if(lstatus != NC_NOERR)
#line 740
			return lstatus;
#line 740

#line 740
		lstatus = ncx_putn_int_uint(&xp, nput, value ,fillp);
#line 740
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 740
		{
#line 740
			/* not fatal to the loop */
#line 740
			status = lstatus;
#line 740
		}
#line 740

#line 740
		(void) ncio_rel(ncp->nciop, offset,
#line 740
				 RGN_MODIFIED);
#line 740

#line 740
		remaining -= extent;
#line 740
		if(remaining == 0)
#line 740
			break; /* normal loop exit */
#line 740
		offset += (off_t)extent;
#line 740
		value += nput;
#line 740

#line 740
	}
#line 740
#ifdef ERANGE_FILL
#line 740
        free(fillp);
#line 740
#endif
#line 740

#line 740
	return status;
#line 740
}
#line 740

static int
#line 741
putNCvx_int_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 741
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 741
{
#line 741
	off_t offset = NC_varoffset(ncp, varp, start);
#line 741
	size_t remaining = varp->xsz * nelems;
#line 741
	int status = NC_NOERR;
#line 741
	void *xp;
#line 741
        void *fillp=NULL;
#line 741

#line 741
	if(nelems == 0)
#line 741
		return NC_NOERR;
#line 741

#line 741
	assert(value != NULL);
#line 741

#line 741
#ifdef ERANGE_FILL
#line 741
        fillp = malloc(varp->xsz);
#line 741
        status = NC3_inq_var_fill(varp, fillp);
#line 741
#endif
#line 741

#line 741
	for(;;)
#line 741
	{
#line 741
		size_t extent = MIN(remaining, ncp->chunk);
#line 741
		size_t nput = ncx_howmany(varp->type, extent);
#line 741

#line 741
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 741
				 RGN_WRITE, &xp);
#line 741
		if(lstatus != NC_NOERR)
#line 741
			return lstatus;
#line 741

#line 741
		lstatus = ncx_putn_int_ulonglong(&xp, nput, value ,fillp);
#line 741
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 741
		{
#line 741
			/* not fatal to the loop */
#line 741
			status = lstatus;
#line 741
		}
#line 741

#line 741
		(void) ncio_rel(ncp->nciop, offset,
#line 741
				 RGN_MODIFIED);
#line 741

#line 741
		remaining -= extent;
#line 741
		if(remaining == 0)
#line 741
			break; /* normal loop exit */
#line 741
		offset += (off_t)extent;
#line 741
		value += nput;
#line 741

#line 741
	}
#line 741
#ifdef ERANGE_FILL
#line 741
        free(fillp);
#line 741
#endif
#line 741

#line 741
	return status;
#line 741
}
#line 741


static int
#line 743
putNCvx_float_schar(NC3_INFO* ncp, const NC_var *varp,
#line 743
		 const size_t *start, size_t nelems, const schar *value)
#line 743
{
#line 743
	off_t offset = NC_varoffset(ncp, varp, start);
#line 743
	size_t remaining = varp->xsz * nelems;
#line 743
	int status = NC_NOERR;
#line 743
	void *xp;
#line 743
        void *fillp=NULL;
#line 743

#line 743
	if(nelems == 0)
#line 743
		return NC_NOERR;
#line 743

#line 743
	assert(value != NULL);
#line 743

#line 743
#ifdef ERANGE_FILL
#line 743
        fillp = malloc(varp->xsz);
#line 743
        status = NC3_inq_var_fill(varp, fillp);
#line 743
#endif
#line 743

#line 743
	for(;;)
#line 743
	{
#line 743
		size_t extent = MIN(remaining, ncp->chunk);
#line 743
		size_t nput = ncx_howmany(varp->type, extent);
#line 743

#line 743
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 743
				 RGN_WRITE, &xp);
#line 743
		if(lstatus != NC_NOERR)
#line 743
			return lstatus;
#line 743

#line 743
		lstatus = ncx_putn_float_schar(&xp, nput, value ,fillp);
#line 743
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 743
		{
#line 743
			/* not fatal to the loop */
#line 743
			status = lstatus;
#line 743
		}
#line 743

#line 743
		(void) ncio_rel(ncp->nciop, offset,
#line 743
				 RGN_MODIFIED);
#line 743

#line 743
		remaining -= extent;
#line 743
		if(remaining == 0)
#line 743
			break; /* normal loop exit */
#line 743
		offset += (off_t)extent;
#line 743
		value += nput;
#line 743

#line 743
	}
#line 743
#ifdef ERANGE_FILL
#line 743
        free(fillp);
#line 743
#endif
#line 743

#line 743
	return status;
#line 743
}
#line 743

static int
#line 744
putNCvx_float_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 744
		 const size_t *start, size_t nelems, const uchar *value)
#line 744
{
#line 744
	off_t offset = NC_varoffset(ncp, varp, start);
#line 744
	size_t remaining = varp->xsz * nelems;
#line 744
	int status = NC_NOERR;
#line 744
	void *xp;
#line 744
        void *fillp=NULL;
#line 744

#line 744
	if(nelems == 0)
#line 744
		return NC_NOERR;
#line 744

#line 744
	assert(value != NULL);
#line 744

#line 744
#ifdef ERANGE_FILL
#line 744
        fillp = malloc(varp->xsz);
#line 744
        status = NC3_inq_var_fill(varp, fillp);
#line 744
#endif
#line 744

#line 744
	for(;;)
#line 744
	{
#line 744
		size_t extent = MIN(remaining, ncp->chunk);
#line 744
		size_t nput = ncx_howmany(varp->type, extent);
#line 744

#line 744
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 744
				 RGN_WRITE, &xp);
#line 744
		if(lstatus != NC_NOERR)
#line 744
			return lstatus;
#line 744

#line 744
		lstatus = ncx_putn_float_uchar(&xp, nput, value ,fillp);
#line 744
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 744
		{
#line 744
			/* not fatal to the loop */
#line 744
			status = lstatus;
#line 744
		}
#line 744

#line 744
		(void) ncio_rel(ncp->nciop, offset,
#line 744
				 RGN_MODIFIED);
#line 744

#line 744
		remaining -= extent;
#line 744
		if(remaining == 0)
#line 744
			break; /* normal loop exit */
#line 744
		offset += (off_t)extent;
#line 744
		value += nput;
#line 744

#line 744
	}
#line 744
#ifdef ERANGE_FILL
#line 744
        free(fillp);
#line 744
#endif
#line 744

#line 744
	return status;
#line 744
}
#line 744

static int
#line 745
putNCvx_float_short(NC3_INFO* ncp, const NC_var *varp,
#line 745
		 const size_t *start, size_t nelems, const short *value)
#line 745
{
#line 745
	off_t offset = NC_varoffset(ncp, varp, start);
#line 745
	size_t remaining = varp->xsz * nelems;
#line 745
	int status = NC_NOERR;
#line 745
	void *xp;
#line 745
        void *fillp=NULL;
#line 745

#line 745
	if(nelems == 0)
#line 745
		return NC_NOERR;
#line 745

#line 745
	assert(value != NULL);
#line 745

#line 745
#ifdef ERANGE_FILL
#line 745
        fillp = malloc(varp->xsz);
#line 745
        status = NC3_inq_var_fill(varp, fillp);
#line 745
#endif
#line 745

#line 745
	for(;;)
#line 745
	{
#line 745
		size_t extent = MIN(remaining, ncp->chunk);
#line 745
		size_t nput = ncx_howmany(varp->type, extent);
#line 745

#line 745
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 745
				 RGN_WRITE, &xp);
#line 745
		if(lstatus != NC_NOERR)
#line 745
			return lstatus;
#line 745

#line 745
		lstatus = ncx_putn_float_short(&xp, nput, value ,fillp);
#line 745
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 745
		{
#line 745
			/* not fatal to the loop */
#line 745
			status = lstatus;
#line 745
		}
#line 745

#line 745
		(void) ncio_rel(ncp->nciop, offset,
#line 745
				 RGN_MODIFIED);
#line 745

#line 745
		remaining -= extent;
#line 745
		if(remaining == 0)
#line 745
			break; /* normal loop exit */
#line 745
		offset += (off_t)extent;
#line 745
		value += nput;
#line 745

#line 745
	}
#line 745
#ifdef ERANGE_FILL
#line 745
        free(fillp);
#line 745
#endif
#line 745

#line 745
	return status;
#line 745
}
#line 745

static int
#line 746
putNCvx_float_int(NC3_INFO* ncp, const NC_var *varp,
#line 746
		 const size_t *start, size_t nelems, const int *value)
#line 746
{
#line 746
	off_t offset = NC_varoffset(ncp, varp, start);
#line 746
	size_t remaining = varp->xsz * nelems;
#line 746
	int status = NC_NOERR;
#line 746
	void *xp;
#line 746
        void *fillp=NULL;
#line 746

#line 746
	if(nelems == 0)
#line 746
		return NC_NOERR;
#line 746

#line 746
	assert(value != NULL);
#line 746

#line 746
#ifdef ERANGE_FILL
#line 746
        fillp = malloc(varp->xsz);
#line 746
        status = NC3_inq_var_fill(varp, fillp);
#line 746
#endif
#line 746

#line 746
	for(;;)
#line 746
	{
#line 746
		size_t extent = MIN(remaining, ncp->chunk);
#line 746
		size_t nput = ncx_howmany(varp->type, extent);
#line 746

#line 746
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 746
				 RGN_WRITE, &xp);
#line 746
		if(lstatus != NC_NOERR)
#line 746
			return lstatus;
#line 746

#line 746
		lstatus = ncx_putn_float_int(&xp, nput, value ,fillp);
#line 746
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 746
		{
#line 746
			/* not fatal to the loop */
#line 746
			status = lstatus;
#line 746
		}
#line 746

#line 746
		(void) ncio_rel(ncp->nciop, offset,
#line 746
				 RGN_MODIFIED);
#line 746

#line 746
		remaining -= extent;
#line 746
		if(remaining == 0)
#line 746
			break; /* normal loop exit */
#line 746
		offset += (off_t)extent;
#line 746
		value += nput;
#line 746

#line 746
	}
#line 746
#ifdef ERANGE_FILL
#line 746
        free(fillp);
#line 746
#endif
#line 746

#line 746
	return status;
#line 746
}
#line 746

static int
#line 747
putNCvx_float_float(NC3_INFO* ncp, const NC_var *varp,
#line 747
		 const size_t *start, size_t nelems, const float *value)
#line 747
{
#line 747
	off_t offset = NC_varoffset(ncp, varp, start);
#line 747
	size_t remaining = varp->xsz * nelems;
#line 747
	int status = NC_NOERR;
#line 747
	void *xp;
#line 747
        void *fillp=NULL;
#line 747

#line 747
	if(nelems == 0)
#line 747
		return NC_NOERR;
#line 747

#line 747
	assert(value != NULL);
#line 747

#line 747
#ifdef ERANGE_FILL
#line 747
        fillp = malloc(varp->xsz);
#line 747
        status = NC3_inq_var_fill(varp, fillp);
#line 747
#endif
#line 747

#line 747
	for(;;)
#line 747
	{
#line 747
		size_t extent = MIN(remaining, ncp->chunk);
#line 747
		size_t nput = ncx_howmany(varp->type, extent);
#line 747

#line 747
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 747
				 RGN_WRITE, &xp);
#line 747
		if(lstatus != NC_NOERR)
#line 747
			return lstatus;
#line 747

#line 747
		lstatus = ncx_putn_float_float(&xp, nput, value ,fillp);
#line 747
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 747
		{
#line 747
			/* not fatal to the loop */
#line 747
			status = lstatus;
#line 747
		}
#line 747

#line 747
		(void) ncio_rel(ncp->nciop, offset,
#line 747
				 RGN_MODIFIED);
#line 747

#line 747
		remaining -= extent;
#line 747
		if(remaining == 0)
#line 747
			break; /* normal loop exit */
#line 747
		offset += (off_t)extent;
#line 747
		value += nput;
#line 747

#line 747
	}
#line 747
#ifdef ERANGE_FILL
#line 747
        free(fillp);
#line 747
#endif
#line 747

#line 747
	return status;
#line 747
}
#line 747

static int
#line 748
putNCvx_float_double(NC3_INFO* ncp, const NC_var *varp,
#line 748
		 const size_t *start, size_t nelems, const double *value)
#line 748
{
#line 748
	off_t offset = NC_varoffset(ncp, varp, start);
#line 748
	size_t remaining = varp->xsz * nelems;
#line 748
	int status = NC_NOERR;
#line 748
	void *xp;
#line 748
        void *fillp=NULL;
#line 748

#line 748
	if(nelems == 0)
#line 748
		return NC_NOERR;
#line 748

#line 748
	assert(value != NULL);
#line 748

#line 748
#ifdef ERANGE_FILL
#line 748
        fillp = malloc(varp->xsz);
#line 748
        status = NC3_inq_var_fill(varp, fillp);
#line 748
#endif
#line 748

#line 748
	for(;;)
#line 748
	{
#line 748
		size_t extent = MIN(remaining, ncp->chunk);
#line 748
		size_t nput = ncx_howmany(varp->type, extent);
#line 748

#line 748
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 748
				 RGN_WRITE, &xp);
#line 748
		if(lstatus != NC_NOERR)
#line 748
			return lstatus;
#line 748

#line 748
		lstatus = ncx_putn_float_double(&xp, nput, value ,fillp);
#line 748
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 748
		{
#line 748
			/* not fatal to the loop */
#line 748
			status = lstatus;
#line 748
		}
#line 748

#line 748
		(void) ncio_rel(ncp->nciop, offset,
#line 748
				 RGN_MODIFIED);
#line 748

#line 748
		remaining -= extent;
#line 748
		if(remaining == 0)
#line 748
			break; /* normal loop exit */
#line 748
		offset += (off_t)extent;
#line 748
		value += nput;
#line 748

#line 748
	}
#line 748
#ifdef ERANGE_FILL
#line 748
        free(fillp);
#line 748
#endif
#line 748

#line 748
	return status;
#line 748
}
#line 748

static int
#line 749
putNCvx_float_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 749
		 const size_t *start, size_t nelems, const longlong *value)
#line 749
{
#line 749
	off_t offset = NC_varoffset(ncp, varp, start);
#line 749
	size_t remaining = varp->xsz * nelems;
#line 749
	int status = NC_NOERR;
#line 749
	void *xp;
#line 749
        void *fillp=NULL;
#line 749

#line 749
	if(nelems == 0)
#line 749
		return NC_NOERR;
#line 749

#line 749
	assert(value != NULL);
#line 749

#line 749
#ifdef ERANGE_FILL
#line 749
        fillp = malloc(varp->xsz);
#line 749
        status = NC3_inq_var_fill(varp, fillp);
#line 749
#endif
#line 749

#line 749
	for(;;)
#line 749
	{
#line 749
		size_t extent = MIN(remaining, ncp->chunk);
#line 749
		size_t nput = ncx_howmany(varp->type, extent);
#line 749

#line 749
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 749
				 RGN_WRITE, &xp);
#line 749
		if(lstatus != NC_NOERR)
#line 749
			return lstatus;
#line 749

#line 749
		lstatus = ncx_putn_float_longlong(&xp, nput, value ,fillp);
#line 749
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 749
		{
#line 749
			/* not fatal to the loop */
#line 749
			status = lstatus;
#line 749
		}
#line 749

#line 749
		(void) ncio_rel(ncp->nciop, offset,
#line 749
				 RGN_MODIFIED);
#line 749

#line 749
		remaining -= extent;
#line 749
		if(remaining == 0)
#line 749
			break; /* normal loop exit */
#line 749
		offset += (off_t)extent;
#line 749
		value += nput;
#line 749

#line 749
	}
#line 749
#ifdef ERANGE_FILL
#line 749
        free(fillp);
#line 749
#endif
#line 749

#line 749
	return status;
#line 749
}
#line 749

static int
#line 750
putNCvx_float_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 750
		 const size_t *start, size_t nelems, const ushort *value)
#line 750
{
#line 750
	off_t offset = NC_varoffset(ncp, varp, start);
#line 750
	size_t remaining = varp->xsz * nelems;
#line 750
	int status = NC_NOERR;
#line 750
	void *xp;
#line 750
        void *fillp=NULL;
#line 750

#line 750
	if(nelems == 0)
#line 750
		return NC_NOERR;
#line 750

#line 750
	assert(value != NULL);
#line 750

#line 750
#ifdef ERANGE_FILL
#line 750
        fillp = malloc(varp->xsz);
#line 750
        status = NC3_inq_var_fill(varp, fillp);
#line 750
#endif
#line 750

#line 750
	for(;;)
#line 750
	{
#line 750
		size_t extent = MIN(remaining, ncp->chunk);
#line 750
		size_t nput = ncx_howmany(varp->type, extent);
#line 750

#line 750
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 750
				 RGN_WRITE, &xp);
#line 750
		if(lstatus != NC_NOERR)
#line 750
			return lstatus;
#line 750

#line 750
		lstatus = ncx_putn_float_ushort(&xp, nput, value ,fillp);
#line 750
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 750
		{
#line 750
			/* not fatal to the loop */
#line 750
			status = lstatus;
#line 750
		}
#line 750

#line 750
		(void) ncio_rel(ncp->nciop, offset,
#line 750
				 RGN_MODIFIED);
#line 750

#line 750
		remaining -= extent;
#line 750
		if(remaining == 0)
#line 750
			break; /* normal loop exit */
#line 750
		offset += (off_t)extent;
#line 750
		value += nput;
#line 750

#line 750
	}
#line 750
#ifdef ERANGE_FILL
#line 750
        free(fillp);
#line 750
#endif
#line 750

#line 750
	return status;
#line 750
}
#line 750

static int
#line 751
putNCvx_float_uint(NC3_INFO* ncp, const NC_var *varp,
#line 751
		 const size_t *start, size_t nelems, const uint *value)
#line 751
{
#line 751
	off_t offset = NC_varoffset(ncp, varp, start);
#line 751
	size_t remaining = varp->xsz * nelems;
#line 751
	int status = NC_NOERR;
#line 751
	void *xp;
#line 751
        void *fillp=NULL;
#line 751

#line 751
	if(nelems == 0)
#line 751
		return NC_NOERR;
#line 751

#line 751
	assert(value != NULL);
#line 751

#line 751
#ifdef ERANGE_FILL
#line 751
        fillp = malloc(varp->xsz);
#line 751
        status = NC3_inq_var_fill(varp, fillp);
#line 751
#endif
#line 751

#line 751
	for(;;)
#line 751
	{
#line 751
		size_t extent = MIN(remaining, ncp->chunk);
#line 751
		size_t nput = ncx_howmany(varp->type, extent);
#line 751

#line 751
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 751
				 RGN_WRITE, &xp);
#line 751
		if(lstatus != NC_NOERR)
#line 751
			return lstatus;
#line 751

#line 751
		lstatus = ncx_putn_float_uint(&xp, nput, value ,fillp);
#line 751
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 751
		{
#line 751
			/* not fatal to the loop */
#line 751
			status = lstatus;
#line 751
		}
#line 751

#line 751
		(void) ncio_rel(ncp->nciop, offset,
#line 751
				 RGN_MODIFIED);
#line 751

#line 751
		remaining -= extent;
#line 751
		if(remaining == 0)
#line 751
			break; /* normal loop exit */
#line 751
		offset += (off_t)extent;
#line 751
		value += nput;
#line 751

#line 751
	}
#line 751
#ifdef ERANGE_FILL
#line 751
        free(fillp);
#line 751
#endif
#line 751

#line 751
	return status;
#line 751
}
#line 751

static int
#line 752
putNCvx_float_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 752
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 752
{
#line 752
	off_t offset = NC_varoffset(ncp, varp, start);
#line 752
	size_t remaining = varp->xsz * nelems;
#line 752
	int status = NC_NOERR;
#line 752
	void *xp;
#line 752
        void *fillp=NULL;
#line 752

#line 752
	if(nelems == 0)
#line 752
		return NC_NOERR;
#line 752

#line 752
	assert(value != NULL);
#line 752

#line 752
#ifdef ERANGE_FILL
#line 752
        fillp = malloc(varp->xsz);
#line 752
        status = NC3_inq_var_fill(varp, fillp);
#line 752
#endif
#line 752

#line 752
	for(;;)
#line 752
	{
#line 752
		size_t extent = MIN(remaining, ncp->chunk);
#line 752
		size_t nput = ncx_howmany(varp->type, extent);
#line 752

#line 752
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 752
				 RGN_WRITE, &xp);
#line 752
		if(lstatus != NC_NOERR)
#line 752
			return lstatus;
#line 752

#line 752
		lstatus = ncx_putn_float_ulonglong(&xp, nput, value ,fillp);
#line 752
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 752
		{
#line 752
			/* not fatal to the loop */
#line 752
			status = lstatus;
#line 752
		}
#line 752

#line 752
		(void) ncio_rel(ncp->nciop, offset,
#line 752
				 RGN_MODIFIED);
#line 752

#line 752
		remaining -= extent;
#line 752
		if(remaining == 0)
#line 752
			break; /* normal loop exit */
#line 752
		offset += (off_t)extent;
#line 752
		value += nput;
#line 752

#line 752
	}
#line 752
#ifdef ERANGE_FILL
#line 752
        free(fillp);
#line 752
#endif
#line 752

#line 752
	return status;
#line 752
}
#line 752


static int
#line 754
putNCvx_double_schar(NC3_INFO* ncp, const NC_var *varp,
#line 754
		 const size_t *start, size_t nelems, const schar *value)
#line 754
{
#line 754
	off_t offset = NC_varoffset(ncp, varp, start);
#line 754
	size_t remaining = varp->xsz * nelems;
#line 754
	int status = NC_NOERR;
#line 754
	void *xp;
#line 754
        void *fillp=NULL;
#line 754

#line 754
	if(nelems == 0)
#line 754
		return NC_NOERR;
#line 754

#line 754
	assert(value != NULL);
#line 754

#line 754
#ifdef ERANGE_FILL
#line 754
        fillp = malloc(varp->xsz);
#line 754
        status = NC3_inq_var_fill(varp, fillp);
#line 754
#endif
#line 754

#line 754
	for(;;)
#line 754
	{
#line 754
		size_t extent = MIN(remaining, ncp->chunk);
#line 754
		size_t nput = ncx_howmany(varp->type, extent);
#line 754

#line 754
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 754
				 RGN_WRITE, &xp);
#line 754
		if(lstatus != NC_NOERR)
#line 754
			return lstatus;
#line 754

#line 754
		lstatus = ncx_putn_double_schar(&xp, nput, value ,fillp);
#line 754
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 754
		{
#line 754
			/* not fatal to the loop */
#line 754
			status = lstatus;
#line 754
		}
#line 754

#line 754
		(void) ncio_rel(ncp->nciop, offset,
#line 754
				 RGN_MODIFIED);
#line 754

#line 754
		remaining -= extent;
#line 754
		if(remaining == 0)
#line 754
			break; /* normal loop exit */
#line 754
		offset += (off_t)extent;
#line 754
		value += nput;
#line 754

#line 754
	}
#line 754
#ifdef ERANGE_FILL
#line 754
        free(fillp);
#line 754
#endif
#line 754

#line 754
	return status;
#line 754
}
#line 754

static int
#line 755
putNCvx_double_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 755
		 const size_t *start, size_t nelems, const uchar *value)
#line 755
{
#line 755
	off_t offset = NC_varoffset(ncp, varp, start);
#line 755
	size_t remaining = varp->xsz * nelems;
#line 755
	int status = NC_NOERR;
#line 755
	void *xp;
#line 755
        void *fillp=NULL;
#line 755

#line 755
	if(nelems == 0)
#line 755
		return NC_NOERR;
#line 755

#line 755
	assert(value != NULL);
#line 755

#line 755
#ifdef ERANGE_FILL
#line 755
        fillp = malloc(varp->xsz);
#line 755
        status = NC3_inq_var_fill(varp, fillp);
#line 755
#endif
#line 755

#line 755
	for(;;)
#line 755
	{
#line 755
		size_t extent = MIN(remaining, ncp->chunk);
#line 755
		size_t nput = ncx_howmany(varp->type, extent);
#line 755

#line 755
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 755
				 RGN_WRITE, &xp);
#line 755
		if(lstatus != NC_NOERR)
#line 755
			return lstatus;
#line 755

#line 755
		lstatus = ncx_putn_double_uchar(&xp, nput, value ,fillp);
#line 755
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 755
		{
#line 755
			/* not fatal to the loop */
#line 755
			status = lstatus;
#line 755
		}
#line 755

#line 755
		(void) ncio_rel(ncp->nciop, offset,
#line 755
				 RGN_MODIFIED);
#line 755

#line 755
		remaining -= extent;
#line 755
		if(remaining == 0)
#line 755
			break; /* normal loop exit */
#line 755
		offset += (off_t)extent;
#line 755
		value += nput;
#line 755

#line 755
	}
#line 755
#ifdef ERANGE_FILL
#line 755
        free(fillp);
#line 755
#endif
#line 755

#line 755
	return status;
#line 755
}
#line 755

static int
#line 756
putNCvx_double_short(NC3_INFO* ncp, const NC_var *varp,
#line 756
		 const size_t *start, size_t nelems, const short *value)
#line 756
{
#line 756
	off_t offset = NC_varoffset(ncp, varp, start);
#line 756
	size_t remaining = varp->xsz * nelems;
#line 756
	int status = NC_NOERR;
#line 756
	void *xp;
#line 756
        void *fillp=NULL;
#line 756

#line 756
	if(nelems == 0)
#line 756
		return NC_NOERR;
#line 756

#line 756
	assert(value != NULL);
#line 756

#line 756
#ifdef ERANGE_FILL
#line 756
        fillp = malloc(varp->xsz);
#line 756
        status = NC3_inq_var_fill(varp, fillp);
#line 756
#endif
#line 756

#line 756
	for(;;)
#line 756
	{
#line 756
		size_t extent = MIN(remaining, ncp->chunk);
#line 756
		size_t nput = ncx_howmany(varp->type, extent);
#line 756

#line 756
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 756
				 RGN_WRITE, &xp);
#line 756
		if(lstatus != NC_NOERR)
#line 756
			return lstatus;
#line 756

#line 756
		lstatus = ncx_putn_double_short(&xp, nput, value ,fillp);
#line 756
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 756
		{
#line 756
			/* not fatal to the loop */
#line 756
			status = lstatus;
#line 756
		}
#line 756

#line 756
		(void) ncio_rel(ncp->nciop, offset,
#line 756
				 RGN_MODIFIED);
#line 756

#line 756
		remaining -= extent;
#line 756
		if(remaining == 0)
#line 756
			break; /* normal loop exit */
#line 756
		offset += (off_t)extent;
#line 756
		value += nput;
#line 756

#line 756
	}
#line 756
#ifdef ERANGE_FILL
#line 756
        free(fillp);
#line 756
#endif
#line 756

#line 756
	return status;
#line 756
}
#line 756

static int
#line 757
putNCvx_double_int(NC3_INFO* ncp, const NC_var *varp,
#line 757
		 const size_t *start, size_t nelems, const int *value)
#line 757
{
#line 757
	off_t offset = NC_varoffset(ncp, varp, start);
#line 757
	size_t remaining = varp->xsz * nelems;
#line 757
	int status = NC_NOERR;
#line 757
	void *xp;
#line 757
        void *fillp=NULL;
#line 757

#line 757
	if(nelems == 0)
#line 757
		return NC_NOERR;
#line 757

#line 757
	assert(value != NULL);
#line 757

#line 757
#ifdef ERANGE_FILL
#line 757
        fillp = malloc(varp->xsz);
#line 757
        status = NC3_inq_var_fill(varp, fillp);
#line 757
#endif
#line 757

#line 757
	for(;;)
#line 757
	{
#line 757
		size_t extent = MIN(remaining, ncp->chunk);
#line 757
		size_t nput = ncx_howmany(varp->type, extent);
#line 757

#line 757
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 757
				 RGN_WRITE, &xp);
#line 757
		if(lstatus != NC_NOERR)
#line 757
			return lstatus;
#line 757

#line 757
		lstatus = ncx_putn_double_int(&xp, nput, value ,fillp);
#line 757
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 757
		{
#line 757
			/* not fatal to the loop */
#line 757
			status = lstatus;
#line 757
		}
#line 757

#line 757
		(void) ncio_rel(ncp->nciop, offset,
#line 757
				 RGN_MODIFIED);
#line 757

#line 757
		remaining -= extent;
#line 757
		if(remaining == 0)
#line 757
			break; /* normal loop exit */
#line 757
		offset += (off_t)extent;
#line 757
		value += nput;
#line 757

#line 757
	}
#line 757
#ifdef ERANGE_FILL
#line 757
        free(fillp);
#line 757
#endif
#line 757

#line 757
	return status;
#line 757
}
#line 757

static int
#line 758
putNCvx_double_float(NC3_INFO* ncp, const NC_var *varp,
#line 758
		 const size_t *start, size_t nelems, const float *value)
#line 758
{
#line 758
	off_t offset = NC_varoffset(ncp, varp, start);
#line 758
	size_t remaining = varp->xsz * nelems;
#line 758
	int status = NC_NOERR;
#line 758
	void *xp;
#line 758
        void *fillp=NULL;
#line 758

#line 758
	if(nelems == 0)
#line 758
		return NC_NOERR;
#line 758

#line 758
	assert(value != NULL);
#line 758

#line 758
#ifdef ERANGE_FILL
#line 758
        fillp = malloc(varp->xsz);
#line 758
        status = NC3_inq_var_fill(varp, fillp);
#line 758
#endif
#line 758

#line 758
	for(;;)
#line 758
	{
#line 758
		size_t extent = MIN(remaining, ncp->chunk);
#line 758
		size_t nput = ncx_howmany(varp->type, extent);
#line 758

#line 758
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 758
				 RGN_WRITE, &xp);
#line 758
		if(lstatus != NC_NOERR)
#line 758
			return lstatus;
#line 758

#line 758
		lstatus = ncx_putn_double_float(&xp, nput, value ,fillp);
#line 758
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 758
		{
#line 758
			/* not fatal to the loop */
#line 758
			status = lstatus;
#line 758
		}
#line 758

#line 758
		(void) ncio_rel(ncp->nciop, offset,
#line 758
				 RGN_MODIFIED);
#line 758

#line 758
		remaining -= extent;
#line 758
		if(remaining == 0)
#line 758
			break; /* normal loop exit */
#line 758
		offset += (off_t)extent;
#line 758
		value += nput;
#line 758

#line 758
	}
#line 758
#ifdef ERANGE_FILL
#line 758
        free(fillp);
#line 758
#endif
#line 758

#line 758
	return status;
#line 758
}
#line 758

static int
#line 759
putNCvx_double_double(NC3_INFO* ncp, const NC_var *varp,
#line 759
		 const size_t *start, size_t nelems, const double *value)
#line 759
{
#line 759
	off_t offset = NC_varoffset(ncp, varp, start);
#line 759
	size_t remaining = varp->xsz * nelems;
#line 759
	int status = NC_NOERR;
#line 759
	void *xp;
#line 759
        void *fillp=NULL;
#line 759

#line 759
	if(nelems == 0)
#line 759
		return NC_NOERR;
#line 759

#line 759
	assert(value != NULL);
#line 759

#line 759
#ifdef ERANGE_FILL
#line 759
        fillp = malloc(varp->xsz);
#line 759
        status = NC3_inq_var_fill(varp, fillp);
#line 759
#endif
#line 759

#line 759
	for(;;)
#line 759
	{
#line 759
		size_t extent = MIN(remaining, ncp->chunk);
#line 759
		size_t nput = ncx_howmany(varp->type, extent);
#line 759

#line 759
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 759
				 RGN_WRITE, &xp);
#line 759
		if(lstatus != NC_NOERR)
#line 759
			return lstatus;
#line 759

#line 759
		lstatus = ncx_putn_double_double(&xp, nput, value ,fillp);
#line 759
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 759
		{
#line 759
			/* not fatal to the loop */
#line 759
			status = lstatus;
#line 759
		}
#line 759

#line 759
		(void) ncio_rel(ncp->nciop, offset,
#line 759
				 RGN_MODIFIED);
#line 759

#line 759
		remaining -= extent;
#line 759
		if(remaining == 0)
#line 759
			break; /* normal loop exit */
#line 759
		offset += (off_t)extent;
#line 759
		value += nput;
#line 759

#line 759
	}
#line 759
#ifdef ERANGE_FILL
#line 759
        free(fillp);
#line 759
#endif
#line 759

#line 759
	return status;
#line 759
}
#line 759

static int
#line 760
putNCvx_double_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 760
		 const size_t *start, size_t nelems, const longlong *value)
#line 760
{
#line 760
	off_t offset = NC_varoffset(ncp, varp, start);
#line 760
	size_t remaining = varp->xsz * nelems;
#line 760
	int status = NC_NOERR;
#line 760
	void *xp;
#line 760
        void *fillp=NULL;
#line 760

#line 760
	if(nelems == 0)
#line 760
		return NC_NOERR;
#line 760

#line 760
	assert(value != NULL);
#line 760

#line 760
#ifdef ERANGE_FILL
#line 760
        fillp = malloc(varp->xsz);
#line 760
        status = NC3_inq_var_fill(varp, fillp);
#line 760
#endif
#line 760

#line 760
	for(;;)
#line 760
	{
#line 760
		size_t extent = MIN(remaining, ncp->chunk);
#line 760
		size_t nput = ncx_howmany(varp->type, extent);
#line 760

#line 760
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 760
				 RGN_WRITE, &xp);
#line 760
		if(lstatus != NC_NOERR)
#line 760
			return lstatus;
#line 760

#line 760
		lstatus = ncx_putn_double_longlong(&xp, nput, value ,fillp);
#line 760
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 760
		{
#line 760
			/* not fatal to the loop */
#line 760
			status = lstatus;
#line 760
		}
#line 760

#line 760
		(void) ncio_rel(ncp->nciop, offset,
#line 760
				 RGN_MODIFIED);
#line 760

#line 760
		remaining -= extent;
#line 760
		if(remaining == 0)
#line 760
			break; /* normal loop exit */
#line 760
		offset += (off_t)extent;
#line 760
		value += nput;
#line 760

#line 760
	}
#line 760
#ifdef ERANGE_FILL
#line 760
        free(fillp);
#line 760
#endif
#line 760

#line 760
	return status;
#line 760
}
#line 760

static int
#line 761
putNCvx_double_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 761
		 const size_t *start, size_t nelems, const ushort *value)
#line 761
{
#line 761
	off_t offset = NC_varoffset(ncp, varp, start);
#line 761
	size_t remaining = varp->xsz * nelems;
#line 761
	int status = NC_NOERR;
#line 761
	void *xp;
#line 761
        void *fillp=NULL;
#line 761

#line 761
	if(nelems == 0)
#line 761
		return NC_NOERR;
#line 761

#line 761
	assert(value != NULL);
#line 761

#line 761
#ifdef ERANGE_FILL
#line 761
        fillp = malloc(varp->xsz);
#line 761
        status = NC3_inq_var_fill(varp, fillp);
#line 761
#endif
#line 761

#line 761
	for(;;)
#line 761
	{
#line 761
		size_t extent = MIN(remaining, ncp->chunk);
#line 761
		size_t nput = ncx_howmany(varp->type, extent);
#line 761

#line 761
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 761
				 RGN_WRITE, &xp);
#line 761
		if(lstatus != NC_NOERR)
#line 761
			return lstatus;
#line 761

#line 761
		lstatus = ncx_putn_double_ushort(&xp, nput, value ,fillp);
#line 761
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 761
		{
#line 761
			/* not fatal to the loop */
#line 761
			status = lstatus;
#line 761
		}
#line 761

#line 761
		(void) ncio_rel(ncp->nciop, offset,
#line 761
				 RGN_MODIFIED);
#line 761

#line 761
		remaining -= extent;
#line 761
		if(remaining == 0)
#line 761
			break; /* normal loop exit */
#line 761
		offset += (off_t)extent;
#line 761
		value += nput;
#line 761

#line 761
	}
#line 761
#ifdef ERANGE_FILL
#line 761
        free(fillp);
#line 761
#endif
#line 761

#line 761
	return status;
#line 761
}
#line 761

static int
#line 762
putNCvx_double_uint(NC3_INFO* ncp, const NC_var *varp,
#line 762
		 const size_t *start, size_t nelems, const uint *value)
#line 762
{
#line 762
	off_t offset = NC_varoffset(ncp, varp, start);
#line 762
	size_t remaining = varp->xsz * nelems;
#line 762
	int status = NC_NOERR;
#line 762
	void *xp;
#line 762
        void *fillp=NULL;
#line 762

#line 762
	if(nelems == 0)
#line 762
		return NC_NOERR;
#line 762

#line 762
	assert(value != NULL);
#line 762

#line 762
#ifdef ERANGE_FILL
#line 762
        fillp = malloc(varp->xsz);
#line 762
        status = NC3_inq_var_fill(varp, fillp);
#line 762
#endif
#line 762

#line 762
	for(;;)
#line 762
	{
#line 762
		size_t extent = MIN(remaining, ncp->chunk);
#line 762
		size_t nput = ncx_howmany(varp->type, extent);
#line 762

#line 762
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 762
				 RGN_WRITE, &xp);
#line 762
		if(lstatus != NC_NOERR)
#line 762
			return lstatus;
#line 762

#line 762
		lstatus = ncx_putn_double_uint(&xp, nput, value ,fillp);
#line 762
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 762
		{
#line 762
			/* not fatal to the loop */
#line 762
			status = lstatus;
#line 762
		}
#line 762

#line 762
		(void) ncio_rel(ncp->nciop, offset,
#line 762
				 RGN_MODIFIED);
#line 762

#line 762
		remaining -= extent;
#line 762
		if(remaining == 0)
#line 762
			break; /* normal loop exit */
#line 762
		offset += (off_t)extent;
#line 762
		value += nput;
#line 762

#line 762
	}
#line 762
#ifdef ERANGE_FILL
#line 762
        free(fillp);
#line 762
#endif
#line 762

#line 762
	return status;
#line 762
}
#line 762

static int
#line 763
putNCvx_double_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 763
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 763
{
#line 763
	off_t offset = NC_varoffset(ncp, varp, start);
#line 763
	size_t remaining = varp->xsz * nelems;
#line 763
	int status = NC_NOERR;
#line 763
	void *xp;
#line 763
        void *fillp=NULL;
#line 763

#line 763
	if(nelems == 0)
#line 763
		return NC_NOERR;
#line 763

#line 763
	assert(value != NULL);
#line 763

#line 763
#ifdef ERANGE_FILL
#line 763
        fillp = malloc(varp->xsz);
#line 763
        status = NC3_inq_var_fill(varp, fillp);
#line 763
#endif
#line 763

#line 763
	for(;;)
#line 763
	{
#line 763
		size_t extent = MIN(remaining, ncp->chunk);
#line 763
		size_t nput = ncx_howmany(varp->type, extent);
#line 763

#line 763
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 763
				 RGN_WRITE, &xp);
#line 763
		if(lstatus != NC_NOERR)
#line 763
			return lstatus;
#line 763

#line 763
		lstatus = ncx_putn_double_ulonglong(&xp, nput, value ,fillp);
#line 763
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 763
		{
#line 763
			/* not fatal to the loop */
#line 763
			status = lstatus;
#line 763
		}
#line 763

#line 763
		(void) ncio_rel(ncp->nciop, offset,
#line 763
				 RGN_MODIFIED);
#line 763

#line 763
		remaining -= extent;
#line 763
		if(remaining == 0)
#line 763
			break; /* normal loop exit */
#line 763
		offset += (off_t)extent;
#line 763
		value += nput;
#line 763

#line 763
	}
#line 763
#ifdef ERANGE_FILL
#line 763
        free(fillp);
#line 763
#endif
#line 763

#line 763
	return status;
#line 763
}
#line 763


static int
#line 765
putNCvx_uchar_schar(NC3_INFO* ncp, const NC_var *varp,
#line 765
		 const size_t *start, size_t nelems, const schar *value)
#line 765
{
#line 765
	off_t offset = NC_varoffset(ncp, varp, start);
#line 765
	size_t remaining = varp->xsz * nelems;
#line 765
	int status = NC_NOERR;
#line 765
	void *xp;
#line 765
        void *fillp=NULL;
#line 765

#line 765
	if(nelems == 0)
#line 765
		return NC_NOERR;
#line 765

#line 765
	assert(value != NULL);
#line 765

#line 765
#ifdef ERANGE_FILL
#line 765
        fillp = malloc(varp->xsz);
#line 765
        status = NC3_inq_var_fill(varp, fillp);
#line 765
#endif
#line 765

#line 765
	for(;;)
#line 765
	{
#line 765
		size_t extent = MIN(remaining, ncp->chunk);
#line 765
		size_t nput = ncx_howmany(varp->type, extent);
#line 765

#line 765
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 765
				 RGN_WRITE, &xp);
#line 765
		if(lstatus != NC_NOERR)
#line 765
			return lstatus;
#line 765

#line 765
		lstatus = ncx_putn_uchar_schar(&xp, nput, value ,fillp);
#line 765
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 765
		{
#line 765
			/* not fatal to the loop */
#line 765
			status = lstatus;
#line 765
		}
#line 765

#line 765
		(void) ncio_rel(ncp->nciop, offset,
#line 765
				 RGN_MODIFIED);
#line 765

#line 765
		remaining -= extent;
#line 765
		if(remaining == 0)
#line 765
			break; /* normal loop exit */
#line 765
		offset += (off_t)extent;
#line 765
		value += nput;
#line 765

#line 765
	}
#line 765
#ifdef ERANGE_FILL
#line 765
        free(fillp);
#line 765
#endif
#line 765

#line 765
	return status;
#line 765
}
#line 765

static int
#line 766
putNCvx_uchar_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 766
		 const size_t *start, size_t nelems, const uchar *value)
#line 766
{
#line 766
	off_t offset = NC_varoffset(ncp, varp, start);
#line 766
	size_t remaining = varp->xsz * nelems;
#line 766
	int status = NC_NOERR;
#line 766
	void *xp;
#line 766
        void *fillp=NULL;
#line 766

#line 766
	if(nelems == 0)
#line 766
		return NC_NOERR;
#line 766

#line 766
	assert(value != NULL);
#line 766

#line 766
#ifdef ERANGE_FILL
#line 766
        fillp = malloc(varp->xsz);
#line 766
        status = NC3_inq_var_fill(varp, fillp);
#line 766
#endif
#line 766

#line 766
	for(;;)
#line 766
	{
#line 766
		size_t extent = MIN(remaining, ncp->chunk);
#line 766
		size_t nput = ncx_howmany(varp->type, extent);
#line 766

#line 766
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 766
				 RGN_WRITE, &xp);
#line 766
		if(lstatus != NC_NOERR)
#line 766
			return lstatus;
#line 766

#line 766
		lstatus = ncx_putn_uchar_uchar(&xp, nput, value ,fillp);
#line 766
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 766
		{
#line 766
			/* not fatal to the loop */
#line 766
			status = lstatus;
#line 766
		}
#line 766

#line 766
		(void) ncio_rel(ncp->nciop, offset,
#line 766
				 RGN_MODIFIED);
#line 766

#line 766
		remaining -= extent;
#line 766
		if(remaining == 0)
#line 766
			break; /* normal loop exit */
#line 766
		offset += (off_t)extent;
#line 766
		value += nput;
#line 766

#line 766
	}
#line 766
#ifdef ERANGE_FILL
#line 766
        free(fillp);
#line 766
#endif
#line 766

#line 766
	return status;
#line 766
}
#line 766

static int
#line 767
putNCvx_uchar_short(NC3_INFO* ncp, const NC_var *varp,
#line 767
		 const size_t *start, size_t nelems, const short *value)
#line 767
{
#line 767
	off_t offset = NC_varoffset(ncp, varp, start);
#line 767
	size_t remaining = varp->xsz * nelems;
#line 767
	int status = NC_NOERR;
#line 767
	void *xp;
#line 767
        void *fillp=NULL;
#line 767

#line 767
	if(nelems == 0)
#line 767
		return NC_NOERR;
#line 767

#line 767
	assert(value != NULL);
#line 767

#line 767
#ifdef ERANGE_FILL
#line 767
        fillp = malloc(varp->xsz);
#line 767
        status = NC3_inq_var_fill(varp, fillp);
#line 767
#endif
#line 767

#line 767
	for(;;)
#line 767
	{
#line 767
		size_t extent = MIN(remaining, ncp->chunk);
#line 767
		size_t nput = ncx_howmany(varp->type, extent);
#line 767

#line 767
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 767
				 RGN_WRITE, &xp);
#line 767
		if(lstatus != NC_NOERR)
#line 767
			return lstatus;
#line 767

#line 767
		lstatus = ncx_putn_uchar_short(&xp, nput, value ,fillp);
#line 767
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 767
		{
#line 767
			/* not fatal to the loop */
#line 767
			status = lstatus;
#line 767
		}
#line 767

#line 767
		(void) ncio_rel(ncp->nciop, offset,
#line 767
				 RGN_MODIFIED);
#line 767

#line 767
		remaining -= extent;
#line 767
		if(remaining == 0)
#line 767
			break; /* normal loop exit */
#line 767
		offset += (off_t)extent;
#line 767
		value += nput;
#line 767

#line 767
	}
#line 767
#ifdef ERANGE_FILL
#line 767
        free(fillp);
#line 767
#endif
#line 767

#line 767
	return status;
#line 767
}
#line 767

static int
#line 768
putNCvx_uchar_int(NC3_INFO* ncp, const NC_var *varp,
#line 768
		 const size_t *start, size_t nelems, const int *value)
#line 768
{
#line 768
	off_t offset = NC_varoffset(ncp, varp, start);
#line 768
	size_t remaining = varp->xsz * nelems;
#line 768
	int status = NC_NOERR;
#line 768
	void *xp;
#line 768
        void *fillp=NULL;
#line 768

#line 768
	if(nelems == 0)
#line 768
		return NC_NOERR;
#line 768

#line 768
	assert(value != NULL);
#line 768

#line 768
#ifdef ERANGE_FILL
#line 768
        fillp = malloc(varp->xsz);
#line 768
        status = NC3_inq_var_fill(varp, fillp);
#line 768
#endif
#line 768

#line 768
	for(;;)
#line 768
	{
#line 768
		size_t extent = MIN(remaining, ncp->chunk);
#line 768
		size_t nput = ncx_howmany(varp->type, extent);
#line 768

#line 768
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 768
				 RGN_WRITE, &xp);
#line 768
		if(lstatus != NC_NOERR)
#line 768
			return lstatus;
#line 768

#line 768
		lstatus = ncx_putn_uchar_int(&xp, nput, value ,fillp);
#line 768
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 768
		{
#line 768
			/* not fatal to the loop */
#line 768
			status = lstatus;
#line 768
		}
#line 768

#line 768
		(void) ncio_rel(ncp->nciop, offset,
#line 768
				 RGN_MODIFIED);
#line 768

#line 768
		remaining -= extent;
#line 768
		if(remaining == 0)
#line 768
			break; /* normal loop exit */
#line 768
		offset += (off_t)extent;
#line 768
		value += nput;
#line 768

#line 768
	}
#line 768
#ifdef ERANGE_FILL
#line 768
        free(fillp);
#line 768
#endif
#line 768

#line 768
	return status;
#line 768
}
#line 768

static int
#line 769
putNCvx_uchar_float(NC3_INFO* ncp, const NC_var *varp,
#line 769
		 const size_t *start, size_t nelems, const float *value)
#line 769
{
#line 769
	off_t offset = NC_varoffset(ncp, varp, start);
#line 769
	size_t remaining = varp->xsz * nelems;
#line 769
	int status = NC_NOERR;
#line 769
	void *xp;
#line 769
        void *fillp=NULL;
#line 769

#line 769
	if(nelems == 0)
#line 769
		return NC_NOERR;
#line 769

#line 769
	assert(value != NULL);
#line 769

#line 769
#ifdef ERANGE_FILL
#line 769
        fillp = malloc(varp->xsz);
#line 769
        status = NC3_inq_var_fill(varp, fillp);
#line 769
#endif
#line 769

#line 769
	for(;;)
#line 769
	{
#line 769
		size_t extent = MIN(remaining, ncp->chunk);
#line 769
		size_t nput = ncx_howmany(varp->type, extent);
#line 769

#line 769
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 769
				 RGN_WRITE, &xp);
#line 769
		if(lstatus != NC_NOERR)
#line 769
			return lstatus;
#line 769

#line 769
		lstatus = ncx_putn_uchar_float(&xp, nput, value ,fillp);
#line 769
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 769
		{
#line 769
			/* not fatal to the loop */
#line 769
			status = lstatus;
#line 769
		}
#line 769

#line 769
		(void) ncio_rel(ncp->nciop, offset,
#line 769
				 RGN_MODIFIED);
#line 769

#line 769
		remaining -= extent;
#line 769
		if(remaining == 0)
#line 769
			break; /* normal loop exit */
#line 769
		offset += (off_t)extent;
#line 769
		value += nput;
#line 769

#line 769
	}
#line 769
#ifdef ERANGE_FILL
#line 769
        free(fillp);
#line 769
#endif
#line 769

#line 769
	return status;
#line 769
}
#line 769

static int
#line 770
putNCvx_uchar_double(NC3_INFO* ncp, const NC_var *varp,
#line 770
		 const size_t *start, size_t nelems, const double *value)
#line 770
{
#line 770
	off_t offset = NC_varoffset(ncp, varp, start);
#line 770
	size_t remaining = varp->xsz * nelems;
#line 770
	int status = NC_NOERR;
#line 770
	void *xp;
#line 770
        void *fillp=NULL;
#line 770

#line 770
	if(nelems == 0)
#line 770
		return NC_NOERR;
#line 770

#line 770
	assert(value != NULL);
#line 770

#line 770
#ifdef ERANGE_FILL
#line 770
        fillp = malloc(varp->xsz);
#line 770
        status = NC3_inq_var_fill(varp, fillp);
#line 770
#endif
#line 770

#line 770
	for(;;)
#line 770
	{
#line 770
		size_t extent = MIN(remaining, ncp->chunk);
#line 770
		size_t nput = ncx_howmany(varp->type, extent);
#line 770

#line 770
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 770
				 RGN_WRITE, &xp);
#line 770
		if(lstatus != NC_NOERR)
#line 770
			return lstatus;
#line 770

#line 770
		lstatus = ncx_putn_uchar_double(&xp, nput, value ,fillp);
#line 770
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 770
		{
#line 770
			/* not fatal to the loop */
#line 770
			status = lstatus;
#line 770
		}
#line 770

#line 770
		(void) ncio_rel(ncp->nciop, offset,
#line 770
				 RGN_MODIFIED);
#line 770

#line 770
		remaining -= extent;
#line 770
		if(remaining == 0)
#line 770
			break; /* normal loop exit */
#line 770
		offset += (off_t)extent;
#line 770
		value += nput;
#line 770

#line 770
	}
#line 770
#ifdef ERANGE_FILL
#line 770
        free(fillp);
#line 770
#endif
#line 770

#line 770
	return status;
#line 770
}
#line 770

static int
#line 771
putNCvx_uchar_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 771
		 const size_t *start, size_t nelems, const longlong *value)
#line 771
{
#line 771
	off_t offset = NC_varoffset(ncp, varp, start);
#line 771
	size_t remaining = varp->xsz * nelems;
#line 771
	int status = NC_NOERR;
#line 771
	void *xp;
#line 771
        void *fillp=NULL;
#line 771

#line 771
	if(nelems == 0)
#line 771
		return NC_NOERR;
#line 771

#line 771
	assert(value != NULL);
#line 771

#line 771
#ifdef ERANGE_FILL
#line 771
        fillp = malloc(varp->xsz);
#line 771
        status = NC3_inq_var_fill(varp, fillp);
#line 771
#endif
#line 771

#line 771
	for(;;)
#line 771
	{
#line 771
		size_t extent = MIN(remaining, ncp->chunk);
#line 771
		size_t nput = ncx_howmany(varp->type, extent);
#line 771

#line 771
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 771
				 RGN_WRITE, &xp);
#line 771
		if(lstatus != NC_NOERR)
#line 771
			return lstatus;
#line 771

#line 771
		lstatus = ncx_putn_uchar_longlong(&xp, nput, value ,fillp);
#line 771
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 771
		{
#line 771
			/* not fatal to the loop */
#line 771
			status = lstatus;
#line 771
		}
#line 771

#line 771
		(void) ncio_rel(ncp->nciop, offset,
#line 771
				 RGN_MODIFIED);
#line 771

#line 771
		remaining -= extent;
#line 771
		if(remaining == 0)
#line 771
			break; /* normal loop exit */
#line 771
		offset += (off_t)extent;
#line 771
		value += nput;
#line 771

#line 771
	}
#line 771
#ifdef ERANGE_FILL
#line 771
        free(fillp);
#line 771
#endif
#line 771

#line 771
	return status;
#line 771
}
#line 771

static int
#line 772
putNCvx_uchar_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 772
		 const size_t *start, size_t nelems, const ushort *value)
#line 772
{
#line 772
	off_t offset = NC_varoffset(ncp, varp, start);
#line 772
	size_t remaining = varp->xsz * nelems;
#line 772
	int status = NC_NOERR;
#line 772
	void *xp;
#line 772
        void *fillp=NULL;
#line 772

#line 772
	if(nelems == 0)
#line 772
		return NC_NOERR;
#line 772

#line 772
	assert(value != NULL);
#line 772

#line 772
#ifdef ERANGE_FILL
#line 772
        fillp = malloc(varp->xsz);
#line 772
        status = NC3_inq_var_fill(varp, fillp);
#line 772
#endif
#line 772

#line 772
	for(;;)
#line 772
	{
#line 772
		size_t extent = MIN(remaining, ncp->chunk);
#line 772
		size_t nput = ncx_howmany(varp->type, extent);
#line 772

#line 772
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 772
				 RGN_WRITE, &xp);
#line 772
		if(lstatus != NC_NOERR)
#line 772
			return lstatus;
#line 772

#line 772
		lstatus = ncx_putn_uchar_ushort(&xp, nput, value ,fillp);
#line 772
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 772
		{
#line 772
			/* not fatal to the loop */
#line 772
			status = lstatus;
#line 772
		}
#line 772

#line 772
		(void) ncio_rel(ncp->nciop, offset,
#line 772
				 RGN_MODIFIED);
#line 772

#line 772
		remaining -= extent;
#line 772
		if(remaining == 0)
#line 772
			break; /* normal loop exit */
#line 772
		offset += (off_t)extent;
#line 772
		value += nput;
#line 772

#line 772
	}
#line 772
#ifdef ERANGE_FILL
#line 772
        free(fillp);
#line 772
#endif
#line 772

#line 772
	return status;
#line 772
}
#line 772

static int
#line 773
putNCvx_uchar_uint(NC3_INFO* ncp, const NC_var *varp,
#line 773
		 const size_t *start, size_t nelems, const uint *value)
#line 773
{
#line 773
	off_t offset = NC_varoffset(ncp, varp, start);
#line 773
	size_t remaining = varp->xsz * nelems;
#line 773
	int status = NC_NOERR;
#line 773
	void *xp;
#line 773
        void *fillp=NULL;
#line 773

#line 773
	if(nelems == 0)
#line 773
		return NC_NOERR;
#line 773

#line 773
	assert(value != NULL);
#line 773

#line 773
#ifdef ERANGE_FILL
#line 773
        fillp = malloc(varp->xsz);
#line 773
        status = NC3_inq_var_fill(varp, fillp);
#line 773
#endif
#line 773

#line 773
	for(;;)
#line 773
	{
#line 773
		size_t extent = MIN(remaining, ncp->chunk);
#line 773
		size_t nput = ncx_howmany(varp->type, extent);
#line 773

#line 773
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 773
				 RGN_WRITE, &xp);
#line 773
		if(lstatus != NC_NOERR)
#line 773
			return lstatus;
#line 773

#line 773
		lstatus = ncx_putn_uchar_uint(&xp, nput, value ,fillp);
#line 773
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 773
		{
#line 773
			/* not fatal to the loop */
#line 773
			status = lstatus;
#line 773
		}
#line 773

#line 773
		(void) ncio_rel(ncp->nciop, offset,
#line 773
				 RGN_MODIFIED);
#line 773

#line 773
		remaining -= extent;
#line 773
		if(remaining == 0)
#line 773
			break; /* normal loop exit */
#line 773
		offset += (off_t)extent;
#line 773
		value += nput;
#line 773

#line 773
	}
#line 773
#ifdef ERANGE_FILL
#line 773
        free(fillp);
#line 773
#endif
#line 773

#line 773
	return status;
#line 773
}
#line 773

static int
#line 774
putNCvx_uchar_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 774
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 774
{
#line 774
	off_t offset = NC_varoffset(ncp, varp, start);
#line 774
	size_t remaining = varp->xsz * nelems;
#line 774
	int status = NC_NOERR;
#line 774
	void *xp;
#line 774
        void *fillp=NULL;
#line 774

#line 774
	if(nelems == 0)
#line 774
		return NC_NOERR;
#line 774

#line 774
	assert(value != NULL);
#line 774

#line 774
#ifdef ERANGE_FILL
#line 774
        fillp = malloc(varp->xsz);
#line 774
        status = NC3_inq_var_fill(varp, fillp);
#line 774
#endif
#line 774

#line 774
	for(;;)
#line 774
	{
#line 774
		size_t extent = MIN(remaining, ncp->chunk);
#line 774
		size_t nput = ncx_howmany(varp->type, extent);
#line 774

#line 774
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 774
				 RGN_WRITE, &xp);
#line 774
		if(lstatus != NC_NOERR)
#line 774
			return lstatus;
#line 774

#line 774
		lstatus = ncx_putn_uchar_ulonglong(&xp, nput, value ,fillp);
#line 774
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 774
		{
#line 774
			/* not fatal to the loop */
#line 774
			status = lstatus;
#line 774
		}
#line 774

#line 774
		(void) ncio_rel(ncp->nciop, offset,
#line 774
				 RGN_MODIFIED);
#line 774

#line 774
		remaining -= extent;
#line 774
		if(remaining == 0)
#line 774
			break; /* normal loop exit */
#line 774
		offset += (off_t)extent;
#line 774
		value += nput;
#line 774

#line 774
	}
#line 774
#ifdef ERANGE_FILL
#line 774
        free(fillp);
#line 774
#endif
#line 774

#line 774
	return status;
#line 774
}
#line 774


static int
#line 776
putNCvx_ushort_schar(NC3_INFO* ncp, const NC_var *varp,
#line 776
		 const size_t *start, size_t nelems, const schar *value)
#line 776
{
#line 776
	off_t offset = NC_varoffset(ncp, varp, start);
#line 776
	size_t remaining = varp->xsz * nelems;
#line 776
	int status = NC_NOERR;
#line 776
	void *xp;
#line 776
        void *fillp=NULL;
#line 776

#line 776
	if(nelems == 0)
#line 776
		return NC_NOERR;
#line 776

#line 776
	assert(value != NULL);
#line 776

#line 776
#ifdef ERANGE_FILL
#line 776
        fillp = malloc(varp->xsz);
#line 776
        status = NC3_inq_var_fill(varp, fillp);
#line 776
#endif
#line 776

#line 776
	for(;;)
#line 776
	{
#line 776
		size_t extent = MIN(remaining, ncp->chunk);
#line 776
		size_t nput = ncx_howmany(varp->type, extent);
#line 776

#line 776
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 776
				 RGN_WRITE, &xp);
#line 776
		if(lstatus != NC_NOERR)
#line 776
			return lstatus;
#line 776

#line 776
		lstatus = ncx_putn_ushort_schar(&xp, nput, value ,fillp);
#line 776
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 776
		{
#line 776
			/* not fatal to the loop */
#line 776
			status = lstatus;
#line 776
		}
#line 776

#line 776
		(void) ncio_rel(ncp->nciop, offset,
#line 776
				 RGN_MODIFIED);
#line 776

#line 776
		remaining -= extent;
#line 776
		if(remaining == 0)
#line 776
			break; /* normal loop exit */
#line 776
		offset += (off_t)extent;
#line 776
		value += nput;
#line 776

#line 776
	}
#line 776
#ifdef ERANGE_FILL
#line 776
        free(fillp);
#line 776
#endif
#line 776

#line 776
	return status;
#line 776
}
#line 776

static int
#line 777
putNCvx_ushort_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 777
		 const size_t *start, size_t nelems, const uchar *value)
#line 777
{
#line 777
	off_t offset = NC_varoffset(ncp, varp, start);
#line 777
	size_t remaining = varp->xsz * nelems;
#line 777
	int status = NC_NOERR;
#line 777
	void *xp;
#line 777
        void *fillp=NULL;
#line 777

#line 777
	if(nelems == 0)
#line 777
		return NC_NOERR;
#line 777

#line 777
	assert(value != NULL);
#line 777

#line 777
#ifdef ERANGE_FILL
#line 777
        fillp = malloc(varp->xsz);
#line 777
        status = NC3_inq_var_fill(varp, fillp);
#line 777
#endif
#line 777

#line 777
	for(;;)
#line 777
	{
#line 777
		size_t extent = MIN(remaining, ncp->chunk);
#line 777
		size_t nput = ncx_howmany(varp->type, extent);
#line 777

#line 777
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 777
				 RGN_WRITE, &xp);
#line 777
		if(lstatus != NC_NOERR)
#line 777
			return lstatus;
#line 777

#line 777
		lstatus = ncx_putn_ushort_uchar(&xp, nput, value ,fillp);
#line 777
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 777
		{
#line 777
			/* not fatal to the loop */
#line 777
			status = lstatus;
#line 777
		}
#line 777

#line 777
		(void) ncio_rel(ncp->nciop, offset,
#line 777
				 RGN_MODIFIED);
#line 777

#line 777
		remaining -= extent;
#line 777
		if(remaining == 0)
#line 777
			break; /* normal loop exit */
#line 777
		offset += (off_t)extent;
#line 777
		value += nput;
#line 777

#line 777
	}
#line 777
#ifdef ERANGE_FILL
#line 777
        free(fillp);
#line 777
#endif
#line 777

#line 777
	return status;
#line 777
}
#line 777

static int
#line 778
putNCvx_ushort_short(NC3_INFO* ncp, const NC_var *varp,
#line 778
		 const size_t *start, size_t nelems, const short *value)
#line 778
{
#line 778
	off_t offset = NC_varoffset(ncp, varp, start);
#line 778
	size_t remaining = varp->xsz * nelems;
#line 778
	int status = NC_NOERR;
#line 778
	void *xp;
#line 778
        void *fillp=NULL;
#line 778

#line 778
	if(nelems == 0)
#line 778
		return NC_NOERR;
#line 778

#line 778
	assert(value != NULL);
#line 778

#line 778
#ifdef ERANGE_FILL
#line 778
        fillp = malloc(varp->xsz);
#line 778
        status = NC3_inq_var_fill(varp, fillp);
#line 778
#endif
#line 778

#line 778
	for(;;)
#line 778
	{
#line 778
		size_t extent = MIN(remaining, ncp->chunk);
#line 778
		size_t nput = ncx_howmany(varp->type, extent);
#line 778

#line 778
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 778
				 RGN_WRITE, &xp);
#line 778
		if(lstatus != NC_NOERR)
#line 778
			return lstatus;
#line 778

#line 778
		lstatus = ncx_putn_ushort_short(&xp, nput, value ,fillp);
#line 778
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 778
		{
#line 778
			/* not fatal to the loop */
#line 778
			status = lstatus;
#line 778
		}
#line 778

#line 778
		(void) ncio_rel(ncp->nciop, offset,
#line 778
				 RGN_MODIFIED);
#line 778

#line 778
		remaining -= extent;
#line 778
		if(remaining == 0)
#line 778
			break; /* normal loop exit */
#line 778
		offset += (off_t)extent;
#line 778
		value += nput;
#line 778

#line 778
	}
#line 778
#ifdef ERANGE_FILL
#line 778
        free(fillp);
#line 778
#endif
#line 778

#line 778
	return status;
#line 778
}
#line 778

static int
#line 779
putNCvx_ushort_int(NC3_INFO* ncp, const NC_var *varp,
#line 779
		 const size_t *start, size_t nelems, const int *value)
#line 779
{
#line 779
	off_t offset = NC_varoffset(ncp, varp, start);
#line 779
	size_t remaining = varp->xsz * nelems;
#line 779
	int status = NC_NOERR;
#line 779
	void *xp;
#line 779
        void *fillp=NULL;
#line 779

#line 779
	if(nelems == 0)
#line 779
		return NC_NOERR;
#line 779

#line 779
	assert(value != NULL);
#line 779

#line 779
#ifdef ERANGE_FILL
#line 779
        fillp = malloc(varp->xsz);
#line 779
        status = NC3_inq_var_fill(varp, fillp);
#line 779
#endif
#line 779

#line 779
	for(;;)
#line 779
	{
#line 779
		size_t extent = MIN(remaining, ncp->chunk);
#line 779
		size_t nput = ncx_howmany(varp->type, extent);
#line 779

#line 779
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 779
				 RGN_WRITE, &xp);
#line 779
		if(lstatus != NC_NOERR)
#line 779
			return lstatus;
#line 779

#line 779
		lstatus = ncx_putn_ushort_int(&xp, nput, value ,fillp);
#line 779
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 779
		{
#line 779
			/* not fatal to the loop */
#line 779
			status = lstatus;
#line 779
		}
#line 779

#line 779
		(void) ncio_rel(ncp->nciop, offset,
#line 779
				 RGN_MODIFIED);
#line 779

#line 779
		remaining -= extent;
#line 779
		if(remaining == 0)
#line 779
			break; /* normal loop exit */
#line 779
		offset += (off_t)extent;
#line 779
		value += nput;
#line 779

#line 779
	}
#line 779
#ifdef ERANGE_FILL
#line 779
        free(fillp);
#line 779
#endif
#line 779

#line 779
	return status;
#line 779
}
#line 779

static int
#line 780
putNCvx_ushort_float(NC3_INFO* ncp, const NC_var *varp,
#line 780
		 const size_t *start, size_t nelems, const float *value)
#line 780
{
#line 780
	off_t offset = NC_varoffset(ncp, varp, start);
#line 780
	size_t remaining = varp->xsz * nelems;
#line 780
	int status = NC_NOERR;
#line 780
	void *xp;
#line 780
        void *fillp=NULL;
#line 780

#line 780
	if(nelems == 0)
#line 780
		return NC_NOERR;
#line 780

#line 780
	assert(value != NULL);
#line 780

#line 780
#ifdef ERANGE_FILL
#line 780
        fillp = malloc(varp->xsz);
#line 780
        status = NC3_inq_var_fill(varp, fillp);
#line 780
#endif
#line 780

#line 780
	for(;;)
#line 780
	{
#line 780
		size_t extent = MIN(remaining, ncp->chunk);
#line 780
		size_t nput = ncx_howmany(varp->type, extent);
#line 780

#line 780
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 780
				 RGN_WRITE, &xp);
#line 780
		if(lstatus != NC_NOERR)
#line 780
			return lstatus;
#line 780

#line 780
		lstatus = ncx_putn_ushort_float(&xp, nput, value ,fillp);
#line 780
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 780
		{
#line 780
			/* not fatal to the loop */
#line 780
			status = lstatus;
#line 780
		}
#line 780

#line 780
		(void) ncio_rel(ncp->nciop, offset,
#line 780
				 RGN_MODIFIED);
#line 780

#line 780
		remaining -= extent;
#line 780
		if(remaining == 0)
#line 780
			break; /* normal loop exit */
#line 780
		offset += (off_t)extent;
#line 780
		value += nput;
#line 780

#line 780
	}
#line 780
#ifdef ERANGE_FILL
#line 780
        free(fillp);
#line 780
#endif
#line 780

#line 780
	return status;
#line 780
}
#line 780

static int
#line 781
putNCvx_ushort_double(NC3_INFO* ncp, const NC_var *varp,
#line 781
		 const size_t *start, size_t nelems, const double *value)
#line 781
{
#line 781
	off_t offset = NC_varoffset(ncp, varp, start);
#line 781
	size_t remaining = varp->xsz * nelems;
#line 781
	int status = NC_NOERR;
#line 781
	void *xp;
#line 781
        void *fillp=NULL;
#line 781

#line 781
	if(nelems == 0)
#line 781
		return NC_NOERR;
#line 781

#line 781
	assert(value != NULL);
#line 781

#line 781
#ifdef ERANGE_FILL
#line 781
        fillp = malloc(varp->xsz);
#line 781
        status = NC3_inq_var_fill(varp, fillp);
#line 781
#endif
#line 781

#line 781
	for(;;)
#line 781
	{
#line 781
		size_t extent = MIN(remaining, ncp->chunk);
#line 781
		size_t nput = ncx_howmany(varp->type, extent);
#line 781

#line 781
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 781
				 RGN_WRITE, &xp);
#line 781
		if(lstatus != NC_NOERR)
#line 781
			return lstatus;
#line 781

#line 781
		lstatus = ncx_putn_ushort_double(&xp, nput, value ,fillp);
#line 781
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 781
		{
#line 781
			/* not fatal to the loop */
#line 781
			status = lstatus;
#line 781
		}
#line 781

#line 781
		(void) ncio_rel(ncp->nciop, offset,
#line 781
				 RGN_MODIFIED);
#line 781

#line 781
		remaining -= extent;
#line 781
		if(remaining == 0)
#line 781
			break; /* normal loop exit */
#line 781
		offset += (off_t)extent;
#line 781
		value += nput;
#line 781

#line 781
	}
#line 781
#ifdef ERANGE_FILL
#line 781
        free(fillp);
#line 781
#endif
#line 781

#line 781
	return status;
#line 781
}
#line 781

static int
#line 782
putNCvx_ushort_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 782
		 const size_t *start, size_t nelems, const longlong *value)
#line 782
{
#line 782
	off_t offset = NC_varoffset(ncp, varp, start);
#line 782
	size_t remaining = varp->xsz * nelems;
#line 782
	int status = NC_NOERR;
#line 782
	void *xp;
#line 782
        void *fillp=NULL;
#line 782

#line 782
	if(nelems == 0)
#line 782
		return NC_NOERR;
#line 782

#line 782
	assert(value != NULL);
#line 782

#line 782
#ifdef ERANGE_FILL
#line 782
        fillp = malloc(varp->xsz);
#line 782
        status = NC3_inq_var_fill(varp, fillp);
#line 782
#endif
#line 782

#line 782
	for(;;)
#line 782
	{
#line 782
		size_t extent = MIN(remaining, ncp->chunk);
#line 782
		size_t nput = ncx_howmany(varp->type, extent);
#line 782

#line 782
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 782
				 RGN_WRITE, &xp);
#line 782
		if(lstatus != NC_NOERR)
#line 782
			return lstatus;
#line 782

#line 782
		lstatus = ncx_putn_ushort_longlong(&xp, nput, value ,fillp);
#line 782
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 782
		{
#line 782
			/* not fatal to the loop */
#line 782
			status = lstatus;
#line 782
		}
#line 782

#line 782
		(void) ncio_rel(ncp->nciop, offset,
#line 782
				 RGN_MODIFIED);
#line 782

#line 782
		remaining -= extent;
#line 782
		if(remaining == 0)
#line 782
			break; /* normal loop exit */
#line 782
		offset += (off_t)extent;
#line 782
		value += nput;
#line 782

#line 782
	}
#line 782
#ifdef ERANGE_FILL
#line 782
        free(fillp);
#line 782
#endif
#line 782

#line 782
	return status;
#line 782
}
#line 782

static int
#line 783
putNCvx_ushort_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 783
		 const size_t *start, size_t nelems, const ushort *value)
#line 783
{
#line 783
	off_t offset = NC_varoffset(ncp, varp, start);
#line 783
	size_t remaining = varp->xsz * nelems;
#line 783
	int status = NC_NOERR;
#line 783
	void *xp;
#line 783
        void *fillp=NULL;
#line 783

#line 783
	if(nelems == 0)
#line 783
		return NC_NOERR;
#line 783

#line 783
	assert(value != NULL);
#line 783

#line 783
#ifdef ERANGE_FILL
#line 783
        fillp = malloc(varp->xsz);
#line 783
        status = NC3_inq_var_fill(varp, fillp);
#line 783
#endif
#line 783

#line 783
	for(;;)
#line 783
	{
#line 783
		size_t extent = MIN(remaining, ncp->chunk);
#line 783
		size_t nput = ncx_howmany(varp->type, extent);
#line 783

#line 783
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 783
				 RGN_WRITE, &xp);
#line 783
		if(lstatus != NC_NOERR)
#line 783
			return lstatus;
#line 783

#line 783
		lstatus = ncx_putn_ushort_ushort(&xp, nput, value ,fillp);
#line 783
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 783
		{
#line 783
			/* not fatal to the loop */
#line 783
			status = lstatus;
#line 783
		}
#line 783

#line 783
		(void) ncio_rel(ncp->nciop, offset,
#line 783
				 RGN_MODIFIED);
#line 783

#line 783
		remaining -= extent;
#line 783
		if(remaining == 0)
#line 783
			break; /* normal loop exit */
#line 783
		offset += (off_t)extent;
#line 783
		value += nput;
#line 783

#line 783
	}
#line 783
#ifdef ERANGE_FILL
#line 783
        free(fillp);
#line 783
#endif
#line 783

#line 783
	return status;
#line 783
}
#line 783

static int
#line 784
putNCvx_ushort_uint(NC3_INFO* ncp, const NC_var *varp,
#line 784
		 const size_t *start, size_t nelems, const uint *value)
#line 784
{
#line 784
	off_t offset = NC_varoffset(ncp, varp, start);
#line 784
	size_t remaining = varp->xsz * nelems;
#line 784
	int status = NC_NOERR;
#line 784
	void *xp;
#line 784
        void *fillp=NULL;
#line 784

#line 784
	if(nelems == 0)
#line 784
		return NC_NOERR;
#line 784

#line 784
	assert(value != NULL);
#line 784

#line 784
#ifdef ERANGE_FILL
#line 784
        fillp = malloc(varp->xsz);
#line 784
        status = NC3_inq_var_fill(varp, fillp);
#line 784
#endif
#line 784

#line 784
	for(;;)
#line 784
	{
#line 784
		size_t extent = MIN(remaining, ncp->chunk);
#line 784
		size_t nput = ncx_howmany(varp->type, extent);
#line 784

#line 784
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 784
				 RGN_WRITE, &xp);
#line 784
		if(lstatus != NC_NOERR)
#line 784
			return lstatus;
#line 784

#line 784
		lstatus = ncx_putn_ushort_uint(&xp, nput, value ,fillp);
#line 784
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 784
		{
#line 784
			/* not fatal to the loop */
#line 784
			status = lstatus;
#line 784
		}
#line 784

#line 784
		(void) ncio_rel(ncp->nciop, offset,
#line 784
				 RGN_MODIFIED);
#line 784

#line 784
		remaining -= extent;
#line 784
		if(remaining == 0)
#line 784
			break; /* normal loop exit */
#line 784
		offset += (off_t)extent;
#line 784
		value += nput;
#line 784

#line 784
	}
#line 784
#ifdef ERANGE_FILL
#line 784
        free(fillp);
#line 784
#endif
#line 784

#line 784
	return status;
#line 784
}
#line 784

static int
#line 785
putNCvx_ushort_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 785
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 785
{
#line 785
	off_t offset = NC_varoffset(ncp, varp, start);
#line 785
	size_t remaining = varp->xsz * nelems;
#line 785
	int status = NC_NOERR;
#line 785
	void *xp;
#line 785
        void *fillp=NULL;
#line 785

#line 785
	if(nelems == 0)
#line 785
		return NC_NOERR;
#line 785

#line 785
	assert(value != NULL);
#line 785

#line 785
#ifdef ERANGE_FILL
#line 785
        fillp = malloc(varp->xsz);
#line 785
        status = NC3_inq_var_fill(varp, fillp);
#line 785
#endif
#line 785

#line 785
	for(;;)
#line 785
	{
#line 785
		size_t extent = MIN(remaining, ncp->chunk);
#line 785
		size_t nput = ncx_howmany(varp->type, extent);
#line 785

#line 785
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 785
				 RGN_WRITE, &xp);
#line 785
		if(lstatus != NC_NOERR)
#line 785
			return lstatus;
#line 785

#line 785
		lstatus = ncx_putn_ushort_ulonglong(&xp, nput, value ,fillp);
#line 785
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 785
		{
#line 785
			/* not fatal to the loop */
#line 785
			status = lstatus;
#line 785
		}
#line 785

#line 785
		(void) ncio_rel(ncp->nciop, offset,
#line 785
				 RGN_MODIFIED);
#line 785

#line 785
		remaining -= extent;
#line 785
		if(remaining == 0)
#line 785
			break; /* normal loop exit */
#line 785
		offset += (off_t)extent;
#line 785
		value += nput;
#line 785

#line 785
	}
#line 785
#ifdef ERANGE_FILL
#line 785
        free(fillp);
#line 785
#endif
#line 785

#line 785
	return status;
#line 785
}
#line 785


static int
#line 787
putNCvx_uint_schar(NC3_INFO* ncp, const NC_var *varp,
#line 787
		 const size_t *start, size_t nelems, const schar *value)
#line 787
{
#line 787
	off_t offset = NC_varoffset(ncp, varp, start);
#line 787
	size_t remaining = varp->xsz * nelems;
#line 787
	int status = NC_NOERR;
#line 787
	void *xp;
#line 787
        void *fillp=NULL;
#line 787

#line 787
	if(nelems == 0)
#line 787
		return NC_NOERR;
#line 787

#line 787
	assert(value != NULL);
#line 787

#line 787
#ifdef ERANGE_FILL
#line 787
        fillp = malloc(varp->xsz);
#line 787
        status = NC3_inq_var_fill(varp, fillp);
#line 787
#endif
#line 787

#line 787
	for(;;)
#line 787
	{
#line 787
		size_t extent = MIN(remaining, ncp->chunk);
#line 787
		size_t nput = ncx_howmany(varp->type, extent);
#line 787

#line 787
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 787
				 RGN_WRITE, &xp);
#line 787
		if(lstatus != NC_NOERR)
#line 787
			return lstatus;
#line 787

#line 787
		lstatus = ncx_putn_uint_schar(&xp, nput, value ,fillp);
#line 787
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 787
		{
#line 787
			/* not fatal to the loop */
#line 787
			status = lstatus;
#line 787
		}
#line 787

#line 787
		(void) ncio_rel(ncp->nciop, offset,
#line 787
				 RGN_MODIFIED);
#line 787

#line 787
		remaining -= extent;
#line 787
		if(remaining == 0)
#line 787
			break; /* normal loop exit */
#line 787
		offset += (off_t)extent;
#line 787
		value += nput;
#line 787

#line 787
	}
#line 787
#ifdef ERANGE_FILL
#line 787
        free(fillp);
#line 787
#endif
#line 787

#line 787
	return status;
#line 787
}
#line 787

static int
#line 788
putNCvx_uint_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 788
		 const size_t *start, size_t nelems, const uchar *value)
#line 788
{
#line 788
	off_t offset = NC_varoffset(ncp, varp, start);
#line 788
	size_t remaining = varp->xsz * nelems;
#line 788
	int status = NC_NOERR;
#line 788
	void *xp;
#line 788
        void *fillp=NULL;
#line 788

#line 788
	if(nelems == 0)
#line 788
		return NC_NOERR;
#line 788

#line 788
	assert(value != NULL);
#line 788

#line 788
#ifdef ERANGE_FILL
#line 788
        fillp = malloc(varp->xsz);
#line 788
        status = NC3_inq_var_fill(varp, fillp);
#line 788
#endif
#line 788

#line 788
	for(;;)
#line 788
	{
#line 788
		size_t extent = MIN(remaining, ncp->chunk);
#line 788
		size_t nput = ncx_howmany(varp->type, extent);
#line 788

#line 788
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 788
				 RGN_WRITE, &xp);
#line 788
		if(lstatus != NC_NOERR)
#line 788
			return lstatus;
#line 788

#line 788
		lstatus = ncx_putn_uint_uchar(&xp, nput, value ,fillp);
#line 788
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 788
		{
#line 788
			/* not fatal to the loop */
#line 788
			status = lstatus;
#line 788
		}
#line 788

#line 788
		(void) ncio_rel(ncp->nciop, offset,
#line 788
				 RGN_MODIFIED);
#line 788

#line 788
		remaining -= extent;
#line 788
		if(remaining == 0)
#line 788
			break; /* normal loop exit */
#line 788
		offset += (off_t)extent;
#line 788
		value += nput;
#line 788

#line 788
	}
#line 788
#ifdef ERANGE_FILL
#line 788
        free(fillp);
#line 788
#endif
#line 788

#line 788
	return status;
#line 788
}
#line 788

static int
#line 789
putNCvx_uint_short(NC3_INFO* ncp, const NC_var *varp,
#line 789
		 const size_t *start, size_t nelems, const short *value)
#line 789
{
#line 789
	off_t offset = NC_varoffset(ncp, varp, start);
#line 789
	size_t remaining = varp->xsz * nelems;
#line 789
	int status = NC_NOERR;
#line 789
	void *xp;
#line 789
        void *fillp=NULL;
#line 789

#line 789
	if(nelems == 0)
#line 789
		return NC_NOERR;
#line 789

#line 789
	assert(value != NULL);
#line 789

#line 789
#ifdef ERANGE_FILL
#line 789
        fillp = malloc(varp->xsz);
#line 789
        status = NC3_inq_var_fill(varp, fillp);
#line 789
#endif
#line 789

#line 789
	for(;;)
#line 789
	{
#line 789
		size_t extent = MIN(remaining, ncp->chunk);
#line 789
		size_t nput = ncx_howmany(varp->type, extent);
#line 789

#line 789
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 789
				 RGN_WRITE, &xp);
#line 789
		if(lstatus != NC_NOERR)
#line 789
			return lstatus;
#line 789

#line 789
		lstatus = ncx_putn_uint_short(&xp, nput, value ,fillp);
#line 789
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 789
		{
#line 789
			/* not fatal to the loop */
#line 789
			status = lstatus;
#line 789
		}
#line 789

#line 789
		(void) ncio_rel(ncp->nciop, offset,
#line 789
				 RGN_MODIFIED);
#line 789

#line 789
		remaining -= extent;
#line 789
		if(remaining == 0)
#line 789
			break; /* normal loop exit */
#line 789
		offset += (off_t)extent;
#line 789
		value += nput;
#line 789

#line 789
	}
#line 789
#ifdef ERANGE_FILL
#line 789
        free(fillp);
#line 789
#endif
#line 789

#line 789
	return status;
#line 789
}
#line 789

static int
#line 790
putNCvx_uint_int(NC3_INFO* ncp, const NC_var *varp,
#line 790
		 const size_t *start, size_t nelems, const int *value)
#line 790
{
#line 790
	off_t offset = NC_varoffset(ncp, varp, start);
#line 790
	size_t remaining = varp->xsz * nelems;
#line 790
	int status = NC_NOERR;
#line 790
	void *xp;
#line 790
        void *fillp=NULL;
#line 790

#line 790
	if(nelems == 0)
#line 790
		return NC_NOERR;
#line 790

#line 790
	assert(value != NULL);
#line 790

#line 790
#ifdef ERANGE_FILL
#line 790
        fillp = malloc(varp->xsz);
#line 790
        status = NC3_inq_var_fill(varp, fillp);
#line 790
#endif
#line 790

#line 790
	for(;;)
#line 790
	{
#line 790
		size_t extent = MIN(remaining, ncp->chunk);
#line 790
		size_t nput = ncx_howmany(varp->type, extent);
#line 790

#line 790
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 790
				 RGN_WRITE, &xp);
#line 790
		if(lstatus != NC_NOERR)
#line 790
			return lstatus;
#line 790

#line 790
		lstatus = ncx_putn_uint_int(&xp, nput, value ,fillp);
#line 790
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 790
		{
#line 790
			/* not fatal to the loop */
#line 790
			status = lstatus;
#line 790
		}
#line 790

#line 790
		(void) ncio_rel(ncp->nciop, offset,
#line 790
				 RGN_MODIFIED);
#line 790

#line 790
		remaining -= extent;
#line 790
		if(remaining == 0)
#line 790
			break; /* normal loop exit */
#line 790
		offset += (off_t)extent;
#line 790
		value += nput;
#line 790

#line 790
	}
#line 790
#ifdef ERANGE_FILL
#line 790
        free(fillp);
#line 790
#endif
#line 790

#line 790
	return status;
#line 790
}
#line 790

static int
#line 791
putNCvx_uint_float(NC3_INFO* ncp, const NC_var *varp,
#line 791
		 const size_t *start, size_t nelems, const float *value)
#line 791
{
#line 791
	off_t offset = NC_varoffset(ncp, varp, start);
#line 791
	size_t remaining = varp->xsz * nelems;
#line 791
	int status = NC_NOERR;
#line 791
	void *xp;
#line 791
        void *fillp=NULL;
#line 791

#line 791
	if(nelems == 0)
#line 791
		return NC_NOERR;
#line 791

#line 791
	assert(value != NULL);
#line 791

#line 791
#ifdef ERANGE_FILL
#line 791
        fillp = malloc(varp->xsz);
#line 791
        status = NC3_inq_var_fill(varp, fillp);
#line 791
#endif
#line 791

#line 791
	for(;;)
#line 791
	{
#line 791
		size_t extent = MIN(remaining, ncp->chunk);
#line 791
		size_t nput = ncx_howmany(varp->type, extent);
#line 791

#line 791
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 791
				 RGN_WRITE, &xp);
#line 791
		if(lstatus != NC_NOERR)
#line 791
			return lstatus;
#line 791

#line 791
		lstatus = ncx_putn_uint_float(&xp, nput, value ,fillp);
#line 791
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 791
		{
#line 791
			/* not fatal to the loop */
#line 791
			status = lstatus;
#line 791
		}
#line 791

#line 791
		(void) ncio_rel(ncp->nciop, offset,
#line 791
				 RGN_MODIFIED);
#line 791

#line 791
		remaining -= extent;
#line 791
		if(remaining == 0)
#line 791
			break; /* normal loop exit */
#line 791
		offset += (off_t)extent;
#line 791
		value += nput;
#line 791

#line 791
	}
#line 791
#ifdef ERANGE_FILL
#line 791
        free(fillp);
#line 791
#endif
#line 791

#line 791
	return status;
#line 791
}
#line 791

static int
#line 792
putNCvx_uint_double(NC3_INFO* ncp, const NC_var *varp,
#line 792
		 const size_t *start, size_t nelems, const double *value)
#line 792
{
#line 792
	off_t offset = NC_varoffset(ncp, varp, start);
#line 792
	size_t remaining = varp->xsz * nelems;
#line 792
	int status = NC_NOERR;
#line 792
	void *xp;
#line 792
        void *fillp=NULL;
#line 792

#line 792
	if(nelems == 0)
#line 792
		return NC_NOERR;
#line 792

#line 792
	assert(value != NULL);
#line 792

#line 792
#ifdef ERANGE_FILL
#line 792
        fillp = malloc(varp->xsz);
#line 792
        status = NC3_inq_var_fill(varp, fillp);
#line 792
#endif
#line 792

#line 792
	for(;;)
#line 792
	{
#line 792
		size_t extent = MIN(remaining, ncp->chunk);
#line 792
		size_t nput = ncx_howmany(varp->type, extent);
#line 792

#line 792
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 792
				 RGN_WRITE, &xp);
#line 792
		if(lstatus != NC_NOERR)
#line 792
			return lstatus;
#line 792

#line 792
		lstatus = ncx_putn_uint_double(&xp, nput, value ,fillp);
#line 792
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 792
		{
#line 792
			/* not fatal to the loop */
#line 792
			status = lstatus;
#line 792
		}
#line 792

#line 792
		(void) ncio_rel(ncp->nciop, offset,
#line 792
				 RGN_MODIFIED);
#line 792

#line 792
		remaining -= extent;
#line 792
		if(remaining == 0)
#line 792
			break; /* normal loop exit */
#line 792
		offset += (off_t)extent;
#line 792
		value += nput;
#line 792

#line 792
	}
#line 792
#ifdef ERANGE_FILL
#line 792
        free(fillp);
#line 792
#endif
#line 792

#line 792
	return status;
#line 792
}
#line 792

static int
#line 793
putNCvx_uint_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 793
		 const size_t *start, size_t nelems, const longlong *value)
#line 793
{
#line 793
	off_t offset = NC_varoffset(ncp, varp, start);
#line 793
	size_t remaining = varp->xsz * nelems;
#line 793
	int status = NC_NOERR;
#line 793
	void *xp;
#line 793
        void *fillp=NULL;
#line 793

#line 793
	if(nelems == 0)
#line 793
		return NC_NOERR;
#line 793

#line 793
	assert(value != NULL);
#line 793

#line 793
#ifdef ERANGE_FILL
#line 793
        fillp = malloc(varp->xsz);
#line 793
        status = NC3_inq_var_fill(varp, fillp);
#line 793
#endif
#line 793

#line 793
	for(;;)
#line 793
	{
#line 793
		size_t extent = MIN(remaining, ncp->chunk);
#line 793
		size_t nput = ncx_howmany(varp->type, extent);
#line 793

#line 793
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 793
				 RGN_WRITE, &xp);
#line 793
		if(lstatus != NC_NOERR)
#line 793
			return lstatus;
#line 793

#line 793
		lstatus = ncx_putn_uint_longlong(&xp, nput, value ,fillp);
#line 793
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 793
		{
#line 793
			/* not fatal to the loop */
#line 793
			status = lstatus;
#line 793
		}
#line 793

#line 793
		(void) ncio_rel(ncp->nciop, offset,
#line 793
				 RGN_MODIFIED);
#line 793

#line 793
		remaining -= extent;
#line 793
		if(remaining == 0)
#line 793
			break; /* normal loop exit */
#line 793
		offset += (off_t)extent;
#line 793
		value += nput;
#line 793

#line 793
	}
#line 793
#ifdef ERANGE_FILL
#line 793
        free(fillp);
#line 793
#endif
#line 793

#line 793
	return status;
#line 793
}
#line 793

static int
#line 794
putNCvx_uint_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 794
		 const size_t *start, size_t nelems, const ushort *value)
#line 794
{
#line 794
	off_t offset = NC_varoffset(ncp, varp, start);
#line 794
	size_t remaining = varp->xsz * nelems;
#line 794
	int status = NC_NOERR;
#line 794
	void *xp;
#line 794
        void *fillp=NULL;
#line 794

#line 794
	if(nelems == 0)
#line 794
		return NC_NOERR;
#line 794

#line 794
	assert(value != NULL);
#line 794

#line 794
#ifdef ERANGE_FILL
#line 794
        fillp = malloc(varp->xsz);
#line 794
        status = NC3_inq_var_fill(varp, fillp);
#line 794
#endif
#line 794

#line 794
	for(;;)
#line 794
	{
#line 794
		size_t extent = MIN(remaining, ncp->chunk);
#line 794
		size_t nput = ncx_howmany(varp->type, extent);
#line 794

#line 794
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 794
				 RGN_WRITE, &xp);
#line 794
		if(lstatus != NC_NOERR)
#line 794
			return lstatus;
#line 794

#line 794
		lstatus = ncx_putn_uint_ushort(&xp, nput, value ,fillp);
#line 794
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 794
		{
#line 794
			/* not fatal to the loop */
#line 794
			status = lstatus;
#line 794
		}
#line 794

#line 794
		(void) ncio_rel(ncp->nciop, offset,
#line 794
				 RGN_MODIFIED);
#line 794

#line 794
		remaining -= extent;
#line 794
		if(remaining == 0)
#line 794
			break; /* normal loop exit */
#line 794
		offset += (off_t)extent;
#line 794
		value += nput;
#line 794

#line 794
	}
#line 794
#ifdef ERANGE_FILL
#line 794
        free(fillp);
#line 794
#endif
#line 794

#line 794
	return status;
#line 794
}
#line 794

static int
#line 795
putNCvx_uint_uint(NC3_INFO* ncp, const NC_var *varp,
#line 795
		 const size_t *start, size_t nelems, const uint *value)
#line 795
{
#line 795
	off_t offset = NC_varoffset(ncp, varp, start);
#line 795
	size_t remaining = varp->xsz * nelems;
#line 795
	int status = NC_NOERR;
#line 795
	void *xp;
#line 795
        void *fillp=NULL;
#line 795

#line 795
	if(nelems == 0)
#line 795
		return NC_NOERR;
#line 795

#line 795
	assert(value != NULL);
#line 795

#line 795
#ifdef ERANGE_FILL
#line 795
        fillp = malloc(varp->xsz);
#line 795
        status = NC3_inq_var_fill(varp, fillp);
#line 795
#endif
#line 795

#line 795
	for(;;)
#line 795
	{
#line 795
		size_t extent = MIN(remaining, ncp->chunk);
#line 795
		size_t nput = ncx_howmany(varp->type, extent);
#line 795

#line 795
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 795
				 RGN_WRITE, &xp);
#line 795
		if(lstatus != NC_NOERR)
#line 795
			return lstatus;
#line 795

#line 795
		lstatus = ncx_putn_uint_uint(&xp, nput, value ,fillp);
#line 795
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 795
		{
#line 795
			/* not fatal to the loop */
#line 795
			status = lstatus;
#line 795
		}
#line 795

#line 795
		(void) ncio_rel(ncp->nciop, offset,
#line 795
				 RGN_MODIFIED);
#line 795

#line 795
		remaining -= extent;
#line 795
		if(remaining == 0)
#line 795
			break; /* normal loop exit */
#line 795
		offset += (off_t)extent;
#line 795
		value += nput;
#line 795

#line 795
	}
#line 795
#ifdef ERANGE_FILL
#line 795
        free(fillp);
#line 795
#endif
#line 795

#line 795
	return status;
#line 795
}
#line 795

static int
#line 796
putNCvx_uint_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 796
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 796
{
#line 796
	off_t offset = NC_varoffset(ncp, varp, start);
#line 796
	size_t remaining = varp->xsz * nelems;
#line 796
	int status = NC_NOERR;
#line 796
	void *xp;
#line 796
        void *fillp=NULL;
#line 796

#line 796
	if(nelems == 0)
#line 796
		return NC_NOERR;
#line 796

#line 796
	assert(value != NULL);
#line 796

#line 796
#ifdef ERANGE_FILL
#line 796
        fillp = malloc(varp->xsz);
#line 796
        status = NC3_inq_var_fill(varp, fillp);
#line 796
#endif
#line 796

#line 796
	for(;;)
#line 796
	{
#line 796
		size_t extent = MIN(remaining, ncp->chunk);
#line 796
		size_t nput = ncx_howmany(varp->type, extent);
#line 796

#line 796
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 796
				 RGN_WRITE, &xp);
#line 796
		if(lstatus != NC_NOERR)
#line 796
			return lstatus;
#line 796

#line 796
		lstatus = ncx_putn_uint_ulonglong(&xp, nput, value ,fillp);
#line 796
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 796
		{
#line 796
			/* not fatal to the loop */
#line 796
			status = lstatus;
#line 796
		}
#line 796

#line 796
		(void) ncio_rel(ncp->nciop, offset,
#line 796
				 RGN_MODIFIED);
#line 796

#line 796
		remaining -= extent;
#line 796
		if(remaining == 0)
#line 796
			break; /* normal loop exit */
#line 796
		offset += (off_t)extent;
#line 796
		value += nput;
#line 796

#line 796
	}
#line 796
#ifdef ERANGE_FILL
#line 796
        free(fillp);
#line 796
#endif
#line 796

#line 796
	return status;
#line 796
}
#line 796


static int
#line 798
putNCvx_longlong_schar(NC3_INFO* ncp, const NC_var *varp,
#line 798
		 const size_t *start, size_t nelems, const schar *value)
#line 798
{
#line 798
	off_t offset = NC_varoffset(ncp, varp, start);
#line 798
	size_t remaining = varp->xsz * nelems;
#line 798
	int status = NC_NOERR;
#line 798
	void *xp;
#line 798
        void *fillp=NULL;
#line 798

#line 798
	if(nelems == 0)
#line 798
		return NC_NOERR;
#line 798

#line 798
	assert(value != NULL);
#line 798

#line 798
#ifdef ERANGE_FILL
#line 798
        fillp = malloc(varp->xsz);
#line 798
        status = NC3_inq_var_fill(varp, fillp);
#line 798
#endif
#line 798

#line 798
	for(;;)
#line 798
	{
#line 798
		size_t extent = MIN(remaining, ncp->chunk);
#line 798
		size_t nput = ncx_howmany(varp->type, extent);
#line 798

#line 798
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 798
				 RGN_WRITE, &xp);
#line 798
		if(lstatus != NC_NOERR)
#line 798
			return lstatus;
#line 798

#line 798
		lstatus = ncx_putn_longlong_schar(&xp, nput, value ,fillp);
#line 798
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 798
		{
#line 798
			/* not fatal to the loop */
#line 798
			status = lstatus;
#line 798
		}
#line 798

#line 798
		(void) ncio_rel(ncp->nciop, offset,
#line 798
				 RGN_MODIFIED);
#line 798

#line 798
		remaining -= extent;
#line 798
		if(remaining == 0)
#line 798
			break; /* normal loop exit */
#line 798
		offset += (off_t)extent;
#line 798
		value += nput;
#line 798

#line 798
	}
#line 798
#ifdef ERANGE_FILL
#line 798
        free(fillp);
#line 798
#endif
#line 798

#line 798
	return status;
#line 798
}
#line 798

static int
#line 799
putNCvx_longlong_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 799
		 const size_t *start, size_t nelems, const uchar *value)
#line 799
{
#line 799
	off_t offset = NC_varoffset(ncp, varp, start);
#line 799
	size_t remaining = varp->xsz * nelems;
#line 799
	int status = NC_NOERR;
#line 799
	void *xp;
#line 799
        void *fillp=NULL;
#line 799

#line 799
	if(nelems == 0)
#line 799
		return NC_NOERR;
#line 799

#line 799
	assert(value != NULL);
#line 799

#line 799
#ifdef ERANGE_FILL
#line 799
        fillp = malloc(varp->xsz);
#line 799
        status = NC3_inq_var_fill(varp, fillp);
#line 799
#endif
#line 799

#line 799
	for(;;)
#line 799
	{
#line 799
		size_t extent = MIN(remaining, ncp->chunk);
#line 799
		size_t nput = ncx_howmany(varp->type, extent);
#line 799

#line 799
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 799
				 RGN_WRITE, &xp);
#line 799
		if(lstatus != NC_NOERR)
#line 799
			return lstatus;
#line 799

#line 799
		lstatus = ncx_putn_longlong_uchar(&xp, nput, value ,fillp);
#line 799
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 799
		{
#line 799
			/* not fatal to the loop */
#line 799
			status = lstatus;
#line 799
		}
#line 799

#line 799
		(void) ncio_rel(ncp->nciop, offset,
#line 799
				 RGN_MODIFIED);
#line 799

#line 799
		remaining -= extent;
#line 799
		if(remaining == 0)
#line 799
			break; /* normal loop exit */
#line 799
		offset += (off_t)extent;
#line 799
		value += nput;
#line 799

#line 799
	}
#line 799
#ifdef ERANGE_FILL
#line 799
        free(fillp);
#line 799
#endif
#line 799

#line 799
	return status;
#line 799
}
#line 799

static int
#line 800
putNCvx_longlong_short(NC3_INFO* ncp, const NC_var *varp,
#line 800
		 const size_t *start, size_t nelems, const short *value)
#line 800
{
#line 800
	off_t offset = NC_varoffset(ncp, varp, start);
#line 800
	size_t remaining = varp->xsz * nelems;
#line 800
	int status = NC_NOERR;
#line 800
	void *xp;
#line 800
        void *fillp=NULL;
#line 800

#line 800
	if(nelems == 0)
#line 800
		return NC_NOERR;
#line 800

#line 800
	assert(value != NULL);
#line 800

#line 800
#ifdef ERANGE_FILL
#line 800
        fillp = malloc(varp->xsz);
#line 800
        status = NC3_inq_var_fill(varp, fillp);
#line 800
#endif
#line 800

#line 800
	for(;;)
#line 800
	{
#line 800
		size_t extent = MIN(remaining, ncp->chunk);
#line 800
		size_t nput = ncx_howmany(varp->type, extent);
#line 800

#line 800
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 800
				 RGN_WRITE, &xp);
#line 800
		if(lstatus != NC_NOERR)
#line 800
			return lstatus;
#line 800

#line 800
		lstatus = ncx_putn_longlong_short(&xp, nput, value ,fillp);
#line 800
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 800
		{
#line 800
			/* not fatal to the loop */
#line 800
			status = lstatus;
#line 800
		}
#line 800

#line 800
		(void) ncio_rel(ncp->nciop, offset,
#line 800
				 RGN_MODIFIED);
#line 800

#line 800
		remaining -= extent;
#line 800
		if(remaining == 0)
#line 800
			break; /* normal loop exit */
#line 800
		offset += (off_t)extent;
#line 800
		value += nput;
#line 800

#line 800
	}
#line 800
#ifdef ERANGE_FILL
#line 800
        free(fillp);
#line 800
#endif
#line 800

#line 800
	return status;
#line 800
}
#line 800

static int
#line 801
putNCvx_longlong_int(NC3_INFO* ncp, const NC_var *varp,
#line 801
		 const size_t *start, size_t nelems, const int *value)
#line 801
{
#line 801
	off_t offset = NC_varoffset(ncp, varp, start);
#line 801
	size_t remaining = varp->xsz * nelems;
#line 801
	int status = NC_NOERR;
#line 801
	void *xp;
#line 801
        void *fillp=NULL;
#line 801

#line 801
	if(nelems == 0)
#line 801
		return NC_NOERR;
#line 801

#line 801
	assert(value != NULL);
#line 801

#line 801
#ifdef ERANGE_FILL
#line 801
        fillp = malloc(varp->xsz);
#line 801
        status = NC3_inq_var_fill(varp, fillp);
#line 801
#endif
#line 801

#line 801
	for(;;)
#line 801
	{
#line 801
		size_t extent = MIN(remaining, ncp->chunk);
#line 801
		size_t nput = ncx_howmany(varp->type, extent);
#line 801

#line 801
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 801
				 RGN_WRITE, &xp);
#line 801
		if(lstatus != NC_NOERR)
#line 801
			return lstatus;
#line 801

#line 801
		lstatus = ncx_putn_longlong_int(&xp, nput, value ,fillp);
#line 801
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 801
		{
#line 801
			/* not fatal to the loop */
#line 801
			status = lstatus;
#line 801
		}
#line 801

#line 801
		(void) ncio_rel(ncp->nciop, offset,
#line 801
				 RGN_MODIFIED);
#line 801

#line 801
		remaining -= extent;
#line 801
		if(remaining == 0)
#line 801
			break; /* normal loop exit */
#line 801
		offset += (off_t)extent;
#line 801
		value += nput;
#line 801

#line 801
	}
#line 801
#ifdef ERANGE_FILL
#line 801
        free(fillp);
#line 801
#endif
#line 801

#line 801
	return status;
#line 801
}
#line 801

static int
#line 802
putNCvx_longlong_float(NC3_INFO* ncp, const NC_var *varp,
#line 802
		 const size_t *start, size_t nelems, const float *value)
#line 802
{
#line 802
	off_t offset = NC_varoffset(ncp, varp, start);
#line 802
	size_t remaining = varp->xsz * nelems;
#line 802
	int status = NC_NOERR;
#line 802
	void *xp;
#line 802
        void *fillp=NULL;
#line 802

#line 802
	if(nelems == 0)
#line 802
		return NC_NOERR;
#line 802

#line 802
	assert(value != NULL);
#line 802

#line 802
#ifdef ERANGE_FILL
#line 802
        fillp = malloc(varp->xsz);
#line 802
        status = NC3_inq_var_fill(varp, fillp);
#line 802
#endif
#line 802

#line 802
	for(;;)
#line 802
	{
#line 802
		size_t extent = MIN(remaining, ncp->chunk);
#line 802
		size_t nput = ncx_howmany(varp->type, extent);
#line 802

#line 802
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 802
				 RGN_WRITE, &xp);
#line 802
		if(lstatus != NC_NOERR)
#line 802
			return lstatus;
#line 802

#line 802
		lstatus = ncx_putn_longlong_float(&xp, nput, value ,fillp);
#line 802
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 802
		{
#line 802
			/* not fatal to the loop */
#line 802
			status = lstatus;
#line 802
		}
#line 802

#line 802
		(void) ncio_rel(ncp->nciop, offset,
#line 802
				 RGN_MODIFIED);
#line 802

#line 802
		remaining -= extent;
#line 802
		if(remaining == 0)
#line 802
			break; /* normal loop exit */
#line 802
		offset += (off_t)extent;
#line 802
		value += nput;
#line 802

#line 802
	}
#line 802
#ifdef ERANGE_FILL
#line 802
        free(fillp);
#line 802
#endif
#line 802

#line 802
	return status;
#line 802
}
#line 802

static int
#line 803
putNCvx_longlong_double(NC3_INFO* ncp, const NC_var *varp,
#line 803
		 const size_t *start, size_t nelems, const double *value)
#line 803
{
#line 803
	off_t offset = NC_varoffset(ncp, varp, start);
#line 803
	size_t remaining = varp->xsz * nelems;
#line 803
	int status = NC_NOERR;
#line 803
	void *xp;
#line 803
        void *fillp=NULL;
#line 803

#line 803
	if(nelems == 0)
#line 803
		return NC_NOERR;
#line 803

#line 803
	assert(value != NULL);
#line 803

#line 803
#ifdef ERANGE_FILL
#line 803
        fillp = malloc(varp->xsz);
#line 803
        status = NC3_inq_var_fill(varp, fillp);
#line 803
#endif
#line 803

#line 803
	for(;;)
#line 803
	{
#line 803
		size_t extent = MIN(remaining, ncp->chunk);
#line 803
		size_t nput = ncx_howmany(varp->type, extent);
#line 803

#line 803
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 803
				 RGN_WRITE, &xp);
#line 803
		if(lstatus != NC_NOERR)
#line 803
			return lstatus;
#line 803

#line 803
		lstatus = ncx_putn_longlong_double(&xp, nput, value ,fillp);
#line 803
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 803
		{
#line 803
			/* not fatal to the loop */
#line 803
			status = lstatus;
#line 803
		}
#line 803

#line 803
		(void) ncio_rel(ncp->nciop, offset,
#line 803
				 RGN_MODIFIED);
#line 803

#line 803
		remaining -= extent;
#line 803
		if(remaining == 0)
#line 803
			break; /* normal loop exit */
#line 803
		offset += (off_t)extent;
#line 803
		value += nput;
#line 803

#line 803
	}
#line 803
#ifdef ERANGE_FILL
#line 803
        free(fillp);
#line 803
#endif
#line 803

#line 803
	return status;
#line 803
}
#line 803

static int
#line 804
putNCvx_longlong_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 804
		 const size_t *start, size_t nelems, const longlong *value)
#line 804
{
#line 804
	off_t offset = NC_varoffset(ncp, varp, start);
#line 804
	size_t remaining = varp->xsz * nelems;
#line 804
	int status = NC_NOERR;
#line 804
	void *xp;
#line 804
        void *fillp=NULL;
#line 804

#line 804
	if(nelems == 0)
#line 804
		return NC_NOERR;
#line 804

#line 804
	assert(value != NULL);
#line 804

#line 804
#ifdef ERANGE_FILL
#line 804
        fillp = malloc(varp->xsz);
#line 804
        status = NC3_inq_var_fill(varp, fillp);
#line 804
#endif
#line 804

#line 804
	for(;;)
#line 804
	{
#line 804
		size_t extent = MIN(remaining, ncp->chunk);
#line 804
		size_t nput = ncx_howmany(varp->type, extent);
#line 804

#line 804
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 804
				 RGN_WRITE, &xp);
#line 804
		if(lstatus != NC_NOERR)
#line 804
			return lstatus;
#line 804

#line 804
		lstatus = ncx_putn_longlong_longlong(&xp, nput, value ,fillp);
#line 804
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 804
		{
#line 804
			/* not fatal to the loop */
#line 804
			status = lstatus;
#line 804
		}
#line 804

#line 804
		(void) ncio_rel(ncp->nciop, offset,
#line 804
				 RGN_MODIFIED);
#line 804

#line 804
		remaining -= extent;
#line 804
		if(remaining == 0)
#line 804
			break; /* normal loop exit */
#line 804
		offset += (off_t)extent;
#line 804
		value += nput;
#line 804

#line 804
	}
#line 804
#ifdef ERANGE_FILL
#line 804
        free(fillp);
#line 804
#endif
#line 804

#line 804
	return status;
#line 804
}
#line 804

static int
#line 805
putNCvx_longlong_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 805
		 const size_t *start, size_t nelems, const ushort *value)
#line 805
{
#line 805
	off_t offset = NC_varoffset(ncp, varp, start);
#line 805
	size_t remaining = varp->xsz * nelems;
#line 805
	int status = NC_NOERR;
#line 805
	void *xp;
#line 805
        void *fillp=NULL;
#line 805

#line 805
	if(nelems == 0)
#line 805
		return NC_NOERR;
#line 805

#line 805
	assert(value != NULL);
#line 805

#line 805
#ifdef ERANGE_FILL
#line 805
        fillp = malloc(varp->xsz);
#line 805
        status = NC3_inq_var_fill(varp, fillp);
#line 805
#endif
#line 805

#line 805
	for(;;)
#line 805
	{
#line 805
		size_t extent = MIN(remaining, ncp->chunk);
#line 805
		size_t nput = ncx_howmany(varp->type, extent);
#line 805

#line 805
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 805
				 RGN_WRITE, &xp);
#line 805
		if(lstatus != NC_NOERR)
#line 805
			return lstatus;
#line 805

#line 805
		lstatus = ncx_putn_longlong_ushort(&xp, nput, value ,fillp);
#line 805
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 805
		{
#line 805
			/* not fatal to the loop */
#line 805
			status = lstatus;
#line 805
		}
#line 805

#line 805
		(void) ncio_rel(ncp->nciop, offset,
#line 805
				 RGN_MODIFIED);
#line 805

#line 805
		remaining -= extent;
#line 805
		if(remaining == 0)
#line 805
			break; /* normal loop exit */
#line 805
		offset += (off_t)extent;
#line 805
		value += nput;
#line 805

#line 805
	}
#line 805
#ifdef ERANGE_FILL
#line 805
        free(fillp);
#line 805
#endif
#line 805

#line 805
	return status;
#line 805
}
#line 805

static int
#line 806
putNCvx_longlong_uint(NC3_INFO* ncp, const NC_var *varp,
#line 806
		 const size_t *start, size_t nelems, const uint *value)
#line 806
{
#line 806
	off_t offset = NC_varoffset(ncp, varp, start);
#line 806
	size_t remaining = varp->xsz * nelems;
#line 806
	int status = NC_NOERR;
#line 806
	void *xp;
#line 806
        void *fillp=NULL;
#line 806

#line 806
	if(nelems == 0)
#line 806
		return NC_NOERR;
#line 806

#line 806
	assert(value != NULL);
#line 806

#line 806
#ifdef ERANGE_FILL
#line 806
        fillp = malloc(varp->xsz);
#line 806
        status = NC3_inq_var_fill(varp, fillp);
#line 806
#endif
#line 806

#line 806
	for(;;)
#line 806
	{
#line 806
		size_t extent = MIN(remaining, ncp->chunk);
#line 806
		size_t nput = ncx_howmany(varp->type, extent);
#line 806

#line 806
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 806
				 RGN_WRITE, &xp);
#line 806
		if(lstatus != NC_NOERR)
#line 806
			return lstatus;
#line 806

#line 806
		lstatus = ncx_putn_longlong_uint(&xp, nput, value ,fillp);
#line 806
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 806
		{
#line 806
			/* not fatal to the loop */
#line 806
			status = lstatus;
#line 806
		}
#line 806

#line 806
		(void) ncio_rel(ncp->nciop, offset,
#line 806
				 RGN_MODIFIED);
#line 806

#line 806
		remaining -= extent;
#line 806
		if(remaining == 0)
#line 806
			break; /* normal loop exit */
#line 806
		offset += (off_t)extent;
#line 806
		value += nput;
#line 806

#line 806
	}
#line 806
#ifdef ERANGE_FILL
#line 806
        free(fillp);
#line 806
#endif
#line 806

#line 806
	return status;
#line 806
}
#line 806

static int
#line 807
putNCvx_longlong_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 807
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 807
{
#line 807
	off_t offset = NC_varoffset(ncp, varp, start);
#line 807
	size_t remaining = varp->xsz * nelems;
#line 807
	int status = NC_NOERR;
#line 807
	void *xp;
#line 807
        void *fillp=NULL;
#line 807

#line 807
	if(nelems == 0)
#line 807
		return NC_NOERR;
#line 807

#line 807
	assert(value != NULL);
#line 807

#line 807
#ifdef ERANGE_FILL
#line 807
        fillp = malloc(varp->xsz);
#line 807
        status = NC3_inq_var_fill(varp, fillp);
#line 807
#endif
#line 807

#line 807
	for(;;)
#line 807
	{
#line 807
		size_t extent = MIN(remaining, ncp->chunk);
#line 807
		size_t nput = ncx_howmany(varp->type, extent);
#line 807

#line 807
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 807
				 RGN_WRITE, &xp);
#line 807
		if(lstatus != NC_NOERR)
#line 807
			return lstatus;
#line 807

#line 807
		lstatus = ncx_putn_longlong_ulonglong(&xp, nput, value ,fillp);
#line 807
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 807
		{
#line 807
			/* not fatal to the loop */
#line 807
			status = lstatus;
#line 807
		}
#line 807

#line 807
		(void) ncio_rel(ncp->nciop, offset,
#line 807
				 RGN_MODIFIED);
#line 807

#line 807
		remaining -= extent;
#line 807
		if(remaining == 0)
#line 807
			break; /* normal loop exit */
#line 807
		offset += (off_t)extent;
#line 807
		value += nput;
#line 807

#line 807
	}
#line 807
#ifdef ERANGE_FILL
#line 807
        free(fillp);
#line 807
#endif
#line 807

#line 807
	return status;
#line 807
}
#line 807


static int
#line 809
putNCvx_ulonglong_schar(NC3_INFO* ncp, const NC_var *varp,
#line 809
		 const size_t *start, size_t nelems, const schar *value)
#line 809
{
#line 809
	off_t offset = NC_varoffset(ncp, varp, start);
#line 809
	size_t remaining = varp->xsz * nelems;
#line 809
	int status = NC_NOERR;
#line 809
	void *xp;
#line 809
        void *fillp=NULL;
#line 809

#line 809
	if(nelems == 0)
#line 809
		return NC_NOERR;
#line 809

#line 809
	assert(value != NULL);
#line 809

#line 809
#ifdef ERANGE_FILL
#line 809
        fillp = malloc(varp->xsz);
#line 809
        status = NC3_inq_var_fill(varp, fillp);
#line 809
#endif
#line 809

#line 809
	for(;;)
#line 809
	{
#line 809
		size_t extent = MIN(remaining, ncp->chunk);
#line 809
		size_t nput = ncx_howmany(varp->type, extent);
#line 809

#line 809
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 809
				 RGN_WRITE, &xp);
#line 809
		if(lstatus != NC_NOERR)
#line 809
			return lstatus;
#line 809

#line 809
		lstatus = ncx_putn_ulonglong_schar(&xp, nput, value ,fillp);
#line 809
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 809
		{
#line 809
			/* not fatal to the loop */
#line 809
			status = lstatus;
#line 809
		}
#line 809

#line 809
		(void) ncio_rel(ncp->nciop, offset,
#line 809
				 RGN_MODIFIED);
#line 809

#line 809
		remaining -= extent;
#line 809
		if(remaining == 0)
#line 809
			break; /* normal loop exit */
#line 809
		offset += (off_t)extent;
#line 809
		value += nput;
#line 809

#line 809
	}
#line 809
#ifdef ERANGE_FILL
#line 809
        free(fillp);
#line 809
#endif
#line 809

#line 809
	return status;
#line 809
}
#line 809

static int
#line 810
putNCvx_ulonglong_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 810
		 const size_t *start, size_t nelems, const uchar *value)
#line 810
{
#line 810
	off_t offset = NC_varoffset(ncp, varp, start);
#line 810
	size_t remaining = varp->xsz * nelems;
#line 810
	int status = NC_NOERR;
#line 810
	void *xp;
#line 810
        void *fillp=NULL;
#line 810

#line 810
	if(nelems == 0)
#line 810
		return NC_NOERR;
#line 810

#line 810
	assert(value != NULL);
#line 810

#line 810
#ifdef ERANGE_FILL
#line 810
        fillp = malloc(varp->xsz);
#line 810
        status = NC3_inq_var_fill(varp, fillp);
#line 810
#endif
#line 810

#line 810
	for(;;)
#line 810
	{
#line 810
		size_t extent = MIN(remaining, ncp->chunk);
#line 810
		size_t nput = ncx_howmany(varp->type, extent);
#line 810

#line 810
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 810
				 RGN_WRITE, &xp);
#line 810
		if(lstatus != NC_NOERR)
#line 810
			return lstatus;
#line 810

#line 810
		lstatus = ncx_putn_ulonglong_uchar(&xp, nput, value ,fillp);
#line 810
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 810
		{
#line 810
			/* not fatal to the loop */
#line 810
			status = lstatus;
#line 810
		}
#line 810

#line 810
		(void) ncio_rel(ncp->nciop, offset,
#line 810
				 RGN_MODIFIED);
#line 810

#line 810
		remaining -= extent;
#line 810
		if(remaining == 0)
#line 810
			break; /* normal loop exit */
#line 810
		offset += (off_t)extent;
#line 810
		value += nput;
#line 810

#line 810
	}
#line 810
#ifdef ERANGE_FILL
#line 810
        free(fillp);
#line 810
#endif
#line 810

#line 810
	return status;
#line 810
}
#line 810

static int
#line 811
putNCvx_ulonglong_short(NC3_INFO* ncp, const NC_var *varp,
#line 811
		 const size_t *start, size_t nelems, const short *value)
#line 811
{
#line 811
	off_t offset = NC_varoffset(ncp, varp, start);
#line 811
	size_t remaining = varp->xsz * nelems;
#line 811
	int status = NC_NOERR;
#line 811
	void *xp;
#line 811
        void *fillp=NULL;
#line 811

#line 811
	if(nelems == 0)
#line 811
		return NC_NOERR;
#line 811

#line 811
	assert(value != NULL);
#line 811

#line 811
#ifdef ERANGE_FILL
#line 811
        fillp = malloc(varp->xsz);
#line 811
        status = NC3_inq_var_fill(varp, fillp);
#line 811
#endif
#line 811

#line 811
	for(;;)
#line 811
	{
#line 811
		size_t extent = MIN(remaining, ncp->chunk);
#line 811
		size_t nput = ncx_howmany(varp->type, extent);
#line 811

#line 811
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 811
				 RGN_WRITE, &xp);
#line 811
		if(lstatus != NC_NOERR)
#line 811
			return lstatus;
#line 811

#line 811
		lstatus = ncx_putn_ulonglong_short(&xp, nput, value ,fillp);
#line 811
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 811
		{
#line 811
			/* not fatal to the loop */
#line 811
			status = lstatus;
#line 811
		}
#line 811

#line 811
		(void) ncio_rel(ncp->nciop, offset,
#line 811
				 RGN_MODIFIED);
#line 811

#line 811
		remaining -= extent;
#line 811
		if(remaining == 0)
#line 811
			break; /* normal loop exit */
#line 811
		offset += (off_t)extent;
#line 811
		value += nput;
#line 811

#line 811
	}
#line 811
#ifdef ERANGE_FILL
#line 811
        free(fillp);
#line 811
#endif
#line 811

#line 811
	return status;
#line 811
}
#line 811

static int
#line 812
putNCvx_ulonglong_int(NC3_INFO* ncp, const NC_var *varp,
#line 812
		 const size_t *start, size_t nelems, const int *value)
#line 812
{
#line 812
	off_t offset = NC_varoffset(ncp, varp, start);
#line 812
	size_t remaining = varp->xsz * nelems;
#line 812
	int status = NC_NOERR;
#line 812
	void *xp;
#line 812
        void *fillp=NULL;
#line 812

#line 812
	if(nelems == 0)
#line 812
		return NC_NOERR;
#line 812

#line 812
	assert(value != NULL);
#line 812

#line 812
#ifdef ERANGE_FILL
#line 812
        fillp = malloc(varp->xsz);
#line 812
        status = NC3_inq_var_fill(varp, fillp);
#line 812
#endif
#line 812

#line 812
	for(;;)
#line 812
	{
#line 812
		size_t extent = MIN(remaining, ncp->chunk);
#line 812
		size_t nput = ncx_howmany(varp->type, extent);
#line 812

#line 812
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 812
				 RGN_WRITE, &xp);
#line 812
		if(lstatus != NC_NOERR)
#line 812
			return lstatus;
#line 812

#line 812
		lstatus = ncx_putn_ulonglong_int(&xp, nput, value ,fillp);
#line 812
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 812
		{
#line 812
			/* not fatal to the loop */
#line 812
			status = lstatus;
#line 812
		}
#line 812

#line 812
		(void) ncio_rel(ncp->nciop, offset,
#line 812
				 RGN_MODIFIED);
#line 812

#line 812
		remaining -= extent;
#line 812
		if(remaining == 0)
#line 812
			break; /* normal loop exit */
#line 812
		offset += (off_t)extent;
#line 812
		value += nput;
#line 812

#line 812
	}
#line 812
#ifdef ERANGE_FILL
#line 812
        free(fillp);
#line 812
#endif
#line 812

#line 812
	return status;
#line 812
}
#line 812

static int
#line 813
putNCvx_ulonglong_float(NC3_INFO* ncp, const NC_var *varp,
#line 813
		 const size_t *start, size_t nelems, const float *value)
#line 813
{
#line 813
	off_t offset = NC_varoffset(ncp, varp, start);
#line 813
	size_t remaining = varp->xsz * nelems;
#line 813
	int status = NC_NOERR;
#line 813
	void *xp;
#line 813
        void *fillp=NULL;
#line 813

#line 813
	if(nelems == 0)
#line 813
		return NC_NOERR;
#line 813

#line 813
	assert(value != NULL);
#line 813

#line 813
#ifdef ERANGE_FILL
#line 813
        fillp = malloc(varp->xsz);
#line 813
        status = NC3_inq_var_fill(varp, fillp);
#line 813
#endif
#line 813

#line 813
	for(;;)
#line 813
	{
#line 813
		size_t extent = MIN(remaining, ncp->chunk);
#line 813
		size_t nput = ncx_howmany(varp->type, extent);
#line 813

#line 813
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 813
				 RGN_WRITE, &xp);
#line 813
		if(lstatus != NC_NOERR)
#line 813
			return lstatus;
#line 813

#line 813
		lstatus = ncx_putn_ulonglong_float(&xp, nput, value ,fillp);
#line 813
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 813
		{
#line 813
			/* not fatal to the loop */
#line 813
			status = lstatus;
#line 813
		}
#line 813

#line 813
		(void) ncio_rel(ncp->nciop, offset,
#line 813
				 RGN_MODIFIED);
#line 813

#line 813
		remaining -= extent;
#line 813
		if(remaining == 0)
#line 813
			break; /* normal loop exit */
#line 813
		offset += (off_t)extent;
#line 813
		value += nput;
#line 813

#line 813
	}
#line 813
#ifdef ERANGE_FILL
#line 813
        free(fillp);
#line 813
#endif
#line 813

#line 813
	return status;
#line 813
}
#line 813

static int
#line 814
putNCvx_ulonglong_double(NC3_INFO* ncp, const NC_var *varp,
#line 814
		 const size_t *start, size_t nelems, const double *value)
#line 814
{
#line 814
	off_t offset = NC_varoffset(ncp, varp, start);
#line 814
	size_t remaining = varp->xsz * nelems;
#line 814
	int status = NC_NOERR;
#line 814
	void *xp;
#line 814
        void *fillp=NULL;
#line 814

#line 814
	if(nelems == 0)
#line 814
		return NC_NOERR;
#line 814

#line 814
	assert(value != NULL);
#line 814

#line 814
#ifdef ERANGE_FILL
#line 814
        fillp = malloc(varp->xsz);
#line 814
        status = NC3_inq_var_fill(varp, fillp);
#line 814
#endif
#line 814

#line 814
	for(;;)
#line 814
	{
#line 814
		size_t extent = MIN(remaining, ncp->chunk);
#line 814
		size_t nput = ncx_howmany(varp->type, extent);
#line 814

#line 814
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 814
				 RGN_WRITE, &xp);
#line 814
		if(lstatus != NC_NOERR)
#line 814
			return lstatus;
#line 814

#line 814
		lstatus = ncx_putn_ulonglong_double(&xp, nput, value ,fillp);
#line 814
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 814
		{
#line 814
			/* not fatal to the loop */
#line 814
			status = lstatus;
#line 814
		}
#line 814

#line 814
		(void) ncio_rel(ncp->nciop, offset,
#line 814
				 RGN_MODIFIED);
#line 814

#line 814
		remaining -= extent;
#line 814
		if(remaining == 0)
#line 814
			break; /* normal loop exit */
#line 814
		offset += (off_t)extent;
#line 814
		value += nput;
#line 814

#line 814
	}
#line 814
#ifdef ERANGE_FILL
#line 814
        free(fillp);
#line 814
#endif
#line 814

#line 814
	return status;
#line 814
}
#line 814

static int
#line 815
putNCvx_ulonglong_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 815
		 const size_t *start, size_t nelems, const longlong *value)
#line 815
{
#line 815
	off_t offset = NC_varoffset(ncp, varp, start);
#line 815
	size_t remaining = varp->xsz * nelems;
#line 815
	int status = NC_NOERR;
#line 815
	void *xp;
#line 815
        void *fillp=NULL;
#line 815

#line 815
	if(nelems == 0)
#line 815
		return NC_NOERR;
#line 815

#line 815
	assert(value != NULL);
#line 815

#line 815
#ifdef ERANGE_FILL
#line 815
        fillp = malloc(varp->xsz);
#line 815
        status = NC3_inq_var_fill(varp, fillp);
#line 815
#endif
#line 815

#line 815
	for(;;)
#line 815
	{
#line 815
		size_t extent = MIN(remaining, ncp->chunk);
#line 815
		size_t nput = ncx_howmany(varp->type, extent);
#line 815

#line 815
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 815
				 RGN_WRITE, &xp);
#line 815
		if(lstatus != NC_NOERR)
#line 815
			return lstatus;
#line 815

#line 815
		lstatus = ncx_putn_ulonglong_longlong(&xp, nput, value ,fillp);
#line 815
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 815
		{
#line 815
			/* not fatal to the loop */
#line 815
			status = lstatus;
#line 815
		}
#line 815

#line 815
		(void) ncio_rel(ncp->nciop, offset,
#line 815
				 RGN_MODIFIED);
#line 815

#line 815
		remaining -= extent;
#line 815
		if(remaining == 0)
#line 815
			break; /* normal loop exit */
#line 815
		offset += (off_t)extent;
#line 815
		value += nput;
#line 815

#line 815
	}
#line 815
#ifdef ERANGE_FILL
#line 815
        free(fillp);
#line 815
#endif
#line 815

#line 815
	return status;
#line 815
}
#line 815

static int
#line 816
putNCvx_ulonglong_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 816
		 const size_t *start, size_t nelems, const ushort *value)
#line 816
{
#line 816
	off_t offset = NC_varoffset(ncp, varp, start);
#line 816
	size_t remaining = varp->xsz * nelems;
#line 816
	int status = NC_NOERR;
#line 816
	void *xp;
#line 816
        void *fillp=NULL;
#line 816

#line 816
	if(nelems == 0)
#line 816
		return NC_NOERR;
#line 816

#line 816
	assert(value != NULL);
#line 816

#line 816
#ifdef ERANGE_FILL
#line 816
        fillp = malloc(varp->xsz);
#line 816
        status = NC3_inq_var_fill(varp, fillp);
#line 816
#endif
#line 816

#line 816
	for(;;)
#line 816
	{
#line 816
		size_t extent = MIN(remaining, ncp->chunk);
#line 816
		size_t nput = ncx_howmany(varp->type, extent);
#line 816

#line 816
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 816
				 RGN_WRITE, &xp);
#line 816
		if(lstatus != NC_NOERR)
#line 816
			return lstatus;
#line 816

#line 816
		lstatus = ncx_putn_ulonglong_ushort(&xp, nput, value ,fillp);
#line 816
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 816
		{
#line 816
			/* not fatal to the loop */
#line 816
			status = lstatus;
#line 816
		}
#line 816

#line 816
		(void) ncio_rel(ncp->nciop, offset,
#line 816
				 RGN_MODIFIED);
#line 816

#line 816
		remaining -= extent;
#line 816
		if(remaining == 0)
#line 816
			break; /* normal loop exit */
#line 816
		offset += (off_t)extent;
#line 816
		value += nput;
#line 816

#line 816
	}
#line 816
#ifdef ERANGE_FILL
#line 816
        free(fillp);
#line 816
#endif
#line 816

#line 816
	return status;
#line 816
}
#line 816

static int
#line 817
putNCvx_ulonglong_uint(NC3_INFO* ncp, const NC_var *varp,
#line 817
		 const size_t *start, size_t nelems, const uint *value)
#line 817
{
#line 817
	off_t offset = NC_varoffset(ncp, varp, start);
#line 817
	size_t remaining = varp->xsz * nelems;
#line 817
	int status = NC_NOERR;
#line 817
	void *xp;
#line 817
        void *fillp=NULL;
#line 817

#line 817
	if(nelems == 0)
#line 817
		return NC_NOERR;
#line 817

#line 817
	assert(value != NULL);
#line 817

#line 817
#ifdef ERANGE_FILL
#line 817
        fillp = malloc(varp->xsz);
#line 817
        status = NC3_inq_var_fill(varp, fillp);
#line 817
#endif
#line 817

#line 817
	for(;;)
#line 817
	{
#line 817
		size_t extent = MIN(remaining, ncp->chunk);
#line 817
		size_t nput = ncx_howmany(varp->type, extent);
#line 817

#line 817
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 817
				 RGN_WRITE, &xp);
#line 817
		if(lstatus != NC_NOERR)
#line 817
			return lstatus;
#line 817

#line 817
		lstatus = ncx_putn_ulonglong_uint(&xp, nput, value ,fillp);
#line 817
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 817
		{
#line 817
			/* not fatal to the loop */
#line 817
			status = lstatus;
#line 817
		}
#line 817

#line 817
		(void) ncio_rel(ncp->nciop, offset,
#line 817
				 RGN_MODIFIED);
#line 817

#line 817
		remaining -= extent;
#line 817
		if(remaining == 0)
#line 817
			break; /* normal loop exit */
#line 817
		offset += (off_t)extent;
#line 817
		value += nput;
#line 817

#line 817
	}
#line 817
#ifdef ERANGE_FILL
#line 817
        free(fillp);
#line 817
#endif
#line 817

#line 817
	return status;
#line 817
}
#line 817

static int
#line 818
putNCvx_ulonglong_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 818
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 818
{
#line 818
	off_t offset = NC_varoffset(ncp, varp, start);
#line 818
	size_t remaining = varp->xsz * nelems;
#line 818
	int status = NC_NOERR;
#line 818
	void *xp;
#line 818
        void *fillp=NULL;
#line 818

#line 818
	if(nelems == 0)
#line 818
		return NC_NOERR;
#line 818

#line 818
	assert(value != NULL);
#line 818

#line 818
#ifdef ERANGE_FILL
#line 818
        fillp = malloc(varp->xsz);
#line 818
        status = NC3_inq_var_fill(varp, fillp);
#line 818
#endif
#line 818

#line 818
	for(;;)
#line 818
	{
#line 818
		size_t extent = MIN(remaining, ncp->chunk);
#line 818
		size_t nput = ncx_howmany(varp->type, extent);
#line 818

#line 818
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 818
				 RGN_WRITE, &xp);
#line 818
		if(lstatus != NC_NOERR)
#line 818
			return lstatus;
#line 818

#line 818
		lstatus = ncx_putn_ulonglong_ulonglong(&xp, nput, value ,fillp);
#line 818
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 818
		{
#line 818
			/* not fatal to the loop */
#line 818
			status = lstatus;
#line 818
		}
#line 818

#line 818
		(void) ncio_rel(ncp->nciop, offset,
#line 818
				 RGN_MODIFIED);
#line 818

#line 818
		remaining -= extent;
#line 818
		if(remaining == 0)
#line 818
			break; /* normal loop exit */
#line 818
		offset += (off_t)extent;
#line 818
		value += nput;
#line 818

#line 818
	}
#line 818
#ifdef ERANGE_FILL
#line 818
        free(fillp);
#line 818
#endif
#line 818

#line 818
	return status;
#line 818
}
#line 818


#line 865

static int
#line 866
getNCvx_char_char(const NC3_INFO* ncp, const NC_var *varp,
#line 866
		 const size_t *start, size_t nelems, char *value)
#line 866
{
#line 866
	off_t offset = NC_varoffset(ncp, varp, start);
#line 866
	size_t remaining = varp->xsz * nelems;
#line 866
	int status = NC_NOERR;
#line 866
	const void *xp;
#line 866

#line 866
	if(nelems == 0)
#line 866
		return NC_NOERR;
#line 866

#line 866
	assert(value != NULL);
#line 866

#line 866
	for(;;)
#line 866
	{
#line 866
		size_t extent = MIN(remaining, ncp->chunk);
#line 866
		size_t nget = ncx_howmany(varp->type, extent);
#line 866

#line 866
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 866
				 0, (void **)&xp);	/* cast away const */
#line 866
		if(lstatus != NC_NOERR)
#line 866
			return lstatus;
#line 866

#line 866
		lstatus = ncx_getn_char_char(&xp, nget, value);
#line 866
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 866
			status = lstatus;
#line 866

#line 866
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 866

#line 866
		remaining -= extent;
#line 866
		if(remaining == 0)
#line 866
			break; /* normal loop exit */
#line 866
		offset += (off_t)extent;
#line 866
		value += nget;
#line 866
	}
#line 866

#line 866
	return status;
#line 866
}
#line 866


static int
#line 868
getNCvx_schar_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 868
		 const size_t *start, size_t nelems, schar *value)
#line 868
{
#line 868
	off_t offset = NC_varoffset(ncp, varp, start);
#line 868
	size_t remaining = varp->xsz * nelems;
#line 868
	int status = NC_NOERR;
#line 868
	const void *xp;
#line 868

#line 868
	if(nelems == 0)
#line 868
		return NC_NOERR;
#line 868

#line 868
	assert(value != NULL);
#line 868

#line 868
	for(;;)
#line 868
	{
#line 868
		size_t extent = MIN(remaining, ncp->chunk);
#line 868
		size_t nget = ncx_howmany(varp->type, extent);
#line 868

#line 868
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 868
				 0, (void **)&xp);	/* cast away const */
#line 868
		if(lstatus != NC_NOERR)
#line 868
			return lstatus;
#line 868

#line 868
		lstatus = ncx_getn_schar_schar(&xp, nget, value);
#line 868
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 868
			status = lstatus;
#line 868

#line 868
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 868

#line 868
		remaining -= extent;
#line 868
		if(remaining == 0)
#line 868
			break; /* normal loop exit */
#line 868
		offset += (off_t)extent;
#line 868
		value += nget;
#line 868
	}
#line 868

#line 868
	return status;
#line 868
}
#line 868

static int
#line 869
getNCvx_schar_short(const NC3_INFO* ncp, const NC_var *varp,
#line 869
		 const size_t *start, size_t nelems, short *value)
#line 869
{
#line 869
	off_t offset = NC_varoffset(ncp, varp, start);
#line 869
	size_t remaining = varp->xsz * nelems;
#line 869
	int status = NC_NOERR;
#line 869
	const void *xp;
#line 869

#line 869
	if(nelems == 0)
#line 869
		return NC_NOERR;
#line 869

#line 869
	assert(value != NULL);
#line 869

#line 869
	for(;;)
#line 869
	{
#line 869
		size_t extent = MIN(remaining, ncp->chunk);
#line 869
		size_t nget = ncx_howmany(varp->type, extent);
#line 869

#line 869
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 869
				 0, (void **)&xp);	/* cast away const */
#line 869
		if(lstatus != NC_NOERR)
#line 869
			return lstatus;
#line 869

#line 869
		lstatus = ncx_getn_schar_short(&xp, nget, value);
#line 869
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 869
			status = lstatus;
#line 869

#line 869
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 869

#line 869
		remaining -= extent;
#line 869
		if(remaining == 0)
#line 869
			break; /* normal loop exit */
#line 869
		offset += (off_t)extent;
#line 869
		value += nget;
#line 869
	}
#line 869

#line 869
	return status;
#line 869
}
#line 869

static int
#line 870
getNCvx_schar_int(const NC3_INFO* ncp, const NC_var *varp,
#line 870
		 const size_t *start, size_t nelems, int *value)
#line 870
{
#line 870
	off_t offset = NC_varoffset(ncp, varp, start);
#line 870
	size_t remaining = varp->xsz * nelems;
#line 870
	int status = NC_NOERR;
#line 870
	const void *xp;
#line 870

#line 870
	if(nelems == 0)
#line 870
		return NC_NOERR;
#line 870

#line 870
	assert(value != NULL);
#line 870

#line 870
	for(;;)
#line 870
	{
#line 870
		size_t extent = MIN(remaining, ncp->chunk);
#line 870
		size_t nget = ncx_howmany(varp->type, extent);
#line 870

#line 870
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 870
				 0, (void **)&xp);	/* cast away const */
#line 870
		if(lstatus != NC_NOERR)
#line 870
			return lstatus;
#line 870

#line 870
		lstatus = ncx_getn_schar_int(&xp, nget, value);
#line 870
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 870
			status = lstatus;
#line 870

#line 870
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 870

#line 870
		remaining -= extent;
#line 870
		if(remaining == 0)
#line 870
			break; /* normal loop exit */
#line 870
		offset += (off_t)extent;
#line 870
		value += nget;
#line 870
	}
#line 870

#line 870
	return status;
#line 870
}
#line 870

static int
#line 871
getNCvx_schar_float(const NC3_INFO* ncp, const NC_var *varp,
#line 871
		 const size_t *start, size_t nelems, float *value)
#line 871
{
#line 871
	off_t offset = NC_varoffset(ncp, varp, start);
#line 871
	size_t remaining = varp->xsz * nelems;
#line 871
	int status = NC_NOERR;
#line 871
	const void *xp;
#line 871

#line 871
	if(nelems == 0)
#line 871
		return NC_NOERR;
#line 871

#line 871
	assert(value != NULL);
#line 871

#line 871
	for(;;)
#line 871
	{
#line 871
		size_t extent = MIN(remaining, ncp->chunk);
#line 871
		size_t nget = ncx_howmany(varp->type, extent);
#line 871

#line 871
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 871
				 0, (void **)&xp);	/* cast away const */
#line 871
		if(lstatus != NC_NOERR)
#line 871
			return lstatus;
#line 871

#line 871
		lstatus = ncx_getn_schar_float(&xp, nget, value);
#line 871
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 871
			status = lstatus;
#line 871

#line 871
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 871

#line 871
		remaining -= extent;
#line 871
		if(remaining == 0)
#line 871
			break; /* normal loop exit */
#line 871
		offset += (off_t)extent;
#line 871
		value += nget;
#line 871
	}
#line 871

#line 871
	return status;
#line 871
}
#line 871

static int
#line 872
getNCvx_schar_double(const NC3_INFO* ncp, const NC_var *varp,
#line 872
		 const size_t *start, size_t nelems, double *value)
#line 872
{
#line 872
	off_t offset = NC_varoffset(ncp, varp, start);
#line 872
	size_t remaining = varp->xsz * nelems;
#line 872
	int status = NC_NOERR;
#line 872
	const void *xp;
#line 872

#line 872
	if(nelems == 0)
#line 872
		return NC_NOERR;
#line 872

#line 872
	assert(value != NULL);
#line 872

#line 872
	for(;;)
#line 872
	{
#line 872
		size_t extent = MIN(remaining, ncp->chunk);
#line 872
		size_t nget = ncx_howmany(varp->type, extent);
#line 872

#line 872
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 872
				 0, (void **)&xp);	/* cast away const */
#line 872
		if(lstatus != NC_NOERR)
#line 872
			return lstatus;
#line 872

#line 872
		lstatus = ncx_getn_schar_double(&xp, nget, value);
#line 872
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 872
			status = lstatus;
#line 872

#line 872
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 872

#line 872
		remaining -= extent;
#line 872
		if(remaining == 0)
#line 872
			break; /* normal loop exit */
#line 872
		offset += (off_t)extent;
#line 872
		value += nget;
#line 872
	}
#line 872

#line 872
	return status;
#line 872
}
#line 872

static int
#line 873
getNCvx_schar_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 873
		 const size_t *start, size_t nelems, longlong *value)
#line 873
{
#line 873
	off_t offset = NC_varoffset(ncp, varp, start);
#line 873
	size_t remaining = varp->xsz * nelems;
#line 873
	int status = NC_NOERR;
#line 873
	const void *xp;
#line 873

#line 873
	if(nelems == 0)
#line 873
		return NC_NOERR;
#line 873

#line 873
	assert(value != NULL);
#line 873

#line 873
	for(;;)
#line 873
	{
#line 873
		size_t extent = MIN(remaining, ncp->chunk);
#line 873
		size_t nget = ncx_howmany(varp->type, extent);
#line 873

#line 873
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 873
				 0, (void **)&xp);	/* cast away const */
#line 873
		if(lstatus != NC_NOERR)
#line 873
			return lstatus;
#line 873

#line 873
		lstatus = ncx_getn_schar_longlong(&xp, nget, value);
#line 873
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 873
			status = lstatus;
#line 873

#line 873
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 873

#line 873
		remaining -= extent;
#line 873
		if(remaining == 0)
#line 873
			break; /* normal loop exit */
#line 873
		offset += (off_t)extent;
#line 873
		value += nget;
#line 873
	}
#line 873

#line 873
	return status;
#line 873
}
#line 873

static int
#line 874
getNCvx_schar_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 874
		 const size_t *start, size_t nelems, uint *value)
#line 874
{
#line 874
	off_t offset = NC_varoffset(ncp, varp, start);
#line 874
	size_t remaining = varp->xsz * nelems;
#line 874
	int status = NC_NOERR;
#line 874
	const void *xp;
#line 874

#line 874
	if(nelems == 0)
#line 874
		return NC_NOERR;
#line 874

#line 874
	assert(value != NULL);
#line 874

#line 874
	for(;;)
#line 874
	{
#line 874
		size_t extent = MIN(remaining, ncp->chunk);
#line 874
		size_t nget = ncx_howmany(varp->type, extent);
#line 874

#line 874
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 874
				 0, (void **)&xp);	/* cast away const */
#line 874
		if(lstatus != NC_NOERR)
#line 874
			return lstatus;
#line 874

#line 874
		lstatus = ncx_getn_schar_uint(&xp, nget, value);
#line 874
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 874
			status = lstatus;
#line 874

#line 874
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 874

#line 874
		remaining -= extent;
#line 874
		if(remaining == 0)
#line 874
			break; /* normal loop exit */
#line 874
		offset += (off_t)extent;
#line 874
		value += nget;
#line 874
	}
#line 874

#line 874
	return status;
#line 874
}
#line 874

static int
#line 875
getNCvx_schar_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 875
		 const size_t *start, size_t nelems, ulonglong *value)
#line 875
{
#line 875
	off_t offset = NC_varoffset(ncp, varp, start);
#line 875
	size_t remaining = varp->xsz * nelems;
#line 875
	int status = NC_NOERR;
#line 875
	const void *xp;
#line 875

#line 875
	if(nelems == 0)
#line 875
		return NC_NOERR;
#line 875

#line 875
	assert(value != NULL);
#line 875

#line 875
	for(;;)
#line 875
	{
#line 875
		size_t extent = MIN(remaining, ncp->chunk);
#line 875
		size_t nget = ncx_howmany(varp->type, extent);
#line 875

#line 875
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 875
				 0, (void **)&xp);	/* cast away const */
#line 875
		if(lstatus != NC_NOERR)
#line 875
			return lstatus;
#line 875

#line 875
		lstatus = ncx_getn_schar_ulonglong(&xp, nget, value);
#line 875
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 875
			status = lstatus;
#line 875

#line 875
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 875

#line 875
		remaining -= extent;
#line 875
		if(remaining == 0)
#line 875
			break; /* normal loop exit */
#line 875
		offset += (off_t)extent;
#line 875
		value += nget;
#line 875
	}
#line 875

#line 875
	return status;
#line 875
}
#line 875

static int
#line 876
getNCvx_schar_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 876
		 const size_t *start, size_t nelems, uchar *value)
#line 876
{
#line 876
	off_t offset = NC_varoffset(ncp, varp, start);
#line 876
	size_t remaining = varp->xsz * nelems;
#line 876
	int status = NC_NOERR;
#line 876
	const void *xp;
#line 876

#line 876
	if(nelems == 0)
#line 876
		return NC_NOERR;
#line 876

#line 876
	assert(value != NULL);
#line 876

#line 876
	for(;;)
#line 876
	{
#line 876
		size_t extent = MIN(remaining, ncp->chunk);
#line 876
		size_t nget = ncx_howmany(varp->type, extent);
#line 876

#line 876
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 876
				 0, (void **)&xp);	/* cast away const */
#line 876
		if(lstatus != NC_NOERR)
#line 876
			return lstatus;
#line 876

#line 876
		lstatus = ncx_getn_schar_uchar(&xp, nget, value);
#line 876
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 876
			status = lstatus;
#line 876

#line 876
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 876

#line 876
		remaining -= extent;
#line 876
		if(remaining == 0)
#line 876
			break; /* normal loop exit */
#line 876
		offset += (off_t)extent;
#line 876
		value += nget;
#line 876
	}
#line 876

#line 876
	return status;
#line 876
}
#line 876

static int
#line 877
getNCvx_schar_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 877
		 const size_t *start, size_t nelems, ushort *value)
#line 877
{
#line 877
	off_t offset = NC_varoffset(ncp, varp, start);
#line 877
	size_t remaining = varp->xsz * nelems;
#line 877
	int status = NC_NOERR;
#line 877
	const void *xp;
#line 877

#line 877
	if(nelems == 0)
#line 877
		return NC_NOERR;
#line 877

#line 877
	assert(value != NULL);
#line 877

#line 877
	for(;;)
#line 877
	{
#line 877
		size_t extent = MIN(remaining, ncp->chunk);
#line 877
		size_t nget = ncx_howmany(varp->type, extent);
#line 877

#line 877
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 877
				 0, (void **)&xp);	/* cast away const */
#line 877
		if(lstatus != NC_NOERR)
#line 877
			return lstatus;
#line 877

#line 877
		lstatus = ncx_getn_schar_ushort(&xp, nget, value);
#line 877
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 877
			status = lstatus;
#line 877

#line 877
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 877

#line 877
		remaining -= extent;
#line 877
		if(remaining == 0)
#line 877
			break; /* normal loop exit */
#line 877
		offset += (off_t)extent;
#line 877
		value += nget;
#line 877
	}
#line 877

#line 877
	return status;
#line 877
}
#line 877


static int
#line 879
getNCvx_short_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 879
		 const size_t *start, size_t nelems, schar *value)
#line 879
{
#line 879
	off_t offset = NC_varoffset(ncp, varp, start);
#line 879
	size_t remaining = varp->xsz * nelems;
#line 879
	int status = NC_NOERR;
#line 879
	const void *xp;
#line 879

#line 879
	if(nelems == 0)
#line 879
		return NC_NOERR;
#line 879

#line 879
	assert(value != NULL);
#line 879

#line 879
	for(;;)
#line 879
	{
#line 879
		size_t extent = MIN(remaining, ncp->chunk);
#line 879
		size_t nget = ncx_howmany(varp->type, extent);
#line 879

#line 879
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 879
				 0, (void **)&xp);	/* cast away const */
#line 879
		if(lstatus != NC_NOERR)
#line 879
			return lstatus;
#line 879

#line 879
		lstatus = ncx_getn_short_schar(&xp, nget, value);
#line 879
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 879
			status = lstatus;
#line 879

#line 879
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 879

#line 879
		remaining -= extent;
#line 879
		if(remaining == 0)
#line 879
			break; /* normal loop exit */
#line 879
		offset += (off_t)extent;
#line 879
		value += nget;
#line 879
	}
#line 879

#line 879
	return status;
#line 879
}
#line 879

static int
#line 880
getNCvx_short_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 880
		 const size_t *start, size_t nelems, uchar *value)
#line 880
{
#line 880
	off_t offset = NC_varoffset(ncp, varp, start);
#line 880
	size_t remaining = varp->xsz * nelems;
#line 880
	int status = NC_NOERR;
#line 880
	const void *xp;
#line 880

#line 880
	if(nelems == 0)
#line 880
		return NC_NOERR;
#line 880

#line 880
	assert(value != NULL);
#line 880

#line 880
	for(;;)
#line 880
	{
#line 880
		size_t extent = MIN(remaining, ncp->chunk);
#line 880
		size_t nget = ncx_howmany(varp->type, extent);
#line 880

#line 880
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 880
				 0, (void **)&xp);	/* cast away const */
#line 880
		if(lstatus != NC_NOERR)
#line 880
			return lstatus;
#line 880

#line 880
		lstatus = ncx_getn_short_uchar(&xp, nget, value);
#line 880
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 880
			status = lstatus;
#line 880

#line 880
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 880

#line 880
		remaining -= extent;
#line 880
		if(remaining == 0)
#line 880
			break; /* normal loop exit */
#line 880
		offset += (off_t)extent;
#line 880
		value += nget;
#line 880
	}
#line 880

#line 880
	return status;
#line 880
}
#line 880

static int
#line 881
getNCvx_short_short(const NC3_INFO* ncp, const NC_var *varp,
#line 881
		 const size_t *start, size_t nelems, short *value)
#line 881
{
#line 881
	off_t offset = NC_varoffset(ncp, varp, start);
#line 881
	size_t remaining = varp->xsz * nelems;
#line 881
	int status = NC_NOERR;
#line 881
	const void *xp;
#line 881

#line 881
	if(nelems == 0)
#line 881
		return NC_NOERR;
#line 881

#line 881
	assert(value != NULL);
#line 881

#line 881
	for(;;)
#line 881
	{
#line 881
		size_t extent = MIN(remaining, ncp->chunk);
#line 881
		size_t nget = ncx_howmany(varp->type, extent);
#line 881

#line 881
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 881
				 0, (void **)&xp);	/* cast away const */
#line 881
		if(lstatus != NC_NOERR)
#line 881
			return lstatus;
#line 881

#line 881
		lstatus = ncx_getn_short_short(&xp, nget, value);
#line 881
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 881
			status = lstatus;
#line 881

#line 881
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 881

#line 881
		remaining -= extent;
#line 881
		if(remaining == 0)
#line 881
			break; /* normal loop exit */
#line 881
		offset += (off_t)extent;
#line 881
		value += nget;
#line 881
	}
#line 881

#line 881
	return status;
#line 881
}
#line 881

static int
#line 882
getNCvx_short_int(const NC3_INFO* ncp, const NC_var *varp,
#line 882
		 const size_t *start, size_t nelems, int *value)
#line 882
{
#line 882
	off_t offset = NC_varoffset(ncp, varp, start);
#line 882
	size_t remaining = varp->xsz * nelems;
#line 882
	int status = NC_NOERR;
#line 882
	const void *xp;
#line 882

#line 882
	if(nelems == 0)
#line 882
		return NC_NOERR;
#line 882

#line 882
	assert(value != NULL);
#line 882

#line 882
	for(;;)
#line 882
	{
#line 882
		size_t extent = MIN(remaining, ncp->chunk);
#line 882
		size_t nget = ncx_howmany(varp->type, extent);
#line 882

#line 882
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 882
				 0, (void **)&xp);	/* cast away const */
#line 882
		if(lstatus != NC_NOERR)
#line 882
			return lstatus;
#line 882

#line 882
		lstatus = ncx_getn_short_int(&xp, nget, value);
#line 882
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 882
			status = lstatus;
#line 882

#line 882
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 882

#line 882
		remaining -= extent;
#line 882
		if(remaining == 0)
#line 882
			break; /* normal loop exit */
#line 882
		offset += (off_t)extent;
#line 882
		value += nget;
#line 882
	}
#line 882

#line 882
	return status;
#line 882
}
#line 882

static int
#line 883
getNCvx_short_float(const NC3_INFO* ncp, const NC_var *varp,
#line 883
		 const size_t *start, size_t nelems, float *value)
#line 883
{
#line 883
	off_t offset = NC_varoffset(ncp, varp, start);
#line 883
	size_t remaining = varp->xsz * nelems;
#line 883
	int status = NC_NOERR;
#line 883
	const void *xp;
#line 883

#line 883
	if(nelems == 0)
#line 883
		return NC_NOERR;
#line 883

#line 883
	assert(value != NULL);
#line 883

#line 883
	for(;;)
#line 883
	{
#line 883
		size_t extent = MIN(remaining, ncp->chunk);
#line 883
		size_t nget = ncx_howmany(varp->type, extent);
#line 883

#line 883
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 883
				 0, (void **)&xp);	/* cast away const */
#line 883
		if(lstatus != NC_NOERR)
#line 883
			return lstatus;
#line 883

#line 883
		lstatus = ncx_getn_short_float(&xp, nget, value);
#line 883
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 883
			status = lstatus;
#line 883

#line 883
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 883

#line 883
		remaining -= extent;
#line 883
		if(remaining == 0)
#line 883
			break; /* normal loop exit */
#line 883
		offset += (off_t)extent;
#line 883
		value += nget;
#line 883
	}
#line 883

#line 883
	return status;
#line 883
}
#line 883

static int
#line 884
getNCvx_short_double(const NC3_INFO* ncp, const NC_var *varp,
#line 884
		 const size_t *start, size_t nelems, double *value)
#line 884
{
#line 884
	off_t offset = NC_varoffset(ncp, varp, start);
#line 884
	size_t remaining = varp->xsz * nelems;
#line 884
	int status = NC_NOERR;
#line 884
	const void *xp;
#line 884

#line 884
	if(nelems == 0)
#line 884
		return NC_NOERR;
#line 884

#line 884
	assert(value != NULL);
#line 884

#line 884
	for(;;)
#line 884
	{
#line 884
		size_t extent = MIN(remaining, ncp->chunk);
#line 884
		size_t nget = ncx_howmany(varp->type, extent);
#line 884

#line 884
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 884
				 0, (void **)&xp);	/* cast away const */
#line 884
		if(lstatus != NC_NOERR)
#line 884
			return lstatus;
#line 884

#line 884
		lstatus = ncx_getn_short_double(&xp, nget, value);
#line 884
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 884
			status = lstatus;
#line 884

#line 884
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 884

#line 884
		remaining -= extent;
#line 884
		if(remaining == 0)
#line 884
			break; /* normal loop exit */
#line 884
		offset += (off_t)extent;
#line 884
		value += nget;
#line 884
	}
#line 884

#line 884
	return status;
#line 884
}
#line 884

static int
#line 885
getNCvx_short_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 885
		 const size_t *start, size_t nelems, longlong *value)
#line 885
{
#line 885
	off_t offset = NC_varoffset(ncp, varp, start);
#line 885
	size_t remaining = varp->xsz * nelems;
#line 885
	int status = NC_NOERR;
#line 885
	const void *xp;
#line 885

#line 885
	if(nelems == 0)
#line 885
		return NC_NOERR;
#line 885

#line 885
	assert(value != NULL);
#line 885

#line 885
	for(;;)
#line 885
	{
#line 885
		size_t extent = MIN(remaining, ncp->chunk);
#line 885
		size_t nget = ncx_howmany(varp->type, extent);
#line 885

#line 885
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 885
				 0, (void **)&xp);	/* cast away const */
#line 885
		if(lstatus != NC_NOERR)
#line 885
			return lstatus;
#line 885

#line 885
		lstatus = ncx_getn_short_longlong(&xp, nget, value);
#line 885
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 885
			status = lstatus;
#line 885

#line 885
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 885

#line 885
		remaining -= extent;
#line 885
		if(remaining == 0)
#line 885
			break; /* normal loop exit */
#line 885
		offset += (off_t)extent;
#line 885
		value += nget;
#line 885
	}
#line 885

#line 885
	return status;
#line 885
}
#line 885

static int
#line 886
getNCvx_short_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 886
		 const size_t *start, size_t nelems, uint *value)
#line 886
{
#line 886
	off_t offset = NC_varoffset(ncp, varp, start);
#line 886
	size_t remaining = varp->xsz * nelems;
#line 886
	int status = NC_NOERR;
#line 886
	const void *xp;
#line 886

#line 886
	if(nelems == 0)
#line 886
		return NC_NOERR;
#line 886

#line 886
	assert(value != NULL);
#line 886

#line 886
	for(;;)
#line 886
	{
#line 886
		size_t extent = MIN(remaining, ncp->chunk);
#line 886
		size_t nget = ncx_howmany(varp->type, extent);
#line 886

#line 886
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 886
				 0, (void **)&xp);	/* cast away const */
#line 886
		if(lstatus != NC_NOERR)
#line 886
			return lstatus;
#line 886

#line 886
		lstatus = ncx_getn_short_uint(&xp, nget, value);
#line 886
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 886
			status = lstatus;
#line 886

#line 886
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 886

#line 886
		remaining -= extent;
#line 886
		if(remaining == 0)
#line 886
			break; /* normal loop exit */
#line 886
		offset += (off_t)extent;
#line 886
		value += nget;
#line 886
	}
#line 886

#line 886
	return status;
#line 886
}
#line 886

static int
#line 887
getNCvx_short_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 887
		 const size_t *start, size_t nelems, ulonglong *value)
#line 887
{
#line 887
	off_t offset = NC_varoffset(ncp, varp, start);
#line 887
	size_t remaining = varp->xsz * nelems;
#line 887
	int status = NC_NOERR;
#line 887
	const void *xp;
#line 887

#line 887
	if(nelems == 0)
#line 887
		return NC_NOERR;
#line 887

#line 887
	assert(value != NULL);
#line 887

#line 887
	for(;;)
#line 887
	{
#line 887
		size_t extent = MIN(remaining, ncp->chunk);
#line 887
		size_t nget = ncx_howmany(varp->type, extent);
#line 887

#line 887
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 887
				 0, (void **)&xp);	/* cast away const */
#line 887
		if(lstatus != NC_NOERR)
#line 887
			return lstatus;
#line 887

#line 887
		lstatus = ncx_getn_short_ulonglong(&xp, nget, value);
#line 887
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 887
			status = lstatus;
#line 887

#line 887
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 887

#line 887
		remaining -= extent;
#line 887
		if(remaining == 0)
#line 887
			break; /* normal loop exit */
#line 887
		offset += (off_t)extent;
#line 887
		value += nget;
#line 887
	}
#line 887

#line 887
	return status;
#line 887
}
#line 887

static int
#line 888
getNCvx_short_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 888
		 const size_t *start, size_t nelems, ushort *value)
#line 888
{
#line 888
	off_t offset = NC_varoffset(ncp, varp, start);
#line 888
	size_t remaining = varp->xsz * nelems;
#line 888
	int status = NC_NOERR;
#line 888
	const void *xp;
#line 888

#line 888
	if(nelems == 0)
#line 888
		return NC_NOERR;
#line 888

#line 888
	assert(value != NULL);
#line 888

#line 888
	for(;;)
#line 888
	{
#line 888
		size_t extent = MIN(remaining, ncp->chunk);
#line 888
		size_t nget = ncx_howmany(varp->type, extent);
#line 888

#line 888
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 888
				 0, (void **)&xp);	/* cast away const */
#line 888
		if(lstatus != NC_NOERR)
#line 888
			return lstatus;
#line 888

#line 888
		lstatus = ncx_getn_short_ushort(&xp, nget, value);
#line 888
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 888
			status = lstatus;
#line 888

#line 888
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 888

#line 888
		remaining -= extent;
#line 888
		if(remaining == 0)
#line 888
			break; /* normal loop exit */
#line 888
		offset += (off_t)extent;
#line 888
		value += nget;
#line 888
	}
#line 888

#line 888
	return status;
#line 888
}
#line 888


static int
#line 890
getNCvx_int_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 890
		 const size_t *start, size_t nelems, schar *value)
#line 890
{
#line 890
	off_t offset = NC_varoffset(ncp, varp, start);
#line 890
	size_t remaining = varp->xsz * nelems;
#line 890
	int status = NC_NOERR;
#line 890
	const void *xp;
#line 890

#line 890
	if(nelems == 0)
#line 890
		return NC_NOERR;
#line 890

#line 890
	assert(value != NULL);
#line 890

#line 890
	for(;;)
#line 890
	{
#line 890
		size_t extent = MIN(remaining, ncp->chunk);
#line 890
		size_t nget = ncx_howmany(varp->type, extent);
#line 890

#line 890
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 890
				 0, (void **)&xp);	/* cast away const */
#line 890
		if(lstatus != NC_NOERR)
#line 890
			return lstatus;
#line 890

#line 890
		lstatus = ncx_getn_int_schar(&xp, nget, value);
#line 890
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 890
			status = lstatus;
#line 890

#line 890
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 890

#line 890
		remaining -= extent;
#line 890
		if(remaining == 0)
#line 890
			break; /* normal loop exit */
#line 890
		offset += (off_t)extent;
#line 890
		value += nget;
#line 890
	}
#line 890

#line 890
	return status;
#line 890
}
#line 890

static int
#line 891
getNCvx_int_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 891
		 const size_t *start, size_t nelems, uchar *value)
#line 891
{
#line 891
	off_t offset = NC_varoffset(ncp, varp, start);
#line 891
	size_t remaining = varp->xsz * nelems;
#line 891
	int status = NC_NOERR;
#line 891
	const void *xp;
#line 891

#line 891
	if(nelems == 0)
#line 891
		return NC_NOERR;
#line 891

#line 891
	assert(value != NULL);
#line 891

#line 891
	for(;;)
#line 891
	{
#line 891
		size_t extent = MIN(remaining, ncp->chunk);
#line 891
		size_t nget = ncx_howmany(varp->type, extent);
#line 891

#line 891
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 891
				 0, (void **)&xp);	/* cast away const */
#line 891
		if(lstatus != NC_NOERR)
#line 891
			return lstatus;
#line 891

#line 891
		lstatus = ncx_getn_int_uchar(&xp, nget, value);
#line 891
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 891
			status = lstatus;
#line 891

#line 891
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 891

#line 891
		remaining -= extent;
#line 891
		if(remaining == 0)
#line 891
			break; /* normal loop exit */
#line 891
		offset += (off_t)extent;
#line 891
		value += nget;
#line 891
	}
#line 891

#line 891
	return status;
#line 891
}
#line 891

static int
#line 892
getNCvx_int_short(const NC3_INFO* ncp, const NC_var *varp,
#line 892
		 const size_t *start, size_t nelems, short *value)
#line 892
{
#line 892
	off_t offset = NC_varoffset(ncp, varp, start);
#line 892
	size_t remaining = varp->xsz * nelems;
#line 892
	int status = NC_NOERR;
#line 892
	const void *xp;
#line 892

#line 892
	if(nelems == 0)
#line 892
		return NC_NOERR;
#line 892

#line 892
	assert(value != NULL);
#line 892

#line 892
	for(;;)
#line 892
	{
#line 892
		size_t extent = MIN(remaining, ncp->chunk);
#line 892
		size_t nget = ncx_howmany(varp->type, extent);
#line 892

#line 892
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 892
				 0, (void **)&xp);	/* cast away const */
#line 892
		if(lstatus != NC_NOERR)
#line 892
			return lstatus;
#line 892

#line 892
		lstatus = ncx_getn_int_short(&xp, nget, value);
#line 892
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 892
			status = lstatus;
#line 892

#line 892
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 892

#line 892
		remaining -= extent;
#line 892
		if(remaining == 0)
#line 892
			break; /* normal loop exit */
#line 892
		offset += (off_t)extent;
#line 892
		value += nget;
#line 892
	}
#line 892

#line 892
	return status;
#line 892
}
#line 892

static int
#line 893
getNCvx_int_int(const NC3_INFO* ncp, const NC_var *varp,
#line 893
		 const size_t *start, size_t nelems, int *value)
#line 893
{
#line 893
	off_t offset = NC_varoffset(ncp, varp, start);
#line 893
	size_t remaining = varp->xsz * nelems;
#line 893
	int status = NC_NOERR;
#line 893
	const void *xp;
#line 893

#line 893
	if(nelems == 0)
#line 893
		return NC_NOERR;
#line 893

#line 893
	assert(value != NULL);
#line 893

#line 893
	for(;;)
#line 893
	{
#line 893
		size_t extent = MIN(remaining, ncp->chunk);
#line 893
		size_t nget = ncx_howmany(varp->type, extent);
#line 893

#line 893
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 893
				 0, (void **)&xp);	/* cast away const */
#line 893
		if(lstatus != NC_NOERR)
#line 893
			return lstatus;
#line 893

#line 893
		lstatus = ncx_getn_int_int(&xp, nget, value);
#line 893
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 893
			status = lstatus;
#line 893

#line 893
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 893

#line 893
		remaining -= extent;
#line 893
		if(remaining == 0)
#line 893
			break; /* normal loop exit */
#line 893
		offset += (off_t)extent;
#line 893
		value += nget;
#line 893
	}
#line 893

#line 893
	return status;
#line 893
}
#line 893

static int
#line 894
getNCvx_int_float(const NC3_INFO* ncp, const NC_var *varp,
#line 894
		 const size_t *start, size_t nelems, float *value)
#line 894
{
#line 894
	off_t offset = NC_varoffset(ncp, varp, start);
#line 894
	size_t remaining = varp->xsz * nelems;
#line 894
	int status = NC_NOERR;
#line 894
	const void *xp;
#line 894

#line 894
	if(nelems == 0)
#line 894
		return NC_NOERR;
#line 894

#line 894
	assert(value != NULL);
#line 894

#line 894
	for(;;)
#line 894
	{
#line 894
		size_t extent = MIN(remaining, ncp->chunk);
#line 894
		size_t nget = ncx_howmany(varp->type, extent);
#line 894

#line 894
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 894
				 0, (void **)&xp);	/* cast away const */
#line 894
		if(lstatus != NC_NOERR)
#line 894
			return lstatus;
#line 894

#line 894
		lstatus = ncx_getn_int_float(&xp, nget, value);
#line 894
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 894
			status = lstatus;
#line 894

#line 894
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 894

#line 894
		remaining -= extent;
#line 894
		if(remaining == 0)
#line 894
			break; /* normal loop exit */
#line 894
		offset += (off_t)extent;
#line 894
		value += nget;
#line 894
	}
#line 894

#line 894
	return status;
#line 894
}
#line 894

static int
#line 895
getNCvx_int_double(const NC3_INFO* ncp, const NC_var *varp,
#line 895
		 const size_t *start, size_t nelems, double *value)
#line 895
{
#line 895
	off_t offset = NC_varoffset(ncp, varp, start);
#line 895
	size_t remaining = varp->xsz * nelems;
#line 895
	int status = NC_NOERR;
#line 895
	const void *xp;
#line 895

#line 895
	if(nelems == 0)
#line 895
		return NC_NOERR;
#line 895

#line 895
	assert(value != NULL);
#line 895

#line 895
	for(;;)
#line 895
	{
#line 895
		size_t extent = MIN(remaining, ncp->chunk);
#line 895
		size_t nget = ncx_howmany(varp->type, extent);
#line 895

#line 895
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 895
				 0, (void **)&xp);	/* cast away const */
#line 895
		if(lstatus != NC_NOERR)
#line 895
			return lstatus;
#line 895

#line 895
		lstatus = ncx_getn_int_double(&xp, nget, value);
#line 895
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 895
			status = lstatus;
#line 895

#line 895
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 895

#line 895
		remaining -= extent;
#line 895
		if(remaining == 0)
#line 895
			break; /* normal loop exit */
#line 895
		offset += (off_t)extent;
#line 895
		value += nget;
#line 895
	}
#line 895

#line 895
	return status;
#line 895
}
#line 895

static int
#line 896
getNCvx_int_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 896
		 const size_t *start, size_t nelems, longlong *value)
#line 896
{
#line 896
	off_t offset = NC_varoffset(ncp, varp, start);
#line 896
	size_t remaining = varp->xsz * nelems;
#line 896
	int status = NC_NOERR;
#line 896
	const void *xp;
#line 896

#line 896
	if(nelems == 0)
#line 896
		return NC_NOERR;
#line 896

#line 896
	assert(value != NULL);
#line 896

#line 896
	for(;;)
#line 896
	{
#line 896
		size_t extent = MIN(remaining, ncp->chunk);
#line 896
		size_t nget = ncx_howmany(varp->type, extent);
#line 896

#line 896
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 896
				 0, (void **)&xp);	/* cast away const */
#line 896
		if(lstatus != NC_NOERR)
#line 896
			return lstatus;
#line 896

#line 896
		lstatus = ncx_getn_int_longlong(&xp, nget, value);
#line 896
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 896
			status = lstatus;
#line 896

#line 896
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 896

#line 896
		remaining -= extent;
#line 896
		if(remaining == 0)
#line 896
			break; /* normal loop exit */
#line 896
		offset += (off_t)extent;
#line 896
		value += nget;
#line 896
	}
#line 896

#line 896
	return status;
#line 896
}
#line 896

static int
#line 897
getNCvx_int_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 897
		 const size_t *start, size_t nelems, uint *value)
#line 897
{
#line 897
	off_t offset = NC_varoffset(ncp, varp, start);
#line 897
	size_t remaining = varp->xsz * nelems;
#line 897
	int status = NC_NOERR;
#line 897
	const void *xp;
#line 897

#line 897
	if(nelems == 0)
#line 897
		return NC_NOERR;
#line 897

#line 897
	assert(value != NULL);
#line 897

#line 897
	for(;;)
#line 897
	{
#line 897
		size_t extent = MIN(remaining, ncp->chunk);
#line 897
		size_t nget = ncx_howmany(varp->type, extent);
#line 897

#line 897
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 897
				 0, (void **)&xp);	/* cast away const */
#line 897
		if(lstatus != NC_NOERR)
#line 897
			return lstatus;
#line 897

#line 897
		lstatus = ncx_getn_int_uint(&xp, nget, value);
#line 897
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 897
			status = lstatus;
#line 897

#line 897
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 897

#line 897
		remaining -= extent;
#line 897
		if(remaining == 0)
#line 897
			break; /* normal loop exit */
#line 897
		offset += (off_t)extent;
#line 897
		value += nget;
#line 897
	}
#line 897

#line 897
	return status;
#line 897
}
#line 897

static int
#line 898
getNCvx_int_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 898
		 const size_t *start, size_t nelems, ulonglong *value)
#line 898
{
#line 898
	off_t offset = NC_varoffset(ncp, varp, start);
#line 898
	size_t remaining = varp->xsz * nelems;
#line 898
	int status = NC_NOERR;
#line 898
	const void *xp;
#line 898

#line 898
	if(nelems == 0)
#line 898
		return NC_NOERR;
#line 898

#line 898
	assert(value != NULL);
#line 898

#line 898
	for(;;)
#line 898
	{
#line 898
		size_t extent = MIN(remaining, ncp->chunk);
#line 898
		size_t nget = ncx_howmany(varp->type, extent);
#line 898

#line 898
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 898
				 0, (void **)&xp);	/* cast away const */
#line 898
		if(lstatus != NC_NOERR)
#line 898
			return lstatus;
#line 898

#line 898
		lstatus = ncx_getn_int_ulonglong(&xp, nget, value);
#line 898
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 898
			status = lstatus;
#line 898

#line 898
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 898

#line 898
		remaining -= extent;
#line 898
		if(remaining == 0)
#line 898
			break; /* normal loop exit */
#line 898
		offset += (off_t)extent;
#line 898
		value += nget;
#line 898
	}
#line 898

#line 898
	return status;
#line 898
}
#line 898

static int
#line 899
getNCvx_int_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 899
		 const size_t *start, size_t nelems, ushort *value)
#line 899
{
#line 899
	off_t offset = NC_varoffset(ncp, varp, start);
#line 899
	size_t remaining = varp->xsz * nelems;
#line 899
	int status = NC_NOERR;
#line 899
	const void *xp;
#line 899

#line 899
	if(nelems == 0)
#line 899
		return NC_NOERR;
#line 899

#line 899
	assert(value != NULL);
#line 899

#line 899
	for(;;)
#line 899
	{
#line 899
		size_t extent = MIN(remaining, ncp->chunk);
#line 899
		size_t nget = ncx_howmany(varp->type, extent);
#line 899

#line 899
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 899
				 0, (void **)&xp);	/* cast away const */
#line 899
		if(lstatus != NC_NOERR)
#line 899
			return lstatus;
#line 899

#line 899
		lstatus = ncx_getn_int_ushort(&xp, nget, value);
#line 899
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 899
			status = lstatus;
#line 899

#line 899
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 899

#line 899
		remaining -= extent;
#line 899
		if(remaining == 0)
#line 899
			break; /* normal loop exit */
#line 899
		offset += (off_t)extent;
#line 899
		value += nget;
#line 899
	}
#line 899

#line 899
	return status;
#line 899
}
#line 899


static int
#line 901
getNCvx_float_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 901
		 const size_t *start, size_t nelems, schar *value)
#line 901
{
#line 901
	off_t offset = NC_varoffset(ncp, varp, start);
#line 901
	size_t remaining = varp->xsz * nelems;
#line 901
	int status = NC_NOERR;
#line 901
	const void *xp;
#line 901

#line 901
	if(nelems == 0)
#line 901
		return NC_NOERR;
#line 901

#line 901
	assert(value != NULL);
#line 901

#line 901
	for(;;)
#line 901
	{
#line 901
		size_t extent = MIN(remaining, ncp->chunk);
#line 901
		size_t nget = ncx_howmany(varp->type, extent);
#line 901

#line 901
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 901
				 0, (void **)&xp);	/* cast away const */
#line 901
		if(lstatus != NC_NOERR)
#line 901
			return lstatus;
#line 901

#line 901
		lstatus = ncx_getn_float_schar(&xp, nget, value);
#line 901
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 901
			status = lstatus;
#line 901

#line 901
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 901

#line 901
		remaining -= extent;
#line 901
		if(remaining == 0)
#line 901
			break; /* normal loop exit */
#line 901
		offset += (off_t)extent;
#line 901
		value += nget;
#line 901
	}
#line 901

#line 901
	return status;
#line 901
}
#line 901

static int
#line 902
getNCvx_float_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 902
		 const size_t *start, size_t nelems, uchar *value)
#line 902
{
#line 902
	off_t offset = NC_varoffset(ncp, varp, start);
#line 902
	size_t remaining = varp->xsz * nelems;
#line 902
	int status = NC_NOERR;
#line 902
	const void *xp;
#line 902

#line 902
	if(nelems == 0)
#line 902
		return NC_NOERR;
#line 902

#line 902
	assert(value != NULL);
#line 902

#line 902
	for(;;)
#line 902
	{
#line 902
		size_t extent = MIN(remaining, ncp->chunk);
#line 902
		size_t nget = ncx_howmany(varp->type, extent);
#line 902

#line 902
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 902
				 0, (void **)&xp);	/* cast away const */
#line 902
		if(lstatus != NC_NOERR)
#line 902
			return lstatus;
#line 902

#line 902
		lstatus = ncx_getn_float_uchar(&xp, nget, value);
#line 902
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 902
			status = lstatus;
#line 902

#line 902
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 902

#line 902
		remaining -= extent;
#line 902
		if(remaining == 0)
#line 902
			break; /* normal loop exit */
#line 902
		offset += (off_t)extent;
#line 902
		value += nget;
#line 902
	}
#line 902

#line 902
	return status;
#line 902
}
#line 902

static int
#line 903
getNCvx_float_short(const NC3_INFO* ncp, const NC_var *varp,
#line 903
		 const size_t *start, size_t nelems, short *value)
#line 903
{
#line 903
	off_t offset = NC_varoffset(ncp, varp, start);
#line 903
	size_t remaining = varp->xsz * nelems;
#line 903
	int status = NC_NOERR;
#line 903
	const void *xp;
#line 903

#line 903
	if(nelems == 0)
#line 903
		return NC_NOERR;
#line 903

#line 903
	assert(value != NULL);
#line 903

#line 903
	for(;;)
#line 903
	{
#line 903
		size_t extent = MIN(remaining, ncp->chunk);
#line 903
		size_t nget = ncx_howmany(varp->type, extent);
#line 903

#line 903
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 903
				 0, (void **)&xp);	/* cast away const */
#line 903
		if(lstatus != NC_NOERR)
#line 903
			return lstatus;
#line 903

#line 903
		lstatus = ncx_getn_float_short(&xp, nget, value);
#line 903
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 903
			status = lstatus;
#line 903

#line 903
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 903

#line 903
		remaining -= extent;
#line 903
		if(remaining == 0)
#line 903
			break; /* normal loop exit */
#line 903
		offset += (off_t)extent;
#line 903
		value += nget;
#line 903
	}
#line 903

#line 903
	return status;
#line 903
}
#line 903

static int
#line 904
getNCvx_float_int(const NC3_INFO* ncp, const NC_var *varp,
#line 904
		 const size_t *start, size_t nelems, int *value)
#line 904
{
#line 904
	off_t offset = NC_varoffset(ncp, varp, start);
#line 904
	size_t remaining = varp->xsz * nelems;
#line 904
	int status = NC_NOERR;
#line 904
	const void *xp;
#line 904

#line 904
	if(nelems == 0)
#line 904
		return NC_NOERR;
#line 904

#line 904
	assert(value != NULL);
#line 904

#line 904
	for(;;)
#line 904
	{
#line 904
		size_t extent = MIN(remaining, ncp->chunk);
#line 904
		size_t nget = ncx_howmany(varp->type, extent);
#line 904

#line 904
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 904
				 0, (void **)&xp);	/* cast away const */
#line 904
		if(lstatus != NC_NOERR)
#line 904
			return lstatus;
#line 904

#line 904
		lstatus = ncx_getn_float_int(&xp, nget, value);
#line 904
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 904
			status = lstatus;
#line 904

#line 904
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 904

#line 904
		remaining -= extent;
#line 904
		if(remaining == 0)
#line 904
			break; /* normal loop exit */
#line 904
		offset += (off_t)extent;
#line 904
		value += nget;
#line 904
	}
#line 904

#line 904
	return status;
#line 904
}
#line 904

static int
#line 905
getNCvx_float_float(const NC3_INFO* ncp, const NC_var *varp,
#line 905
		 const size_t *start, size_t nelems, float *value)
#line 905
{
#line 905
	off_t offset = NC_varoffset(ncp, varp, start);
#line 905
	size_t remaining = varp->xsz * nelems;
#line 905
	int status = NC_NOERR;
#line 905
	const void *xp;
#line 905

#line 905
	if(nelems == 0)
#line 905
		return NC_NOERR;
#line 905

#line 905
	assert(value != NULL);
#line 905

#line 905
	for(;;)
#line 905
	{
#line 905
		size_t extent = MIN(remaining, ncp->chunk);
#line 905
		size_t nget = ncx_howmany(varp->type, extent);
#line 905

#line 905
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 905
				 0, (void **)&xp);	/* cast away const */
#line 905
		if(lstatus != NC_NOERR)
#line 905
			return lstatus;
#line 905

#line 905
		lstatus = ncx_getn_float_float(&xp, nget, value);
#line 905
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 905
			status = lstatus;
#line 905

#line 905
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 905

#line 905
		remaining -= extent;
#line 905
		if(remaining == 0)
#line 905
			break; /* normal loop exit */
#line 905
		offset += (off_t)extent;
#line 905
		value += nget;
#line 905
	}
#line 905

#line 905
	return status;
#line 905
}
#line 905

static int
#line 906
getNCvx_float_double(const NC3_INFO* ncp, const NC_var *varp,
#line 906
		 const size_t *start, size_t nelems, double *value)
#line 906
{
#line 906
	off_t offset = NC_varoffset(ncp, varp, start);
#line 906
	size_t remaining = varp->xsz * nelems;
#line 906
	int status = NC_NOERR;
#line 906
	const void *xp;
#line 906

#line 906
	if(nelems == 0)
#line 906
		return NC_NOERR;
#line 906

#line 906
	assert(value != NULL);
#line 906

#line 906
	for(;;)
#line 906
	{
#line 906
		size_t extent = MIN(remaining, ncp->chunk);
#line 906
		size_t nget = ncx_howmany(varp->type, extent);
#line 906

#line 906
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 906
				 0, (void **)&xp);	/* cast away const */
#line 906
		if(lstatus != NC_NOERR)
#line 906
			return lstatus;
#line 906

#line 906
		lstatus = ncx_getn_float_double(&xp, nget, value);
#line 906
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 906
			status = lstatus;
#line 906

#line 906
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 906

#line 906
		remaining -= extent;
#line 906
		if(remaining == 0)
#line 906
			break; /* normal loop exit */
#line 906
		offset += (off_t)extent;
#line 906
		value += nget;
#line 906
	}
#line 906

#line 906
	return status;
#line 906
}
#line 906

static int
#line 907
getNCvx_float_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 907
		 const size_t *start, size_t nelems, longlong *value)
#line 907
{
#line 907
	off_t offset = NC_varoffset(ncp, varp, start);
#line 907
	size_t remaining = varp->xsz * nelems;
#line 907
	int status = NC_NOERR;
#line 907
	const void *xp;
#line 907

#line 907
	if(nelems == 0)
#line 907
		return NC_NOERR;
#line 907

#line 907
	assert(value != NULL);
#line 907

#line 907
	for(;;)
#line 907
	{
#line 907
		size_t extent = MIN(remaining, ncp->chunk);
#line 907
		size_t nget = ncx_howmany(varp->type, extent);
#line 907

#line 907
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 907
				 0, (void **)&xp);	/* cast away const */
#line 907
		if(lstatus != NC_NOERR)
#line 907
			return lstatus;
#line 907

#line 907
		lstatus = ncx_getn_float_longlong(&xp, nget, value);
#line 907
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 907
			status = lstatus;
#line 907

#line 907
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 907

#line 907
		remaining -= extent;
#line 907
		if(remaining == 0)
#line 907
			break; /* normal loop exit */
#line 907
		offset += (off_t)extent;
#line 907
		value += nget;
#line 907
	}
#line 907

#line 907
	return status;
#line 907
}
#line 907

static int
#line 908
getNCvx_float_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 908
		 const size_t *start, size_t nelems, uint *value)
#line 908
{
#line 908
	off_t offset = NC_varoffset(ncp, varp, start);
#line 908
	size_t remaining = varp->xsz * nelems;
#line 908
	int status = NC_NOERR;
#line 908
	const void *xp;
#line 908

#line 908
	if(nelems == 0)
#line 908
		return NC_NOERR;
#line 908

#line 908
	assert(value != NULL);
#line 908

#line 908
	for(;;)
#line 908
	{
#line 908
		size_t extent = MIN(remaining, ncp->chunk);
#line 908
		size_t nget = ncx_howmany(varp->type, extent);
#line 908

#line 908
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 908
				 0, (void **)&xp);	/* cast away const */
#line 908
		if(lstatus != NC_NOERR)
#line 908
			return lstatus;
#line 908

#line 908
		lstatus = ncx_getn_float_uint(&xp, nget, value);
#line 908
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 908
			status = lstatus;
#line 908

#line 908
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 908

#line 908
		remaining -= extent;
#line 908
		if(remaining == 0)
#line 908
			break; /* normal loop exit */
#line 908
		offset += (off_t)extent;
#line 908
		value += nget;
#line 908
	}
#line 908

#line 908
	return status;
#line 908
}
#line 908

static int
#line 909
getNCvx_float_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 909
		 const size_t *start, size_t nelems, ulonglong *value)
#line 909
{
#line 909
	off_t offset = NC_varoffset(ncp, varp, start);
#line 909
	size_t remaining = varp->xsz * nelems;
#line 909
	int status = NC_NOERR;
#line 909
	const void *xp;
#line 909

#line 909
	if(nelems == 0)
#line 909
		return NC_NOERR;
#line 909

#line 909
	assert(value != NULL);
#line 909

#line 909
	for(;;)
#line 909
	{
#line 909
		size_t extent = MIN(remaining, ncp->chunk);
#line 909
		size_t nget = ncx_howmany(varp->type, extent);
#line 909

#line 909
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 909
				 0, (void **)&xp);	/* cast away const */
#line 909
		if(lstatus != NC_NOERR)
#line 909
			return lstatus;
#line 909

#line 909
		lstatus = ncx_getn_float_ulonglong(&xp, nget, value);
#line 909
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 909
			status = lstatus;
#line 909

#line 909
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 909

#line 909
		remaining -= extent;
#line 909
		if(remaining == 0)
#line 909
			break; /* normal loop exit */
#line 909
		offset += (off_t)extent;
#line 909
		value += nget;
#line 909
	}
#line 909

#line 909
	return status;
#line 909
}
#line 909

static int
#line 910
getNCvx_float_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 910
		 const size_t *start, size_t nelems, ushort *value)
#line 910
{
#line 910
	off_t offset = NC_varoffset(ncp, varp, start);
#line 910
	size_t remaining = varp->xsz * nelems;
#line 910
	int status = NC_NOERR;
#line 910
	const void *xp;
#line 910

#line 910
	if(nelems == 0)
#line 910
		return NC_NOERR;
#line 910

#line 910
	assert(value != NULL);
#line 910

#line 910
	for(;;)
#line 910
	{
#line 910
		size_t extent = MIN(remaining, ncp->chunk);
#line 910
		size_t nget = ncx_howmany(varp->type, extent);
#line 910

#line 910
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 910
				 0, (void **)&xp);	/* cast away const */
#line 910
		if(lstatus != NC_NOERR)
#line 910
			return lstatus;
#line 910

#line 910
		lstatus = ncx_getn_float_ushort(&xp, nget, value);
#line 910
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 910
			status = lstatus;
#line 910

#line 910
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 910

#line 910
		remaining -= extent;
#line 910
		if(remaining == 0)
#line 910
			break; /* normal loop exit */
#line 910
		offset += (off_t)extent;
#line 910
		value += nget;
#line 910
	}
#line 910

#line 910
	return status;
#line 910
}
#line 910


static int
#line 912
getNCvx_double_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 912
		 const size_t *start, size_t nelems, schar *value)
#line 912
{
#line 912
	off_t offset = NC_varoffset(ncp, varp, start);
#line 912
	size_t remaining = varp->xsz * nelems;
#line 912
	int status = NC_NOERR;
#line 912
	const void *xp;
#line 912

#line 912
	if(nelems == 0)
#line 912
		return NC_NOERR;
#line 912

#line 912
	assert(value != NULL);
#line 912

#line 912
	for(;;)
#line 912
	{
#line 912
		size_t extent = MIN(remaining, ncp->chunk);
#line 912
		size_t nget = ncx_howmany(varp->type, extent);
#line 912

#line 912
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 912
				 0, (void **)&xp);	/* cast away const */
#line 912
		if(lstatus != NC_NOERR)
#line 912
			return lstatus;
#line 912

#line 912
		lstatus = ncx_getn_double_schar(&xp, nget, value);
#line 912
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 912
			status = lstatus;
#line 912

#line 912
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 912

#line 912
		remaining -= extent;
#line 912
		if(remaining == 0)
#line 912
			break; /* normal loop exit */
#line 912
		offset += (off_t)extent;
#line 912
		value += nget;
#line 912
	}
#line 912

#line 912
	return status;
#line 912
}
#line 912

static int
#line 913
getNCvx_double_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 913
		 const size_t *start, size_t nelems, uchar *value)
#line 913
{
#line 913
	off_t offset = NC_varoffset(ncp, varp, start);
#line 913
	size_t remaining = varp->xsz * nelems;
#line 913
	int status = NC_NOERR;
#line 913
	const void *xp;
#line 913

#line 913
	if(nelems == 0)
#line 913
		return NC_NOERR;
#line 913

#line 913
	assert(value != NULL);
#line 913

#line 913
	for(;;)
#line 913
	{
#line 913
		size_t extent = MIN(remaining, ncp->chunk);
#line 913
		size_t nget = ncx_howmany(varp->type, extent);
#line 913

#line 913
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 913
				 0, (void **)&xp);	/* cast away const */
#line 913
		if(lstatus != NC_NOERR)
#line 913
			return lstatus;
#line 913

#line 913
		lstatus = ncx_getn_double_uchar(&xp, nget, value);
#line 913
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 913
			status = lstatus;
#line 913

#line 913
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 913

#line 913
		remaining -= extent;
#line 913
		if(remaining == 0)
#line 913
			break; /* normal loop exit */
#line 913
		offset += (off_t)extent;
#line 913
		value += nget;
#line 913
	}
#line 913

#line 913
	return status;
#line 913
}
#line 913

static int
#line 914
getNCvx_double_short(const NC3_INFO* ncp, const NC_var *varp,
#line 914
		 const size_t *start, size_t nelems, short *value)
#line 914
{
#line 914
	off_t offset = NC_varoffset(ncp, varp, start);
#line 914
	size_t remaining = varp->xsz * nelems;
#line 914
	int status = NC_NOERR;
#line 914
	const void *xp;
#line 914

#line 914
	if(nelems == 0)
#line 914
		return NC_NOERR;
#line 914

#line 914
	assert(value != NULL);
#line 914

#line 914
	for(;;)
#line 914
	{
#line 914
		size_t extent = MIN(remaining, ncp->chunk);
#line 914
		size_t nget = ncx_howmany(varp->type, extent);
#line 914

#line 914
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 914
				 0, (void **)&xp);	/* cast away const */
#line 914
		if(lstatus != NC_NOERR)
#line 914
			return lstatus;
#line 914

#line 914
		lstatus = ncx_getn_double_short(&xp, nget, value);
#line 914
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 914
			status = lstatus;
#line 914

#line 914
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 914

#line 914
		remaining -= extent;
#line 914
		if(remaining == 0)
#line 914
			break; /* normal loop exit */
#line 914
		offset += (off_t)extent;
#line 914
		value += nget;
#line 914
	}
#line 914

#line 914
	return status;
#line 914
}
#line 914

static int
#line 915
getNCvx_double_int(const NC3_INFO* ncp, const NC_var *varp,
#line 915
		 const size_t *start, size_t nelems, int *value)
#line 915
{
#line 915
	off_t offset = NC_varoffset(ncp, varp, start);
#line 915
	size_t remaining = varp->xsz * nelems;
#line 915
	int status = NC_NOERR;
#line 915
	const void *xp;
#line 915

#line 915
	if(nelems == 0)
#line 915
		return NC_NOERR;
#line 915

#line 915
	assert(value != NULL);
#line 915

#line 915
	for(;;)
#line 915
	{
#line 915
		size_t extent = MIN(remaining, ncp->chunk);
#line 915
		size_t nget = ncx_howmany(varp->type, extent);
#line 915

#line 915
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 915
				 0, (void **)&xp);	/* cast away const */
#line 915
		if(lstatus != NC_NOERR)
#line 915
			return lstatus;
#line 915

#line 915
		lstatus = ncx_getn_double_int(&xp, nget, value);
#line 915
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 915
			status = lstatus;
#line 915

#line 915
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 915

#line 915
		remaining -= extent;
#line 915
		if(remaining == 0)
#line 915
			break; /* normal loop exit */
#line 915
		offset += (off_t)extent;
#line 915
		value += nget;
#line 915
	}
#line 915

#line 915
	return status;
#line 915
}
#line 915

static int
#line 916
getNCvx_double_float(const NC3_INFO* ncp, const NC_var *varp,
#line 916
		 const size_t *start, size_t nelems, float *value)
#line 916
{
#line 916
	off_t offset = NC_varoffset(ncp, varp, start);
#line 916
	size_t remaining = varp->xsz * nelems;
#line 916
	int status = NC_NOERR;
#line 916
	const void *xp;
#line 916

#line 916
	if(nelems == 0)
#line 916
		return NC_NOERR;
#line 916

#line 916
	assert(value != NULL);
#line 916

#line 916
	for(;;)
#line 916
	{
#line 916
		size_t extent = MIN(remaining, ncp->chunk);
#line 916
		size_t nget = ncx_howmany(varp->type, extent);
#line 916

#line 916
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 916
				 0, (void **)&xp);	/* cast away const */
#line 916
		if(lstatus != NC_NOERR)
#line 916
			return lstatus;
#line 916

#line 916
		lstatus = ncx_getn_double_float(&xp, nget, value);
#line 916
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 916
			status = lstatus;
#line 916

#line 916
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 916

#line 916
		remaining -= extent;
#line 916
		if(remaining == 0)
#line 916
			break; /* normal loop exit */
#line 916
		offset += (off_t)extent;
#line 916
		value += nget;
#line 916
	}
#line 916

#line 916
	return status;
#line 916
}
#line 916

static int
#line 917
getNCvx_double_double(const NC3_INFO* ncp, const NC_var *varp,
#line 917
		 const size_t *start, size_t nelems, double *value)
#line 917
{
#line 917
	off_t offset = NC_varoffset(ncp, varp, start);
#line 917
	size_t remaining = varp->xsz * nelems;
#line 917
	int status = NC_NOERR;
#line 917
	const void *xp;
#line 917

#line 917
	if(nelems == 0)
#line 917
		return NC_NOERR;
#line 917

#line 917
	assert(value != NULL);
#line 917

#line 917
	for(;;)
#line 917
	{
#line 917
		size_t extent = MIN(remaining, ncp->chunk);
#line 917
		size_t nget = ncx_howmany(varp->type, extent);
#line 917

#line 917
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 917
				 0, (void **)&xp);	/* cast away const */
#line 917
		if(lstatus != NC_NOERR)
#line 917
			return lstatus;
#line 917

#line 917
		lstatus = ncx_getn_double_double(&xp, nget, value);
#line 917
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 917
			status = lstatus;
#line 917

#line 917
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 917

#line 917
		remaining -= extent;
#line 917
		if(remaining == 0)
#line 917
			break; /* normal loop exit */
#line 917
		offset += (off_t)extent;
#line 917
		value += nget;
#line 917
	}
#line 917

#line 917
	return status;
#line 917
}
#line 917

static int
#line 918
getNCvx_double_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 918
		 const size_t *start, size_t nelems, longlong *value)
#line 918
{
#line 918
	off_t offset = NC_varoffset(ncp, varp, start);
#line 918
	size_t remaining = varp->xsz * nelems;
#line 918
	int status = NC_NOERR;
#line 918
	const void *xp;
#line 918

#line 918
	if(nelems == 0)
#line 918
		return NC_NOERR;
#line 918

#line 918
	assert(value != NULL);
#line 918

#line 918
	for(;;)
#line 918
	{
#line 918
		size_t extent = MIN(remaining, ncp->chunk);
#line 918
		size_t nget = ncx_howmany(varp->type, extent);
#line 918

#line 918
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 918
				 0, (void **)&xp);	/* cast away const */
#line 918
		if(lstatus != NC_NOERR)
#line 918
			return lstatus;
#line 918

#line 918
		lstatus = ncx_getn_double_longlong(&xp, nget, value);
#line 918
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 918
			status = lstatus;
#line 918

#line 918
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 918

#line 918
		remaining -= extent;
#line 918
		if(remaining == 0)
#line 918
			break; /* normal loop exit */
#line 918
		offset += (off_t)extent;
#line 918
		value += nget;
#line 918
	}
#line 918

#line 918
	return status;
#line 918
}
#line 918

static int
#line 919
getNCvx_double_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 919
		 const size_t *start, size_t nelems, uint *value)
#line 919
{
#line 919
	off_t offset = NC_varoffset(ncp, varp, start);
#line 919
	size_t remaining = varp->xsz * nelems;
#line 919
	int status = NC_NOERR;
#line 919
	const void *xp;
#line 919

#line 919
	if(nelems == 0)
#line 919
		return NC_NOERR;
#line 919

#line 919
	assert(value != NULL);
#line 919

#line 919
	for(;;)
#line 919
	{
#line 919
		size_t extent = MIN(remaining, ncp->chunk);
#line 919
		size_t nget = ncx_howmany(varp->type, extent);
#line 919

#line 919
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 919
				 0, (void **)&xp);	/* cast away const */
#line 919
		if(lstatus != NC_NOERR)
#line 919
			return lstatus;
#line 919

#line 919
		lstatus = ncx_getn_double_uint(&xp, nget, value);
#line 919
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 919
			status = lstatus;
#line 919

#line 919
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 919

#line 919
		remaining -= extent;
#line 919
		if(remaining == 0)
#line 919
			break; /* normal loop exit */
#line 919
		offset += (off_t)extent;
#line 919
		value += nget;
#line 919
	}
#line 919

#line 919
	return status;
#line 919
}
#line 919

static int
#line 920
getNCvx_double_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 920
		 const size_t *start, size_t nelems, ulonglong *value)
#line 920
{
#line 920
	off_t offset = NC_varoffset(ncp, varp, start);
#line 920
	size_t remaining = varp->xsz * nelems;
#line 920
	int status = NC_NOERR;
#line 920
	const void *xp;
#line 920

#line 920
	if(nelems == 0)
#line 920
		return NC_NOERR;
#line 920

#line 920
	assert(value != NULL);
#line 920

#line 920
	for(;;)
#line 920
	{
#line 920
		size_t extent = MIN(remaining, ncp->chunk);
#line 920
		size_t nget = ncx_howmany(varp->type, extent);
#line 920

#line 920
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 920
				 0, (void **)&xp);	/* cast away const */
#line 920
		if(lstatus != NC_NOERR)
#line 920
			return lstatus;
#line 920

#line 920
		lstatus = ncx_getn_double_ulonglong(&xp, nget, value);
#line 920
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 920
			status = lstatus;
#line 920

#line 920
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 920

#line 920
		remaining -= extent;
#line 920
		if(remaining == 0)
#line 920
			break; /* normal loop exit */
#line 920
		offset += (off_t)extent;
#line 920
		value += nget;
#line 920
	}
#line 920

#line 920
	return status;
#line 920
}
#line 920

static int
#line 921
getNCvx_double_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 921
		 const size_t *start, size_t nelems, ushort *value)
#line 921
{
#line 921
	off_t offset = NC_varoffset(ncp, varp, start);
#line 921
	size_t remaining = varp->xsz * nelems;
#line 921
	int status = NC_NOERR;
#line 921
	const void *xp;
#line 921

#line 921
	if(nelems == 0)
#line 921
		return NC_NOERR;
#line 921

#line 921
	assert(value != NULL);
#line 921

#line 921
	for(;;)
#line 921
	{
#line 921
		size_t extent = MIN(remaining, ncp->chunk);
#line 921
		size_t nget = ncx_howmany(varp->type, extent);
#line 921

#line 921
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 921
				 0, (void **)&xp);	/* cast away const */
#line 921
		if(lstatus != NC_NOERR)
#line 921
			return lstatus;
#line 921

#line 921
		lstatus = ncx_getn_double_ushort(&xp, nget, value);
#line 921
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 921
			status = lstatus;
#line 921

#line 921
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 921

#line 921
		remaining -= extent;
#line 921
		if(remaining == 0)
#line 921
			break; /* normal loop exit */
#line 921
		offset += (off_t)extent;
#line 921
		value += nget;
#line 921
	}
#line 921

#line 921
	return status;
#line 921
}
#line 921


static int
#line 923
getNCvx_uchar_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 923
		 const size_t *start, size_t nelems, schar *value)
#line 923
{
#line 923
	off_t offset = NC_varoffset(ncp, varp, start);
#line 923
	size_t remaining = varp->xsz * nelems;
#line 923
	int status = NC_NOERR;
#line 923
	const void *xp;
#line 923

#line 923
	if(nelems == 0)
#line 923
		return NC_NOERR;
#line 923

#line 923
	assert(value != NULL);
#line 923

#line 923
	for(;;)
#line 923
	{
#line 923
		size_t extent = MIN(remaining, ncp->chunk);
#line 923
		size_t nget = ncx_howmany(varp->type, extent);
#line 923

#line 923
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 923
				 0, (void **)&xp);	/* cast away const */
#line 923
		if(lstatus != NC_NOERR)
#line 923
			return lstatus;
#line 923

#line 923
		lstatus = ncx_getn_uchar_schar(&xp, nget, value);
#line 923
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 923
			status = lstatus;
#line 923

#line 923
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 923

#line 923
		remaining -= extent;
#line 923
		if(remaining == 0)
#line 923
			break; /* normal loop exit */
#line 923
		offset += (off_t)extent;
#line 923
		value += nget;
#line 923
	}
#line 923

#line 923
	return status;
#line 923
}
#line 923

static int
#line 924
getNCvx_uchar_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 924
		 const size_t *start, size_t nelems, uchar *value)
#line 924
{
#line 924
	off_t offset = NC_varoffset(ncp, varp, start);
#line 924
	size_t remaining = varp->xsz * nelems;
#line 924
	int status = NC_NOERR;
#line 924
	const void *xp;
#line 924

#line 924
	if(nelems == 0)
#line 924
		return NC_NOERR;
#line 924

#line 924
	assert(value != NULL);
#line 924

#line 924
	for(;;)
#line 924
	{
#line 924
		size_t extent = MIN(remaining, ncp->chunk);
#line 924
		size_t nget = ncx_howmany(varp->type, extent);
#line 924

#line 924
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 924
				 0, (void **)&xp);	/* cast away const */
#line 924
		if(lstatus != NC_NOERR)
#line 924
			return lstatus;
#line 924

#line 924
		lstatus = ncx_getn_uchar_uchar(&xp, nget, value);
#line 924
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 924
			status = lstatus;
#line 924

#line 924
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 924

#line 924
		remaining -= extent;
#line 924
		if(remaining == 0)
#line 924
			break; /* normal loop exit */
#line 924
		offset += (off_t)extent;
#line 924
		value += nget;
#line 924
	}
#line 924

#line 924
	return status;
#line 924
}
#line 924

static int
#line 925
getNCvx_uchar_short(const NC3_INFO* ncp, const NC_var *varp,
#line 925
		 const size_t *start, size_t nelems, short *value)
#line 925
{
#line 925
	off_t offset = NC_varoffset(ncp, varp, start);
#line 925
	size_t remaining = varp->xsz * nelems;
#line 925
	int status = NC_NOERR;
#line 925
	const void *xp;
#line 925

#line 925
	if(nelems == 0)
#line 925
		return NC_NOERR;
#line 925

#line 925
	assert(value != NULL);
#line 925

#line 925
	for(;;)
#line 925
	{
#line 925
		size_t extent = MIN(remaining, ncp->chunk);
#line 925
		size_t nget = ncx_howmany(varp->type, extent);
#line 925

#line 925
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 925
				 0, (void **)&xp);	/* cast away const */
#line 925
		if(lstatus != NC_NOERR)
#line 925
			return lstatus;
#line 925

#line 925
		lstatus = ncx_getn_uchar_short(&xp, nget, value);
#line 925
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 925
			status = lstatus;
#line 925

#line 925
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 925

#line 925
		remaining -= extent;
#line 925
		if(remaining == 0)
#line 925
			break; /* normal loop exit */
#line 925
		offset += (off_t)extent;
#line 925
		value += nget;
#line 925
	}
#line 925

#line 925
	return status;
#line 925
}
#line 925

static int
#line 926
getNCvx_uchar_int(const NC3_INFO* ncp, const NC_var *varp,
#line 926
		 const size_t *start, size_t nelems, int *value)
#line 926
{
#line 926
	off_t offset = NC_varoffset(ncp, varp, start);
#line 926
	size_t remaining = varp->xsz * nelems;
#line 926
	int status = NC_NOERR;
#line 926
	const void *xp;
#line 926

#line 926
	if(nelems == 0)
#line 926
		return NC_NOERR;
#line 926

#line 926
	assert(value != NULL);
#line 926

#line 926
	for(;;)
#line 926
	{
#line 926
		size_t extent = MIN(remaining, ncp->chunk);
#line 926
		size_t nget = ncx_howmany(varp->type, extent);
#line 926

#line 926
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 926
				 0, (void **)&xp);	/* cast away const */
#line 926
		if(lstatus != NC_NOERR)
#line 926
			return lstatus;
#line 926

#line 926
		lstatus = ncx_getn_uchar_int(&xp, nget, value);
#line 926
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 926
			status = lstatus;
#line 926

#line 926
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 926

#line 926
		remaining -= extent;
#line 926
		if(remaining == 0)
#line 926
			break; /* normal loop exit */
#line 926
		offset += (off_t)extent;
#line 926
		value += nget;
#line 926
	}
#line 926

#line 926
	return status;
#line 926
}
#line 926

static int
#line 927
getNCvx_uchar_float(const NC3_INFO* ncp, const NC_var *varp,
#line 927
		 const size_t *start, size_t nelems, float *value)
#line 927
{
#line 927
	off_t offset = NC_varoffset(ncp, varp, start);
#line 927
	size_t remaining = varp->xsz * nelems;
#line 927
	int status = NC_NOERR;
#line 927
	const void *xp;
#line 927

#line 927
	if(nelems == 0)
#line 927
		return NC_NOERR;
#line 927

#line 927
	assert(value != NULL);
#line 927

#line 927
	for(;;)
#line 927
	{
#line 927
		size_t extent = MIN(remaining, ncp->chunk);
#line 927
		size_t nget = ncx_howmany(varp->type, extent);
#line 927

#line 927
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 927
				 0, (void **)&xp);	/* cast away const */
#line 927
		if(lstatus != NC_NOERR)
#line 927
			return lstatus;
#line 927

#line 927
		lstatus = ncx_getn_uchar_float(&xp, nget, value);
#line 927
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 927
			status = lstatus;
#line 927

#line 927
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 927

#line 927
		remaining -= extent;
#line 927
		if(remaining == 0)
#line 927
			break; /* normal loop exit */
#line 927
		offset += (off_t)extent;
#line 927
		value += nget;
#line 927
	}
#line 927

#line 927
	return status;
#line 927
}
#line 927

static int
#line 928
getNCvx_uchar_double(const NC3_INFO* ncp, const NC_var *varp,
#line 928
		 const size_t *start, size_t nelems, double *value)
#line 928
{
#line 928
	off_t offset = NC_varoffset(ncp, varp, start);
#line 928
	size_t remaining = varp->xsz * nelems;
#line 928
	int status = NC_NOERR;
#line 928
	const void *xp;
#line 928

#line 928
	if(nelems == 0)
#line 928
		return NC_NOERR;
#line 928

#line 928
	assert(value != NULL);
#line 928

#line 928
	for(;;)
#line 928
	{
#line 928
		size_t extent = MIN(remaining, ncp->chunk);
#line 928
		size_t nget = ncx_howmany(varp->type, extent);
#line 928

#line 928
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 928
				 0, (void **)&xp);	/* cast away const */
#line 928
		if(lstatus != NC_NOERR)
#line 928
			return lstatus;
#line 928

#line 928
		lstatus = ncx_getn_uchar_double(&xp, nget, value);
#line 928
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 928
			status = lstatus;
#line 928

#line 928
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 928

#line 928
		remaining -= extent;
#line 928
		if(remaining == 0)
#line 928
			break; /* normal loop exit */
#line 928
		offset += (off_t)extent;
#line 928
		value += nget;
#line 928
	}
#line 928

#line 928
	return status;
#line 928
}
#line 928

static int
#line 929
getNCvx_uchar_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 929
		 const size_t *start, size_t nelems, longlong *value)
#line 929
{
#line 929
	off_t offset = NC_varoffset(ncp, varp, start);
#line 929
	size_t remaining = varp->xsz * nelems;
#line 929
	int status = NC_NOERR;
#line 929
	const void *xp;
#line 929

#line 929
	if(nelems == 0)
#line 929
		return NC_NOERR;
#line 929

#line 929
	assert(value != NULL);
#line 929

#line 929
	for(;;)
#line 929
	{
#line 929
		size_t extent = MIN(remaining, ncp->chunk);
#line 929
		size_t nget = ncx_howmany(varp->type, extent);
#line 929

#line 929
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 929
				 0, (void **)&xp);	/* cast away const */
#line 929
		if(lstatus != NC_NOERR)
#line 929
			return lstatus;
#line 929

#line 929
		lstatus = ncx_getn_uchar_longlong(&xp, nget, value);
#line 929
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 929
			status = lstatus;
#line 929

#line 929
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 929

#line 929
		remaining -= extent;
#line 929
		if(remaining == 0)
#line 929
			break; /* normal loop exit */
#line 929
		offset += (off_t)extent;
#line 929
		value += nget;
#line 929
	}
#line 929

#line 929
	return status;
#line 929
}
#line 929

static int
#line 930
getNCvx_uchar_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 930
		 const size_t *start, size_t nelems, uint *value)
#line 930
{
#line 930
	off_t offset = NC_varoffset(ncp, varp, start);
#line 930
	size_t remaining = varp->xsz * nelems;
#line 930
	int status = NC_NOERR;
#line 930
	const void *xp;
#line 930

#line 930
	if(nelems == 0)
#line 930
		return NC_NOERR;
#line 930

#line 930
	assert(value != NULL);
#line 930

#line 930
	for(;;)
#line 930
	{
#line 930
		size_t extent = MIN(remaining, ncp->chunk);
#line 930
		size_t nget = ncx_howmany(varp->type, extent);
#line 930

#line 930
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 930
				 0, (void **)&xp);	/* cast away const */
#line 930
		if(lstatus != NC_NOERR)
#line 930
			return lstatus;
#line 930

#line 930
		lstatus = ncx_getn_uchar_uint(&xp, nget, value);
#line 930
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 930
			status = lstatus;
#line 930

#line 930
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 930

#line 930
		remaining -= extent;
#line 930
		if(remaining == 0)
#line 930
			break; /* normal loop exit */
#line 930
		offset += (off_t)extent;
#line 930
		value += nget;
#line 930
	}
#line 930

#line 930
	return status;
#line 930
}
#line 930

static int
#line 931
getNCvx_uchar_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 931
		 const size_t *start, size_t nelems, ulonglong *value)
#line 931
{
#line 931
	off_t offset = NC_varoffset(ncp, varp, start);
#line 931
	size_t remaining = varp->xsz * nelems;
#line 931
	int status = NC_NOERR;
#line 931
	const void *xp;
#line 931

#line 931
	if(nelems == 0)
#line 931
		return NC_NOERR;
#line 931

#line 931
	assert(value != NULL);
#line 931

#line 931
	for(;;)
#line 931
	{
#line 931
		size_t extent = MIN(remaining, ncp->chunk);
#line 931
		size_t nget = ncx_howmany(varp->type, extent);
#line 931

#line 931
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 931
				 0, (void **)&xp);	/* cast away const */
#line 931
		if(lstatus != NC_NOERR)
#line 931
			return lstatus;
#line 931

#line 931
		lstatus = ncx_getn_uchar_ulonglong(&xp, nget, value);
#line 931
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 931
			status = lstatus;
#line 931

#line 931
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 931

#line 931
		remaining -= extent;
#line 931
		if(remaining == 0)
#line 931
			break; /* normal loop exit */
#line 931
		offset += (off_t)extent;
#line 931
		value += nget;
#line 931
	}
#line 931

#line 931
	return status;
#line 931
}
#line 931

static int
#line 932
getNCvx_uchar_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 932
		 const size_t *start, size_t nelems, ushort *value)
#line 932
{
#line 932
	off_t offset = NC_varoffset(ncp, varp, start);
#line 932
	size_t remaining = varp->xsz * nelems;
#line 932
	int status = NC_NOERR;
#line 932
	const void *xp;
#line 932

#line 932
	if(nelems == 0)
#line 932
		return NC_NOERR;
#line 932

#line 932
	assert(value != NULL);
#line 932

#line 932
	for(;;)
#line 932
	{
#line 932
		size_t extent = MIN(remaining, ncp->chunk);
#line 932
		size_t nget = ncx_howmany(varp->type, extent);
#line 932

#line 932
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 932
				 0, (void **)&xp);	/* cast away const */
#line 932
		if(lstatus != NC_NOERR)
#line 932
			return lstatus;
#line 932

#line 932
		lstatus = ncx_getn_uchar_ushort(&xp, nget, value);
#line 932
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 932
			status = lstatus;
#line 932

#line 932
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 932

#line 932
		remaining -= extent;
#line 932
		if(remaining == 0)
#line 932
			break; /* normal loop exit */
#line 932
		offset += (off_t)extent;
#line 932
		value += nget;
#line 932
	}
#line 932

#line 932
	return status;
#line 932
}
#line 932


static int
#line 934
getNCvx_ushort_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 934
		 const size_t *start, size_t nelems, schar *value)
#line 934
{
#line 934
	off_t offset = NC_varoffset(ncp, varp, start);
#line 934
	size_t remaining = varp->xsz * nelems;
#line 934
	int status = NC_NOERR;
#line 934
	const void *xp;
#line 934

#line 934
	if(nelems == 0)
#line 934
		return NC_NOERR;
#line 934

#line 934
	assert(value != NULL);
#line 934

#line 934
	for(;;)
#line 934
	{
#line 934
		size_t extent = MIN(remaining, ncp->chunk);
#line 934
		size_t nget = ncx_howmany(varp->type, extent);
#line 934

#line 934
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 934
				 0, (void **)&xp);	/* cast away const */
#line 934
		if(lstatus != NC_NOERR)
#line 934
			return lstatus;
#line 934

#line 934
		lstatus = ncx_getn_ushort_schar(&xp, nget, value);
#line 934
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 934
			status = lstatus;
#line 934

#line 934
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 934

#line 934
		remaining -= extent;
#line 934
		if(remaining == 0)
#line 934
			break; /* normal loop exit */
#line 934
		offset += (off_t)extent;
#line 934
		value += nget;
#line 934
	}
#line 934

#line 934
	return status;
#line 934
}
#line 934

static int
#line 935
getNCvx_ushort_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 935
		 const size_t *start, size_t nelems, uchar *value)
#line 935
{
#line 935
	off_t offset = NC_varoffset(ncp, varp, start);
#line 935
	size_t remaining = varp->xsz * nelems;
#line 935
	int status = NC_NOERR;
#line 935
	const void *xp;
#line 935

#line 935
	if(nelems == 0)
#line 935
		return NC_NOERR;
#line 935

#line 935
	assert(value != NULL);
#line 935

#line 935
	for(;;)
#line 935
	{
#line 935
		size_t extent = MIN(remaining, ncp->chunk);
#line 935
		size_t nget = ncx_howmany(varp->type, extent);
#line 935

#line 935
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 935
				 0, (void **)&xp);	/* cast away const */
#line 935
		if(lstatus != NC_NOERR)
#line 935
			return lstatus;
#line 935

#line 935
		lstatus = ncx_getn_ushort_uchar(&xp, nget, value);
#line 935
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 935
			status = lstatus;
#line 935

#line 935
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 935

#line 935
		remaining -= extent;
#line 935
		if(remaining == 0)
#line 935
			break; /* normal loop exit */
#line 935
		offset += (off_t)extent;
#line 935
		value += nget;
#line 935
	}
#line 935

#line 935
	return status;
#line 935
}
#line 935

static int
#line 936
getNCvx_ushort_short(const NC3_INFO* ncp, const NC_var *varp,
#line 936
		 const size_t *start, size_t nelems, short *value)
#line 936
{
#line 936
	off_t offset = NC_varoffset(ncp, varp, start);
#line 936
	size_t remaining = varp->xsz * nelems;
#line 936
	int status = NC_NOERR;
#line 936
	const void *xp;
#line 936

#line 936
	if(nelems == 0)
#line 936
		return NC_NOERR;
#line 936

#line 936
	assert(value != NULL);
#line 936

#line 936
	for(;;)
#line 936
	{
#line 936
		size_t extent = MIN(remaining, ncp->chunk);
#line 936
		size_t nget = ncx_howmany(varp->type, extent);
#line 936

#line 936
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 936
				 0, (void **)&xp);	/* cast away const */
#line 936
		if(lstatus != NC_NOERR)
#line 936
			return lstatus;
#line 936

#line 936
		lstatus = ncx_getn_ushort_short(&xp, nget, value);
#line 936
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 936
			status = lstatus;
#line 936

#line 936
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 936

#line 936
		remaining -= extent;
#line 936
		if(remaining == 0)
#line 936
			break; /* normal loop exit */
#line 936
		offset += (off_t)extent;
#line 936
		value += nget;
#line 936
	}
#line 936

#line 936
	return status;
#line 936
}
#line 936

static int
#line 937
getNCvx_ushort_int(const NC3_INFO* ncp, const NC_var *varp,
#line 937
		 const size_t *start, size_t nelems, int *value)
#line 937
{
#line 937
	off_t offset = NC_varoffset(ncp, varp, start);
#line 937
	size_t remaining = varp->xsz * nelems;
#line 937
	int status = NC_NOERR;
#line 937
	const void *xp;
#line 937

#line 937
	if(nelems == 0)
#line 937
		return NC_NOERR;
#line 937

#line 937
	assert(value != NULL);
#line 937

#line 937
	for(;;)
#line 937
	{
#line 937
		size_t extent = MIN(remaining, ncp->chunk);
#line 937
		size_t nget = ncx_howmany(varp->type, extent);
#line 937

#line 937
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 937
				 0, (void **)&xp);	/* cast away const */
#line 937
		if(lstatus != NC_NOERR)
#line 937
			return lstatus;
#line 937

#line 937
		lstatus = ncx_getn_ushort_int(&xp, nget, value);
#line 937
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 937
			status = lstatus;
#line 937

#line 937
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 937

#line 937
		remaining -= extent;
#line 937
		if(remaining == 0)
#line 937
			break; /* normal loop exit */
#line 937
		offset += (off_t)extent;
#line 937
		value += nget;
#line 937
	}
#line 937

#line 937
	return status;
#line 937
}
#line 937

static int
#line 938
getNCvx_ushort_float(const NC3_INFO* ncp, const NC_var *varp,
#line 938
		 const size_t *start, size_t nelems, float *value)
#line 938
{
#line 938
	off_t offset = NC_varoffset(ncp, varp, start);
#line 938
	size_t remaining = varp->xsz * nelems;
#line 938
	int status = NC_NOERR;
#line 938
	const void *xp;
#line 938

#line 938
	if(nelems == 0)
#line 938
		return NC_NOERR;
#line 938

#line 938
	assert(value != NULL);
#line 938

#line 938
	for(;;)
#line 938
	{
#line 938
		size_t extent = MIN(remaining, ncp->chunk);
#line 938
		size_t nget = ncx_howmany(varp->type, extent);
#line 938

#line 938
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 938
				 0, (void **)&xp);	/* cast away const */
#line 938
		if(lstatus != NC_NOERR)
#line 938
			return lstatus;
#line 938

#line 938
		lstatus = ncx_getn_ushort_float(&xp, nget, value);
#line 938
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 938
			status = lstatus;
#line 938

#line 938
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 938

#line 938
		remaining -= extent;
#line 938
		if(remaining == 0)
#line 938
			break; /* normal loop exit */
#line 938
		offset += (off_t)extent;
#line 938
		value += nget;
#line 938
	}
#line 938

#line 938
	return status;
#line 938
}
#line 938

static int
#line 939
getNCvx_ushort_double(const NC3_INFO* ncp, const NC_var *varp,
#line 939
		 const size_t *start, size_t nelems, double *value)
#line 939
{
#line 939
	off_t offset = NC_varoffset(ncp, varp, start);
#line 939
	size_t remaining = varp->xsz * nelems;
#line 939
	int status = NC_NOERR;
#line 939
	const void *xp;
#line 939

#line 939
	if(nelems == 0)
#line 939
		return NC_NOERR;
#line 939

#line 939
	assert(value != NULL);
#line 939

#line 939
	for(;;)
#line 939
	{
#line 939
		size_t extent = MIN(remaining, ncp->chunk);
#line 939
		size_t nget = ncx_howmany(varp->type, extent);
#line 939

#line 939
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 939
				 0, (void **)&xp);	/* cast away const */
#line 939
		if(lstatus != NC_NOERR)
#line 939
			return lstatus;
#line 939

#line 939
		lstatus = ncx_getn_ushort_double(&xp, nget, value);
#line 939
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 939
			status = lstatus;
#line 939

#line 939
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 939

#line 939
		remaining -= extent;
#line 939
		if(remaining == 0)
#line 939
			break; /* normal loop exit */
#line 939
		offset += (off_t)extent;
#line 939
		value += nget;
#line 939
	}
#line 939

#line 939
	return status;
#line 939
}
#line 939

static int
#line 940
getNCvx_ushort_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 940
		 const size_t *start, size_t nelems, longlong *value)
#line 940
{
#line 940
	off_t offset = NC_varoffset(ncp, varp, start);
#line 940
	size_t remaining = varp->xsz * nelems;
#line 940
	int status = NC_NOERR;
#line 940
	const void *xp;
#line 940

#line 940
	if(nelems == 0)
#line 940
		return NC_NOERR;
#line 940

#line 940
	assert(value != NULL);
#line 940

#line 940
	for(;;)
#line 940
	{
#line 940
		size_t extent = MIN(remaining, ncp->chunk);
#line 940
		size_t nget = ncx_howmany(varp->type, extent);
#line 940

#line 940
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 940
				 0, (void **)&xp);	/* cast away const */
#line 940
		if(lstatus != NC_NOERR)
#line 940
			return lstatus;
#line 940

#line 940
		lstatus = ncx_getn_ushort_longlong(&xp, nget, value);
#line 940
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 940
			status = lstatus;
#line 940

#line 940
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 940

#line 940
		remaining -= extent;
#line 940
		if(remaining == 0)
#line 940
			break; /* normal loop exit */
#line 940
		offset += (off_t)extent;
#line 940
		value += nget;
#line 940
	}
#line 940

#line 940
	return status;
#line 940
}
#line 940

static int
#line 941
getNCvx_ushort_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 941
		 const size_t *start, size_t nelems, uint *value)
#line 941
{
#line 941
	off_t offset = NC_varoffset(ncp, varp, start);
#line 941
	size_t remaining = varp->xsz * nelems;
#line 941
	int status = NC_NOERR;
#line 941
	const void *xp;
#line 941

#line 941
	if(nelems == 0)
#line 941
		return NC_NOERR;
#line 941

#line 941
	assert(value != NULL);
#line 941

#line 941
	for(;;)
#line 941
	{
#line 941
		size_t extent = MIN(remaining, ncp->chunk);
#line 941
		size_t nget = ncx_howmany(varp->type, extent);
#line 941

#line 941
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 941
				 0, (void **)&xp);	/* cast away const */
#line 941
		if(lstatus != NC_NOERR)
#line 941
			return lstatus;
#line 941

#line 941
		lstatus = ncx_getn_ushort_uint(&xp, nget, value);
#line 941
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 941
			status = lstatus;
#line 941

#line 941
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 941

#line 941
		remaining -= extent;
#line 941
		if(remaining == 0)
#line 941
			break; /* normal loop exit */
#line 941
		offset += (off_t)extent;
#line 941
		value += nget;
#line 941
	}
#line 941

#line 941
	return status;
#line 941
}
#line 941

static int
#line 942
getNCvx_ushort_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 942
		 const size_t *start, size_t nelems, ulonglong *value)
#line 942
{
#line 942
	off_t offset = NC_varoffset(ncp, varp, start);
#line 942
	size_t remaining = varp->xsz * nelems;
#line 942
	int status = NC_NOERR;
#line 942
	const void *xp;
#line 942

#line 942
	if(nelems == 0)
#line 942
		return NC_NOERR;
#line 942

#line 942
	assert(value != NULL);
#line 942

#line 942
	for(;;)
#line 942
	{
#line 942
		size_t extent = MIN(remaining, ncp->chunk);
#line 942
		size_t nget = ncx_howmany(varp->type, extent);
#line 942

#line 942
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 942
				 0, (void **)&xp);	/* cast away const */
#line 942
		if(lstatus != NC_NOERR)
#line 942
			return lstatus;
#line 942

#line 942
		lstatus = ncx_getn_ushort_ulonglong(&xp, nget, value);
#line 942
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 942
			status = lstatus;
#line 942

#line 942
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 942

#line 942
		remaining -= extent;
#line 942
		if(remaining == 0)
#line 942
			break; /* normal loop exit */
#line 942
		offset += (off_t)extent;
#line 942
		value += nget;
#line 942
	}
#line 942

#line 942
	return status;
#line 942
}
#line 942

static int
#line 943
getNCvx_ushort_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 943
		 const size_t *start, size_t nelems, ushort *value)
#line 943
{
#line 943
	off_t offset = NC_varoffset(ncp, varp, start);
#line 943
	size_t remaining = varp->xsz * nelems;
#line 943
	int status = NC_NOERR;
#line 943
	const void *xp;
#line 943

#line 943
	if(nelems == 0)
#line 943
		return NC_NOERR;
#line 943

#line 943
	assert(value != NULL);
#line 943

#line 943
	for(;;)
#line 943
	{
#line 943
		size_t extent = MIN(remaining, ncp->chunk);
#line 943
		size_t nget = ncx_howmany(varp->type, extent);
#line 943

#line 943
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 943
				 0, (void **)&xp);	/* cast away const */
#line 943
		if(lstatus != NC_NOERR)
#line 943
			return lstatus;
#line 943

#line 943
		lstatus = ncx_getn_ushort_ushort(&xp, nget, value);
#line 943
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 943
			status = lstatus;
#line 943

#line 943
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 943

#line 943
		remaining -= extent;
#line 943
		if(remaining == 0)
#line 943
			break; /* normal loop exit */
#line 943
		offset += (off_t)extent;
#line 943
		value += nget;
#line 943
	}
#line 943

#line 943
	return status;
#line 943
}
#line 943


static int
#line 945
getNCvx_uint_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 945
		 const size_t *start, size_t nelems, schar *value)
#line 945
{
#line 945
	off_t offset = NC_varoffset(ncp, varp, start);
#line 945
	size_t remaining = varp->xsz * nelems;
#line 945
	int status = NC_NOERR;
#line 945
	const void *xp;
#line 945

#line 945
	if(nelems == 0)
#line 945
		return NC_NOERR;
#line 945

#line 945
	assert(value != NULL);
#line 945

#line 945
	for(;;)
#line 945
	{
#line 945
		size_t extent = MIN(remaining, ncp->chunk);
#line 945
		size_t nget = ncx_howmany(varp->type, extent);
#line 945

#line 945
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 945
				 0, (void **)&xp);	/* cast away const */
#line 945
		if(lstatus != NC_NOERR)
#line 945
			return lstatus;
#line 945

#line 945
		lstatus = ncx_getn_uint_schar(&xp, nget, value);
#line 945
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 945
			status = lstatus;
#line 945

#line 945
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 945

#line 945
		remaining -= extent;
#line 945
		if(remaining == 0)
#line 945
			break; /* normal loop exit */
#line 945
		offset += (off_t)extent;
#line 945
		value += nget;
#line 945
	}
#line 945

#line 945
	return status;
#line 945
}
#line 945

static int
#line 946
getNCvx_uint_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 946
		 const size_t *start, size_t nelems, uchar *value)
#line 946
{
#line 946
	off_t offset = NC_varoffset(ncp, varp, start);
#line 946
	size_t remaining = varp->xsz * nelems;
#line 946
	int status = NC_NOERR;
#line 946
	const void *xp;
#line 946

#line 946
	if(nelems == 0)
#line 946
		return NC_NOERR;
#line 946

#line 946
	assert(value != NULL);
#line 946

#line 946
	for(;;)
#line 946
	{
#line 946
		size_t extent = MIN(remaining, ncp->chunk);
#line 946
		size_t nget = ncx_howmany(varp->type, extent);
#line 946

#line 946
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 946
				 0, (void **)&xp);	/* cast away const */
#line 946
		if(lstatus != NC_NOERR)
#line 946
			return lstatus;
#line 946

#line 946
		lstatus = ncx_getn_uint_uchar(&xp, nget, value);
#line 946
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 946
			status = lstatus;
#line 946

#line 946
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 946

#line 946
		remaining -= extent;
#line 946
		if(remaining == 0)
#line 946
			break; /* normal loop exit */
#line 946
		offset += (off_t)extent;
#line 946
		value += nget;
#line 946
	}
#line 946

#line 946
	return status;
#line 946
}
#line 946

static int
#line 947
getNCvx_uint_short(const NC3_INFO* ncp, const NC_var *varp,
#line 947
		 const size_t *start, size_t nelems, short *value)
#line 947
{
#line 947
	off_t offset = NC_varoffset(ncp, varp, start);
#line 947
	size_t remaining = varp->xsz * nelems;
#line 947
	int status = NC_NOERR;
#line 947
	const void *xp;
#line 947

#line 947
	if(nelems == 0)
#line 947
		return NC_NOERR;
#line 947

#line 947
	assert(value != NULL);
#line 947

#line 947
	for(;;)
#line 947
	{
#line 947
		size_t extent = MIN(remaining, ncp->chunk);
#line 947
		size_t nget = ncx_howmany(varp->type, extent);
#line 947

#line 947
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 947
				 0, (void **)&xp);	/* cast away const */
#line 947
		if(lstatus != NC_NOERR)
#line 947
			return lstatus;
#line 947

#line 947
		lstatus = ncx_getn_uint_short(&xp, nget, value);
#line 947
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 947
			status = lstatus;
#line 947

#line 947
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 947

#line 947
		remaining -= extent;
#line 947
		if(remaining == 0)
#line 947
			break; /* normal loop exit */
#line 947
		offset += (off_t)extent;
#line 947
		value += nget;
#line 947
	}
#line 947

#line 947
	return status;
#line 947
}
#line 947

static int
#line 948
getNCvx_uint_int(const NC3_INFO* ncp, const NC_var *varp,
#line 948
		 const size_t *start, size_t nelems, int *value)
#line 948
{
#line 948
	off_t offset = NC_varoffset(ncp, varp, start);
#line 948
	size_t remaining = varp->xsz * nelems;
#line 948
	int status = NC_NOERR;
#line 948
	const void *xp;
#line 948

#line 948
	if(nelems == 0)
#line 948
		return NC_NOERR;
#line 948

#line 948
	assert(value != NULL);
#line 948

#line 948
	for(;;)
#line 948
	{
#line 948
		size_t extent = MIN(remaining, ncp->chunk);
#line 948
		size_t nget = ncx_howmany(varp->type, extent);
#line 948

#line 948
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 948
				 0, (void **)&xp);	/* cast away const */
#line 948
		if(lstatus != NC_NOERR)
#line 948
			return lstatus;
#line 948

#line 948
		lstatus = ncx_getn_uint_int(&xp, nget, value);
#line 948
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 948
			status = lstatus;
#line 948

#line 948
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 948

#line 948
		remaining -= extent;
#line 948
		if(remaining == 0)
#line 948
			break; /* normal loop exit */
#line 948
		offset += (off_t)extent;
#line 948
		value += nget;
#line 948
	}
#line 948

#line 948
	return status;
#line 948
}
#line 948

static int
#line 949
getNCvx_uint_float(const NC3_INFO* ncp, const NC_var *varp,
#line 949
		 const size_t *start, size_t nelems, float *value)
#line 949
{
#line 949
	off_t offset = NC_varoffset(ncp, varp, start);
#line 949
	size_t remaining = varp->xsz * nelems;
#line 949
	int status = NC_NOERR;
#line 949
	const void *xp;
#line 949

#line 949
	if(nelems == 0)
#line 949
		return NC_NOERR;
#line 949

#line 949
	assert(value != NULL);
#line 949

#line 949
	for(;;)
#line 949
	{
#line 949
		size_t extent = MIN(remaining, ncp->chunk);
#line 949
		size_t nget = ncx_howmany(varp->type, extent);
#line 949

#line 949
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 949
				 0, (void **)&xp);	/* cast away const */
#line 949
		if(lstatus != NC_NOERR)
#line 949
			return lstatus;
#line 949

#line 949
		lstatus = ncx_getn_uint_float(&xp, nget, value);
#line 949
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 949
			status = lstatus;
#line 949

#line 949
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 949

#line 949
		remaining -= extent;
#line 949
		if(remaining == 0)
#line 949
			break; /* normal loop exit */
#line 949
		offset += (off_t)extent;
#line 949
		value += nget;
#line 949
	}
#line 949

#line 949
	return status;
#line 949
}
#line 949

static int
#line 950
getNCvx_uint_double(const NC3_INFO* ncp, const NC_var *varp,
#line 950
		 const size_t *start, size_t nelems, double *value)
#line 950
{
#line 950
	off_t offset = NC_varoffset(ncp, varp, start);
#line 950
	size_t remaining = varp->xsz * nelems;
#line 950
	int status = NC_NOERR;
#line 950
	const void *xp;
#line 950

#line 950
	if(nelems == 0)
#line 950
		return NC_NOERR;
#line 950

#line 950
	assert(value != NULL);
#line 950

#line 950
	for(;;)
#line 950
	{
#line 950
		size_t extent = MIN(remaining, ncp->chunk);
#line 950
		size_t nget = ncx_howmany(varp->type, extent);
#line 950

#line 950
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 950
				 0, (void **)&xp);	/* cast away const */
#line 950
		if(lstatus != NC_NOERR)
#line 950
			return lstatus;
#line 950

#line 950
		lstatus = ncx_getn_uint_double(&xp, nget, value);
#line 950
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 950
			status = lstatus;
#line 950

#line 950
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 950

#line 950
		remaining -= extent;
#line 950
		if(remaining == 0)
#line 950
			break; /* normal loop exit */
#line 950
		offset += (off_t)extent;
#line 950
		value += nget;
#line 950
	}
#line 950

#line 950
	return status;
#line 950
}
#line 950

static int
#line 951
getNCvx_uint_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 951
		 const size_t *start, size_t nelems, longlong *value)
#line 951
{
#line 951
	off_t offset = NC_varoffset(ncp, varp, start);
#line 951
	size_t remaining = varp->xsz * nelems;
#line 951
	int status = NC_NOERR;
#line 951
	const void *xp;
#line 951

#line 951
	if(nelems == 0)
#line 951
		return NC_NOERR;
#line 951

#line 951
	assert(value != NULL);
#line 951

#line 951
	for(;;)
#line 951
	{
#line 951
		size_t extent = MIN(remaining, ncp->chunk);
#line 951
		size_t nget = ncx_howmany(varp->type, extent);
#line 951

#line 951
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 951
				 0, (void **)&xp);	/* cast away const */
#line 951
		if(lstatus != NC_NOERR)
#line 951
			return lstatus;
#line 951

#line 951
		lstatus = ncx_getn_uint_longlong(&xp, nget, value);
#line 951
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 951
			status = lstatus;
#line 951

#line 951
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 951

#line 951
		remaining -= extent;
#line 951
		if(remaining == 0)
#line 951
			break; /* normal loop exit */
#line 951
		offset += (off_t)extent;
#line 951
		value += nget;
#line 951
	}
#line 951

#line 951
	return status;
#line 951
}
#line 951

static int
#line 952
getNCvx_uint_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 952
		 const size_t *start, size_t nelems, uint *value)
#line 952
{
#line 952
	off_t offset = NC_varoffset(ncp, varp, start);
#line 952
	size_t remaining = varp->xsz * nelems;
#line 952
	int status = NC_NOERR;
#line 952
	const void *xp;
#line 952

#line 952
	if(nelems == 0)
#line 952
		return NC_NOERR;
#line 952

#line 952
	assert(value != NULL);
#line 952

#line 952
	for(;;)
#line 952
	{
#line 952
		size_t extent = MIN(remaining, ncp->chunk);
#line 952
		size_t nget = ncx_howmany(varp->type, extent);
#line 952

#line 952
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 952
				 0, (void **)&xp);	/* cast away const */
#line 952
		if(lstatus != NC_NOERR)
#line 952
			return lstatus;
#line 952

#line 952
		lstatus = ncx_getn_uint_uint(&xp, nget, value);
#line 952
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 952
			status = lstatus;
#line 952

#line 952
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 952

#line 952
		remaining -= extent;
#line 952
		if(remaining == 0)
#line 952
			break; /* normal loop exit */
#line 952
		offset += (off_t)extent;
#line 952
		value += nget;
#line 952
	}
#line 952

#line 952
	return status;
#line 952
}
#line 952

static int
#line 953
getNCvx_uint_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 953
		 const size_t *start, size_t nelems, ulonglong *value)
#line 953
{
#line 953
	off_t offset = NC_varoffset(ncp, varp, start);
#line 953
	size_t remaining = varp->xsz * nelems;
#line 953
	int status = NC_NOERR;
#line 953
	const void *xp;
#line 953

#line 953
	if(nelems == 0)
#line 953
		return NC_NOERR;
#line 953

#line 953
	assert(value != NULL);
#line 953

#line 953
	for(;;)
#line 953
	{
#line 953
		size_t extent = MIN(remaining, ncp->chunk);
#line 953
		size_t nget = ncx_howmany(varp->type, extent);
#line 953

#line 953
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 953
				 0, (void **)&xp);	/* cast away const */
#line 953
		if(lstatus != NC_NOERR)
#line 953
			return lstatus;
#line 953

#line 953
		lstatus = ncx_getn_uint_ulonglong(&xp, nget, value);
#line 953
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 953
			status = lstatus;
#line 953

#line 953
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 953

#line 953
		remaining -= extent;
#line 953
		if(remaining == 0)
#line 953
			break; /* normal loop exit */
#line 953
		offset += (off_t)extent;
#line 953
		value += nget;
#line 953
	}
#line 953

#line 953
	return status;
#line 953
}
#line 953

static int
#line 954
getNCvx_uint_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 954
		 const size_t *start, size_t nelems, ushort *value)
#line 954
{
#line 954
	off_t offset = NC_varoffset(ncp, varp, start);
#line 954
	size_t remaining = varp->xsz * nelems;
#line 954
	int status = NC_NOERR;
#line 954
	const void *xp;
#line 954

#line 954
	if(nelems == 0)
#line 954
		return NC_NOERR;
#line 954

#line 954
	assert(value != NULL);
#line 954

#line 954
	for(;;)
#line 954
	{
#line 954
		size_t extent = MIN(remaining, ncp->chunk);
#line 954
		size_t nget = ncx_howmany(varp->type, extent);
#line 954

#line 954
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 954
				 0, (void **)&xp);	/* cast away const */
#line 954
		if(lstatus != NC_NOERR)
#line 954
			return lstatus;
#line 954

#line 954
		lstatus = ncx_getn_uint_ushort(&xp, nget, value);
#line 954
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 954
			status = lstatus;
#line 954

#line 954
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 954

#line 954
		remaining -= extent;
#line 954
		if(remaining == 0)
#line 954
			break; /* normal loop exit */
#line 954
		offset += (off_t)extent;
#line 954
		value += nget;
#line 954
	}
#line 954

#line 954
	return status;
#line 954
}
#line 954


static int
#line 956
getNCvx_longlong_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 956
		 const size_t *start, size_t nelems, schar *value)
#line 956
{
#line 956
	off_t offset = NC_varoffset(ncp, varp, start);
#line 956
	size_t remaining = varp->xsz * nelems;
#line 956
	int status = NC_NOERR;
#line 956
	const void *xp;
#line 956

#line 956
	if(nelems == 0)
#line 956
		return NC_NOERR;
#line 956

#line 956
	assert(value != NULL);
#line 956

#line 956
	for(;;)
#line 956
	{
#line 956
		size_t extent = MIN(remaining, ncp->chunk);
#line 956
		size_t nget = ncx_howmany(varp->type, extent);
#line 956

#line 956
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 956
				 0, (void **)&xp);	/* cast away const */
#line 956
		if(lstatus != NC_NOERR)
#line 956
			return lstatus;
#line 956

#line 956
		lstatus = ncx_getn_longlong_schar(&xp, nget, value);
#line 956
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 956
			status = lstatus;
#line 956

#line 956
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 956

#line 956
		remaining -= extent;
#line 956
		if(remaining == 0)
#line 956
			break; /* normal loop exit */
#line 956
		offset += (off_t)extent;
#line 956
		value += nget;
#line 956
	}
#line 956

#line 956
	return status;
#line 956
}
#line 956

static int
#line 957
getNCvx_longlong_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 957
		 const size_t *start, size_t nelems, uchar *value)
#line 957
{
#line 957
	off_t offset = NC_varoffset(ncp, varp, start);
#line 957
	size_t remaining = varp->xsz * nelems;
#line 957
	int status = NC_NOERR;
#line 957
	const void *xp;
#line 957

#line 957
	if(nelems == 0)
#line 957
		return NC_NOERR;
#line 957

#line 957
	assert(value != NULL);
#line 957

#line 957
	for(;;)
#line 957
	{
#line 957
		size_t extent = MIN(remaining, ncp->chunk);
#line 957
		size_t nget = ncx_howmany(varp->type, extent);
#line 957

#line 957
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 957
				 0, (void **)&xp);	/* cast away const */
#line 957
		if(lstatus != NC_NOERR)
#line 957
			return lstatus;
#line 957

#line 957
		lstatus = ncx_getn_longlong_uchar(&xp, nget, value);
#line 957
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 957
			status = lstatus;
#line 957

#line 957
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 957

#line 957
		remaining -= extent;
#line 957
		if(remaining == 0)
#line 957
			break; /* normal loop exit */
#line 957
		offset += (off_t)extent;
#line 957
		value += nget;
#line 957
	}
#line 957

#line 957
	return status;
#line 957
}
#line 957

static int
#line 958
getNCvx_longlong_short(const NC3_INFO* ncp, const NC_var *varp,
#line 958
		 const size_t *start, size_t nelems, short *value)
#line 958
{
#line 958
	off_t offset = NC_varoffset(ncp, varp, start);
#line 958
	size_t remaining = varp->xsz * nelems;
#line 958
	int status = NC_NOERR;
#line 958
	const void *xp;
#line 958

#line 958
	if(nelems == 0)
#line 958
		return NC_NOERR;
#line 958

#line 958
	assert(value != NULL);
#line 958

#line 958
	for(;;)
#line 958
	{
#line 958
		size_t extent = MIN(remaining, ncp->chunk);
#line 958
		size_t nget = ncx_howmany(varp->type, extent);
#line 958

#line 958
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 958
				 0, (void **)&xp);	/* cast away const */
#line 958
		if(lstatus != NC_NOERR)
#line 958
			return lstatus;
#line 958

#line 958
		lstatus = ncx_getn_longlong_short(&xp, nget, value);
#line 958
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 958
			status = lstatus;
#line 958

#line 958
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 958

#line 958
		remaining -= extent;
#line 958
		if(remaining == 0)
#line 958
			break; /* normal loop exit */
#line 958
		offset += (off_t)extent;
#line 958
		value += nget;
#line 958
	}
#line 958

#line 958
	return status;
#line 958
}
#line 958

static int
#line 959
getNCvx_longlong_int(const NC3_INFO* ncp, const NC_var *varp,
#line 959
		 const size_t *start, size_t nelems, int *value)
#line 959
{
#line 959
	off_t offset = NC_varoffset(ncp, varp, start);
#line 959
	size_t remaining = varp->xsz * nelems;
#line 959
	int status = NC_NOERR;
#line 959
	const void *xp;
#line 959

#line 959
	if(nelems == 0)
#line 959
		return NC_NOERR;
#line 959

#line 959
	assert(value != NULL);
#line 959

#line 959
	for(;;)
#line 959
	{
#line 959
		size_t extent = MIN(remaining, ncp->chunk);
#line 959
		size_t nget = ncx_howmany(varp->type, extent);
#line 959

#line 959
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 959
				 0, (void **)&xp);	/* cast away const */
#line 959
		if(lstatus != NC_NOERR)
#line 959
			return lstatus;
#line 959

#line 959
		lstatus = ncx_getn_longlong_int(&xp, nget, value);
#line 959
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 959
			status = lstatus;
#line 959

#line 959
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 959

#line 959
		remaining -= extent;
#line 959
		if(remaining == 0)
#line 959
			break; /* normal loop exit */
#line 959
		offset += (off_t)extent;
#line 959
		value += nget;
#line 959
	}
#line 959

#line 959
	return status;
#line 959
}
#line 959

static int
#line 960
getNCvx_longlong_float(const NC3_INFO* ncp, const NC_var *varp,
#line 960
		 const size_t *start, size_t nelems, float *value)
#line 960
{
#line 960
	off_t offset = NC_varoffset(ncp, varp, start);
#line 960
	size_t remaining = varp->xsz * nelems;
#line 960
	int status = NC_NOERR;
#line 960
	const void *xp;
#line 960

#line 960
	if(nelems == 0)
#line 960
		return NC_NOERR;
#line 960

#line 960
	assert(value != NULL);
#line 960

#line 960
	for(;;)
#line 960
	{
#line 960
		size_t extent = MIN(remaining, ncp->chunk);
#line 960
		size_t nget = ncx_howmany(varp->type, extent);
#line 960

#line 960
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 960
				 0, (void **)&xp);	/* cast away const */
#line 960
		if(lstatus != NC_NOERR)
#line 960
			return lstatus;
#line 960

#line 960
		lstatus = ncx_getn_longlong_float(&xp, nget, value);
#line 960
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 960
			status = lstatus;
#line 960

#line 960
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 960

#line 960
		remaining -= extent;
#line 960
		if(remaining == 0)
#line 960
			break; /* normal loop exit */
#line 960
		offset += (off_t)extent;
#line 960
		value += nget;
#line 960
	}
#line 960

#line 960
	return status;
#line 960
}
#line 960

static int
#line 961
getNCvx_longlong_double(const NC3_INFO* ncp, const NC_var *varp,
#line 961
		 const size_t *start, size_t nelems, double *value)
#line 961
{
#line 961
	off_t offset = NC_varoffset(ncp, varp, start);
#line 961
	size_t remaining = varp->xsz * nelems;
#line 961
	int status = NC_NOERR;
#line 961
	const void *xp;
#line 961

#line 961
	if(nelems == 0)
#line 961
		return NC_NOERR;
#line 961

#line 961
	assert(value != NULL);
#line 961

#line 961
	for(;;)
#line 961
	{
#line 961
		size_t extent = MIN(remaining, ncp->chunk);
#line 961
		size_t nget = ncx_howmany(varp->type, extent);
#line 961

#line 961
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 961
				 0, (void **)&xp);	/* cast away const */
#line 961
		if(lstatus != NC_NOERR)
#line 961
			return lstatus;
#line 961

#line 961
		lstatus = ncx_getn_longlong_double(&xp, nget, value);
#line 961
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 961
			status = lstatus;
#line 961

#line 961
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 961

#line 961
		remaining -= extent;
#line 961
		if(remaining == 0)
#line 961
			break; /* normal loop exit */
#line 961
		offset += (off_t)extent;
#line 961
		value += nget;
#line 961
	}
#line 961

#line 961
	return status;
#line 961
}
#line 961

static int
#line 962
getNCvx_longlong_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 962
		 const size_t *start, size_t nelems, longlong *value)
#line 962
{
#line 962
	off_t offset = NC_varoffset(ncp, varp, start);
#line 962
	size_t remaining = varp->xsz * nelems;
#line 962
	int status = NC_NOERR;
#line 962
	const void *xp;
#line 962

#line 962
	if(nelems == 0)
#line 962
		return NC_NOERR;
#line 962

#line 962
	assert(value != NULL);
#line 962

#line 962
	for(;;)
#line 962
	{
#line 962
		size_t extent = MIN(remaining, ncp->chunk);
#line 962
		size_t nget = ncx_howmany(varp->type, extent);
#line 962

#line 962
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 962
				 0, (void **)&xp);	/* cast away const */
#line 962
		if(lstatus != NC_NOERR)
#line 962
			return lstatus;
#line 962

#line 962
		lstatus = ncx_getn_longlong_longlong(&xp, nget, value);
#line 962
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 962
			status = lstatus;
#line 962

#line 962
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 962

#line 962
		remaining -= extent;
#line 962
		if(remaining == 0)
#line 962
			break; /* normal loop exit */
#line 962
		offset += (off_t)extent;
#line 962
		value += nget;
#line 962
	}
#line 962

#line 962
	return status;
#line 962
}
#line 962

static int
#line 963
getNCvx_longlong_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 963
		 const size_t *start, size_t nelems, uint *value)
#line 963
{
#line 963
	off_t offset = NC_varoffset(ncp, varp, start);
#line 963
	size_t remaining = varp->xsz * nelems;
#line 963
	int status = NC_NOERR;
#line 963
	const void *xp;
#line 963

#line 963
	if(nelems == 0)
#line 963
		return NC_NOERR;
#line 963

#line 963
	assert(value != NULL);
#line 963

#line 963
	for(;;)
#line 963
	{
#line 963
		size_t extent = MIN(remaining, ncp->chunk);
#line 963
		size_t nget = ncx_howmany(varp->type, extent);
#line 963

#line 963
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 963
				 0, (void **)&xp);	/* cast away const */
#line 963
		if(lstatus != NC_NOERR)
#line 963
			return lstatus;
#line 963

#line 963
		lstatus = ncx_getn_longlong_uint(&xp, nget, value);
#line 963
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 963
			status = lstatus;
#line 963

#line 963
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 963

#line 963
		remaining -= extent;
#line 963
		if(remaining == 0)
#line 963
			break; /* normal loop exit */
#line 963
		offset += (off_t)extent;
#line 963
		value += nget;
#line 963
	}
#line 963

#line 963
	return status;
#line 963
}
#line 963

static int
#line 964
getNCvx_longlong_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 964
		 const size_t *start, size_t nelems, ulonglong *value)
#line 964
{
#line 964
	off_t offset = NC_varoffset(ncp, varp, start);
#line 964
	size_t remaining = varp->xsz * nelems;
#line 964
	int status = NC_NOERR;
#line 964
	const void *xp;
#line 964

#line 964
	if(nelems == 0)
#line 964
		return NC_NOERR;
#line 964

#line 964
	assert(value != NULL);
#line 964

#line 964
	for(;;)
#line 964
	{
#line 964
		size_t extent = MIN(remaining, ncp->chunk);
#line 964
		size_t nget = ncx_howmany(varp->type, extent);
#line 964

#line 964
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 964
				 0, (void **)&xp);	/* cast away const */
#line 964
		if(lstatus != NC_NOERR)
#line 964
			return lstatus;
#line 964

#line 964
		lstatus = ncx_getn_longlong_ulonglong(&xp, nget, value);
#line 964
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 964
			status = lstatus;
#line 964

#line 964
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 964

#line 964
		remaining -= extent;
#line 964
		if(remaining == 0)
#line 964
			break; /* normal loop exit */
#line 964
		offset += (off_t)extent;
#line 964
		value += nget;
#line 964
	}
#line 964

#line 964
	return status;
#line 964
}
#line 964

static int
#line 965
getNCvx_longlong_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 965
		 const size_t *start, size_t nelems, ushort *value)
#line 965
{
#line 965
	off_t offset = NC_varoffset(ncp, varp, start);
#line 965
	size_t remaining = varp->xsz * nelems;
#line 965
	int status = NC_NOERR;
#line 965
	const void *xp;
#line 965

#line 965
	if(nelems == 0)
#line 965
		return NC_NOERR;
#line 965

#line 965
	assert(value != NULL);
#line 965

#line 965
	for(;;)
#line 965
	{
#line 965
		size_t extent = MIN(remaining, ncp->chunk);
#line 965
		size_t nget = ncx_howmany(varp->type, extent);
#line 965

#line 965
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 965
				 0, (void **)&xp);	/* cast away const */
#line 965
		if(lstatus != NC_NOERR)
#line 965
			return lstatus;
#line 965

#line 965
		lstatus = ncx_getn_longlong_ushort(&xp, nget, value);
#line 965
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 965
			status = lstatus;
#line 965

#line 965
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 965

#line 965
		remaining -= extent;
#line 965
		if(remaining == 0)
#line 965
			break; /* normal loop exit */
#line 965
		offset += (off_t)extent;
#line 965
		value += nget;
#line 965
	}
#line 965

#line 965
	return status;
#line 965
}
#line 965


static int
#line 967
getNCvx_ulonglong_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 967
		 const size_t *start, size_t nelems, schar *value)
#line 967
{
#line 967
	off_t offset = NC_varoffset(ncp, varp, start);
#line 967
	size_t remaining = varp->xsz * nelems;
#line 967
	int status = NC_NOERR;
#line 967
	const void *xp;
#line 967

#line 967
	if(nelems == 0)
#line 967
		return NC_NOERR;
#line 967

#line 967
	assert(value != NULL);
#line 967

#line 967
	for(;;)
#line 967
	{
#line 967
		size_t extent = MIN(remaining, ncp->chunk);
#line 967
		size_t nget = ncx_howmany(varp->type, extent);
#line 967

#line 967
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 967
				 0, (void **)&xp);	/* cast away const */
#line 967
		if(lstatus != NC_NOERR)
#line 967
			return lstatus;
#line 967

#line 967
		lstatus = ncx_getn_ulonglong_schar(&xp, nget, value);
#line 967
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 967
			status = lstatus;
#line 967

#line 967
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 967

#line 967
		remaining -= extent;
#line 967
		if(remaining == 0)
#line 967
			break; /* normal loop exit */
#line 967
		offset += (off_t)extent;
#line 967
		value += nget;
#line 967
	}
#line 967

#line 967
	return status;
#line 967
}
#line 967

static int
#line 968
getNCvx_ulonglong_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 968
		 const size_t *start, size_t nelems, uchar *value)
#line 968
{
#line 968
	off_t offset = NC_varoffset(ncp, varp, start);
#line 968
	size_t remaining = varp->xsz * nelems;
#line 968
	int status = NC_NOERR;
#line 968
	const void *xp;
#line 968

#line 968
	if(nelems == 0)
#line 968
		return NC_NOERR;
#line 968

#line 968
	assert(value != NULL);
#line 968

#line 968
	for(;;)
#line 968
	{
#line 968
		size_t extent = MIN(remaining, ncp->chunk);
#line 968
		size_t nget = ncx_howmany(varp->type, extent);
#line 968

#line 968
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 968
				 0, (void **)&xp);	/* cast away const */
#line 968
		if(lstatus != NC_NOERR)
#line 968
			return lstatus;
#line 968

#line 968
		lstatus = ncx_getn_ulonglong_uchar(&xp, nget, value);
#line 968
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 968
			status = lstatus;
#line 968

#line 968
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 968

#line 968
		remaining -= extent;
#line 968
		if(remaining == 0)
#line 968
			break; /* normal loop exit */
#line 968
		offset += (off_t)extent;
#line 968
		value += nget;
#line 968
	}
#line 968

#line 968
	return status;
#line 968
}
#line 968

static int
#line 969
getNCvx_ulonglong_short(const NC3_INFO* ncp, const NC_var *varp,
#line 969
		 const size_t *start, size_t nelems, short *value)
#line 969
{
#line 969
	off_t offset = NC_varoffset(ncp, varp, start);
#line 969
	size_t remaining = varp->xsz * nelems;
#line 969
	int status = NC_NOERR;
#line 969
	const void *xp;
#line 969

#line 969
	if(nelems == 0)
#line 969
		return NC_NOERR;
#line 969

#line 969
	assert(value != NULL);
#line 969

#line 969
	for(;;)
#line 969
	{
#line 969
		size_t extent = MIN(remaining, ncp->chunk);
#line 969
		size_t nget = ncx_howmany(varp->type, extent);
#line 969

#line 969
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 969
				 0, (void **)&xp);	/* cast away const */
#line 969
		if(lstatus != NC_NOERR)
#line 969
			return lstatus;
#line 969

#line 969
		lstatus = ncx_getn_ulonglong_short(&xp, nget, value);
#line 969
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 969
			status = lstatus;
#line 969

#line 969
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 969

#line 969
		remaining -= extent;
#line 969
		if(remaining == 0)
#line 969
			break; /* normal loop exit */
#line 969
		offset += (off_t)extent;
#line 969
		value += nget;
#line 969
	}
#line 969

#line 969
	return status;
#line 969
}
#line 969

static int
#line 970
getNCvx_ulonglong_int(const NC3_INFO* ncp, const NC_var *varp,
#line 970
		 const size_t *start, size_t nelems, int *value)
#line 970
{
#line 970
	off_t offset = NC_varoffset(ncp, varp, start);
#line 970
	size_t remaining = varp->xsz * nelems;
#line 970
	int status = NC_NOERR;
#line 970
	const void *xp;
#line 970

#line 970
	if(nelems == 0)
#line 970
		return NC_NOERR;
#line 970

#line 970
	assert(value != NULL);
#line 970

#line 970
	for(;;)
#line 970
	{
#line 970
		size_t extent = MIN(remaining, ncp->chunk);
#line 970
		size_t nget = ncx_howmany(varp->type, extent);
#line 970

#line 970
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 970
				 0, (void **)&xp);	/* cast away const */
#line 970
		if(lstatus != NC_NOERR)
#line 970
			return lstatus;
#line 970

#line 970
		lstatus = ncx_getn_ulonglong_int(&xp, nget, value);
#line 970
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 970
			status = lstatus;
#line 970

#line 970
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 970

#line 970
		remaining -= extent;
#line 970
		if(remaining == 0)
#line 970
			break; /* normal loop exit */
#line 970
		offset += (off_t)extent;
#line 970
		value += nget;
#line 970
	}
#line 970

#line 970
	return status;
#line 970
}
#line 970

static int
#line 971
getNCvx_ulonglong_float(const NC3_INFO* ncp, const NC_var *varp,
#line 971
		 const size_t *start, size_t nelems, float *value)
#line 971
{
#line 971
	off_t offset = NC_varoffset(ncp, varp, start);
#line 971
	size_t remaining = varp->xsz * nelems;
#line 971
	int status = NC_NOERR;
#line 971
	const void *xp;
#line 971

#line 971
	if(nelems == 0)
#line 971
		return NC_NOERR;
#line 971

#line 971
	assert(value != NULL);
#line 971

#line 971
	for(;;)
#line 971
	{
#line 971
		size_t extent = MIN(remaining, ncp->chunk);
#line 971
		size_t nget = ncx_howmany(varp->type, extent);
#line 971

#line 971
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 971
				 0, (void **)&xp);	/* cast away const */
#line 971
		if(lstatus != NC_NOERR)
#line 971
			return lstatus;
#line 971

#line 971
		lstatus = ncx_getn_ulonglong_float(&xp, nget, value);
#line 971
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 971
			status = lstatus;
#line 971

#line 971
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 971

#line 971
		remaining -= extent;
#line 971
		if(remaining == 0)
#line 971
			break; /* normal loop exit */
#line 971
		offset += (off_t)extent;
#line 971
		value += nget;
#line 971
	}
#line 971

#line 971
	return status;
#line 971
}
#line 971

static int
#line 972
getNCvx_ulonglong_double(const NC3_INFO* ncp, const NC_var *varp,
#line 972
		 const size_t *start, size_t nelems, double *value)
#line 972
{
#line 972
	off_t offset = NC_varoffset(ncp, varp, start);
#line 972
	size_t remaining = varp->xsz * nelems;
#line 972
	int status = NC_NOERR;
#line 972
	const void *xp;
#line 972

#line 972
	if(nelems == 0)
#line 972
		return NC_NOERR;
#line 972

#line 972
	assert(value != NULL);
#line 972

#line 972
	for(;;)
#line 972
	{
#line 972
		size_t extent = MIN(remaining, ncp->chunk);
#line 972
		size_t nget = ncx_howmany(varp->type, extent);
#line 972

#line 972
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 972
				 0, (void **)&xp);	/* cast away const */
#line 972
		if(lstatus != NC_NOERR)
#line 972
			return lstatus;
#line 972

#line 972
		lstatus = ncx_getn_ulonglong_double(&xp, nget, value);
#line 972
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 972
			status = lstatus;
#line 972

#line 972
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 972

#line 972
		remaining -= extent;
#line 972
		if(remaining == 0)
#line 972
			break; /* normal loop exit */
#line 972
		offset += (off_t)extent;
#line 972
		value += nget;
#line 972
	}
#line 972

#line 972
	return status;
#line 972
}
#line 972

static int
#line 973
getNCvx_ulonglong_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 973
		 const size_t *start, size_t nelems, longlong *value)
#line 973
{
#line 973
	off_t offset = NC_varoffset(ncp, varp, start);
#line 973
	size_t remaining = varp->xsz * nelems;
#line 973
	int status = NC_NOERR;
#line 973
	const void *xp;
#line 973

#line 973
	if(nelems == 0)
#line 973
		return NC_NOERR;
#line 973

#line 973
	assert(value != NULL);
#line 973

#line 973
	for(;;)
#line 973
	{
#line 973
		size_t extent = MIN(remaining, ncp->chunk);
#line 973
		size_t nget = ncx_howmany(varp->type, extent);
#line 973

#line 973
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 973
				 0, (void **)&xp);	/* cast away const */
#line 973
		if(lstatus != NC_NOERR)
#line 973
			return lstatus;
#line 973

#line 973
		lstatus = ncx_getn_ulonglong_longlong(&xp, nget, value);
#line 973
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 973
			status = lstatus;
#line 973

#line 973
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 973

#line 973
		remaining -= extent;
#line 973
		if(remaining == 0)
#line 973
			break; /* normal loop exit */
#line 973
		offset += (off_t)extent;
#line 973
		value += nget;
#line 973
	}
#line 973

#line 973
	return status;
#line 973
}
#line 973

static int
#line 974
getNCvx_ulonglong_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 974
		 const size_t *start, size_t nelems, uint *value)
#line 974
{
#line 974
	off_t offset = NC_varoffset(ncp, varp, start);
#line 974
	size_t remaining = varp->xsz * nelems;
#line 974
	int status = NC_NOERR;
#line 974
	const void *xp;
#line 974

#line 974
	if(nelems == 0)
#line 974
		return NC_NOERR;
#line 974

#line 974
	assert(value != NULL);
#line 974

#line 974
	for(;;)
#line 974
	{
#line 974
		size_t extent = MIN(remaining, ncp->chunk);
#line 974
		size_t nget = ncx_howmany(varp->type, extent);
#line 974

#line 974
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 974
				 0, (void **)&xp);	/* cast away const */
#line 974
		if(lstatus != NC_NOERR)
#line 974
			return lstatus;
#line 974

#line 974
		lstatus = ncx_getn_ulonglong_uint(&xp, nget, value);
#line 974
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 974
			status = lstatus;
#line 974

#line 974
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 974

#line 974
		remaining -= extent;
#line 974
		if(remaining == 0)
#line 974
			break; /* normal loop exit */
#line 974
		offset += (off_t)extent;
#line 974
		value += nget;
#line 974
	}
#line 974

#line 974
	return status;
#line 974
}
#line 974

static int
#line 975
getNCvx_ulonglong_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 975
		 const size_t *start, size_t nelems, ulonglong *value)
#line 975
{
#line 975
	off_t offset = NC_varoffset(ncp, varp, start);
#line 975
	size_t remaining = varp->xsz * nelems;
#line 975
	int status = NC_NOERR;
#line 975
	const void *xp;
#line 975

#line 975
	if(nelems == 0)
#line 975
		return NC_NOERR;
#line 975

#line 975
	assert(value != NULL);
#line 975

#line 975
	for(;;)
#line 975
	{
#line 975
		size_t extent = MIN(remaining, ncp->chunk);
#line 975
		size_t nget = ncx_howmany(varp->type, extent);
#line 975

#line 975
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 975
				 0, (void **)&xp);	/* cast away const */
#line 975
		if(lstatus != NC_NOERR)
#line 975
			return lstatus;
#line 975

#line 975
		lstatus = ncx_getn_ulonglong_ulonglong(&xp, nget, value);
#line 975
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 975
			status = lstatus;
#line 975

#line 975
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 975

#line 975
		remaining -= extent;
#line 975
		if(remaining == 0)
#line 975
			break; /* normal loop exit */
#line 975
		offset += (off_t)extent;
#line 975
		value += nget;
#line 975
	}
#line 975

#line 975
	return status;
#line 975
}
#line 975

static int
#line 976
getNCvx_ulonglong_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 976
		 const size_t *start, size_t nelems, ushort *value)
#line 976
{
#line 976
	off_t offset = NC_varoffset(ncp, varp, start);
#line 976
	size_t remaining = varp->xsz * nelems;
#line 976
	int status = NC_NOERR;
#line 976
	const void *xp;
#line 976

#line 976
	if(nelems == 0)
#line 976
		return NC_NOERR;
#line 976

#line 976
	assert(value != NULL);
#line 976

#line 976
	for(;;)
#line 976
	{
#line 976
		size_t extent = MIN(remaining, ncp->chunk);
#line 976
		size_t nget = ncx_howmany(varp->type, extent);
#line 976

#line 976
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 976
				 0, (void **)&xp);	/* cast away const */
#line 976
		if(lstatus != NC_NOERR)
#line 976
			return lstatus;
#line 976

#line 976
		lstatus = ncx_getn_ulonglong_ushort(&xp, nget, value);
#line 976
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 976
			status = lstatus;
#line 976

#line 976
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 976

#line 976
		remaining -= extent;
#line 976
		if(remaining == 0)
#line 976
			break; /* normal loop exit */
#line 976
		offset += (off_t)extent;
#line 976
		value += nget;
#line 976
	}
#line 976

#line 976
	return status;
#line 976
}
#line 976


#line 979
#ifdef NOTUSED
static int
#line 980
getNCvx_schar_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 980
		 const size_t *start, size_t nelems, uchar *value)
#line 980
{
#line 980
	off_t offset = NC_varoffset(ncp, varp, start);
#line 980
	size_t remaining = varp->xsz * nelems;
#line 980
	int status = NC_NOERR;
#line 980
	const void *xp;
#line 980

#line 980
	if(nelems == 0)
#line 980
		return NC_NOERR;
#line 980

#line 980
	assert(value != NULL);
#line 980

#line 980
	for(;;)
#line 980
	{
#line 980
		size_t extent = MIN(remaining, ncp->chunk);
#line 980
		size_t nget = ncx_howmany(varp->type, extent);
#line 980

#line 980
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 980
				 0, (void **)&xp);	/* cast away const */
#line 980
		if(lstatus != NC_NOERR)
#line 980
			return lstatus;
#line 980

#line 980
		lstatus = ncx_getn_schar_uchar(&xp, nget, value);
#line 980
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 980
			status = lstatus;
#line 980

#line 980
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 980

#line 980
		remaining -= extent;
#line 980
		if(remaining == 0)
#line 980
			break; /* normal loop exit */
#line 980
		offset += (off_t)extent;
#line 980
		value += nget;
#line 980
	}
#line 980

#line 980
	return status;
#line 980
}
#line 980

#endif /*NOTUSED*/

/*
 *  For ncvar{put,get},
 *  find the largest contiguous block from within 'edges'.
 *  returns the index to the left of this (which may be -1).
 *  Compute the number of contiguous elements and return
 *  that in *iocountp.
 *  The presence of "record" variables makes this routine
 *  overly subtle.
 */
static int
NCiocount(const NC3_INFO* const ncp, const NC_var *const varp,
	const size_t *const edges,
	size_t *const iocountp)
{
	const size_t *edp0 = edges;
	const size_t *edp = edges + varp->ndims;
	const size_t *shp = varp->shape + varp->ndims;

	if(IS_RECVAR(varp))
	{
		if(varp->ndims == 1 && ncp->recsize <= varp->len)
		{
			/* one dimensional && the only 'record' variable */
			*iocountp = *edges;
			return(0);
		}
		/* else */
		edp0++;
	}

	assert(edges != NULL);

	/* find max contiguous */
	while(edp > edp0)
	{
		shp--; edp--;
		if(*edp < *shp )
		{
			const size_t *zedp = edp;
			while(zedp >= edp0)
			{
				if(*zedp == 0)
				{
					*iocountp = 0;
					goto done;
				}
				/* Tip of the hat to segmented architectures */
				if(zedp == edp0)
					break;
				zedp--;
			}
			break;
		}
		assert(*edp == *shp);
	}

	/*
	 * edp, shp reference rightmost index s.t. *(edp +1) == *(shp +1)
	 *
	 * Or there is only one dimension.
	 * If there is only one dimension and it is 'non record' dimension,
	 * 	edp is &edges[0] and we will return -1.
	 * If there is only one dimension and and it is a "record dimension",
	 *	edp is &edges[1] (out of bounds) and we will return 0;
	 */
	assert(shp >= varp->shape + varp->ndims -1
		|| *(edp +1) == *(shp +1));

	/* now accumulate max count for a single io operation */
	for(*iocountp = 1, edp0 = edp;
		 	edp0 < edges + varp->ndims;
			edp0++)
	{
		*iocountp *= *edp0;
	}

done:
	return((int)(edp - edges) - 1);
}


/*
 * Set the elements of the array 'upp' to
 * the sum of the corresponding elements of
 * 'stp' and 'edp'. 'end' should be &stp[nelems].
 */
static void
set_upper(size_t *upp, /* modified on return */
	const size_t *stp,
	const size_t *edp,
	const size_t *const end)
{
	while(upp < end) {
		*upp++ = *stp++ + *edp++;
	}
}


/*
 * The infamous and oft-discussed odometer code.
 *
 * 'start[]' is the starting coordinate.
 * 'upper[]' is the upper bound s.t. start[ii] < upper[ii].
 * 'coord[]' is the register, the current coordinate value.
 * For some ii,
 * upp == &upper[ii]
 * cdp == &coord[ii]
 *
 * Running this routine increments *cdp.
 *
 * If after the increment, *cdp is equal to *upp
 * (and cdp is not the leftmost dimension),
 * *cdp is "zeroed" to the starting value and
 * we need to "carry", eg, increment one place to
 * the left.
 *
 * TODO: Some architectures hate recursion?
 * 	Reimplement non-recursively.
 */
static void
odo1(const size_t *const start, const size_t *const upper,
	size_t *const coord, /* modified on return */
	const size_t *upp,
	size_t *cdp)
{
	assert(coord <= cdp && cdp <= coord + NC_MAX_VAR_DIMS);
	assert(upper <= upp && upp <= upper + NC_MAX_VAR_DIMS);
	assert(upp - upper == cdp - coord);

	assert(*cdp <= *upp);

	(*cdp)++;
	if(cdp != coord && *cdp >= *upp)
	{
		*cdp = start[cdp - coord];
		odo1(start, upper, coord, upp -1, cdp -1);
	}
}
#ifdef _CRAYC
#pragma _CRI noinline odo1
#endif


#line 1142

/* Define a macro to allow hash on two type values */
#define CASE(nc1,nc2) (nc1*256+nc2)

static int
readNCv(const NC3_INFO* ncp, const NC_var* varp, const size_t* start,
        const size_t nelems, void* value, const nc_type memtype)
{
    int status = NC_NOERR;
    switch (CASE(varp->type,memtype)) {

    case CASE(NC_CHAR,NC_CHAR):
    case CASE(NC_CHAR,NC_UBYTE):
    return getNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
    break;
    case CASE(NC_BYTE,NC_BYTE):
        return getNCvx_schar_schar(ncp,varp,start,nelems, (schar*)value);
	break;
    case CASE(NC_BYTE,NC_UBYTE):
        if (fIsSet(ncp->flags,NC_64BIT_DATA))
            return getNCvx_schar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
        else
            /* for CDF-1 and CDF-2, NC_BYTE is treated the same type as uchar memtype */
            return getNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_BYTE,NC_SHORT):
        return getNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_BYTE,NC_INT):
        return getNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_BYTE,NC_FLOAT):
        return getNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_BYTE,NC_DOUBLE):
        return getNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_BYTE,NC_INT64):
        return getNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_BYTE,NC_UINT):
        return getNCvx_schar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_BYTE,NC_UINT64):
        return getNCvx_schar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
    	break;
    case CASE(NC_BYTE,NC_USHORT):
        return getNCvx_schar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_SHORT,NC_BYTE):
        return getNCvx_short_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_SHORT,NC_UBYTE):
        return getNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_SHORT,NC_SHORT):
        return getNCvx_short_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_SHORT,NC_INT):
        return getNCvx_short_int(ncp,varp,start,nelems,(int*)value);
	break;
   case CASE(NC_SHORT,NC_FLOAT):
        return getNCvx_short_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_SHORT,NC_DOUBLE):
        return getNCvx_short_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_SHORT,NC_INT64):
        return getNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
   	break;
    case CASE(NC_SHORT,NC_UINT):
        return getNCvx_short_uint(ncp,varp,start,nelems,(unsigned int*)value);
    	break;
    case CASE(NC_SHORT,NC_UINT64):
        return getNCvx_short_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_SHORT,NC_USHORT):
        return getNCvx_short_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_INT,NC_BYTE):
        return getNCvx_int_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_INT,NC_UBYTE):
        return getNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT,NC_SHORT):
        return getNCvx_int_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT,NC_INT):
        return getNCvx_int_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT,NC_FLOAT):
        return getNCvx_int_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT,NC_DOUBLE):
        return getNCvx_int_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT,NC_INT64):
        return getNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT,NC_UINT):
        return getNCvx_int_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT,NC_UINT64):
        return getNCvx_int_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT,NC_USHORT):
        return getNCvx_int_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_FLOAT,NC_BYTE):
        return getNCvx_float_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_FLOAT,NC_UBYTE):
        return getNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_FLOAT,NC_SHORT):
        return getNCvx_float_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_FLOAT,NC_INT):
        return getNCvx_float_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_FLOAT,NC_FLOAT):
        return getNCvx_float_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_FLOAT,NC_DOUBLE):
        return getNCvx_float_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_FLOAT,NC_INT64):
        return getNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT):
        return getNCvx_float_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT64):
        return getNCvx_float_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_FLOAT,NC_USHORT):
        return getNCvx_float_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_DOUBLE,NC_BYTE):
        return getNCvx_double_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_DOUBLE,NC_UBYTE):
        return getNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_DOUBLE,NC_SHORT):
        return getNCvx_double_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT):
        return getNCvx_double_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_DOUBLE,NC_FLOAT):
        return getNCvx_double_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_DOUBLE,NC_DOUBLE):
        return getNCvx_double_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT64):
        return getNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT):
        return getNCvx_double_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT64):
        return getNCvx_double_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_USHORT):
        return getNCvx_double_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_UBYTE,NC_UBYTE):
        return getNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UBYTE,NC_BYTE):
        return getNCvx_uchar_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_UBYTE,NC_SHORT):
        return getNCvx_uchar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UBYTE,NC_INT):
        return getNCvx_uchar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UBYTE,NC_FLOAT):
        return getNCvx_uchar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UBYTE,NC_DOUBLE):
        return getNCvx_uchar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_UBYTE,NC_INT64):
        return getNCvx_uchar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT):
        return getNCvx_uchar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT64):
        return getNCvx_uchar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UBYTE,NC_USHORT):
        return getNCvx_uchar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_USHORT,NC_BYTE):
        return getNCvx_ushort_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_USHORT,NC_UBYTE):
        return getNCvx_ushort_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_USHORT,NC_SHORT):
        return getNCvx_ushort_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_USHORT,NC_INT):
        return getNCvx_ushort_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_USHORT,NC_FLOAT):
        return getNCvx_ushort_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_USHORT,NC_DOUBLE):
        return getNCvx_ushort_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_USHORT,NC_INT64):
        return getNCvx_ushort_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_USHORT,NC_UINT):
        return getNCvx_ushort_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_USHORT,NC_UINT64):
        return getNCvx_ushort_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_USHORT,NC_USHORT):
        return getNCvx_ushort_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_UINT,NC_BYTE):
        return getNCvx_uint_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_UINT,NC_UBYTE):
        return getNCvx_uint_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT,NC_SHORT):
        return getNCvx_uint_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT,NC_INT):
        return getNCvx_uint_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT,NC_FLOAT):
        return getNCvx_uint_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT,NC_DOUBLE):
        return getNCvx_uint_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT,NC_INT64):
        return getNCvx_uint_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT,NC_UINT):
        return getNCvx_uint_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT,NC_UINT64):
        return getNCvx_uint_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT,NC_USHORT):
        return getNCvx_uint_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_INT64,NC_BYTE):
        return getNCvx_longlong_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_INT64,NC_UBYTE):
        return getNCvx_longlong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT64,NC_SHORT):
        return getNCvx_longlong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT64,NC_INT):
        return getNCvx_longlong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT64,NC_FLOAT):
        return getNCvx_longlong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT64,NC_DOUBLE):
        return getNCvx_longlong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT64,NC_INT64):
        return getNCvx_longlong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT64,NC_UINT):
        return getNCvx_longlong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT64,NC_UINT64):
        return getNCvx_longlong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT64,NC_USHORT):
        return getNCvx_longlong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_UINT64,NC_BYTE):
        return getNCvx_ulonglong_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_UINT64,NC_UBYTE):
        return getNCvx_ulonglong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT64,NC_SHORT):
        return getNCvx_ulonglong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT64,NC_INT):
        return getNCvx_ulonglong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT64,NC_FLOAT):
        return getNCvx_ulonglong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT64,NC_DOUBLE):
        return getNCvx_ulonglong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT64,NC_INT64):
        return getNCvx_ulonglong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT64,NC_UINT):
        return getNCvx_ulonglong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT64,NC_UINT64):
        return getNCvx_ulonglong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT64,NC_USHORT):
        return getNCvx_ulonglong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    default:
	return NC_EBADTYPE;
	break;
    }
    return status;
}


static int
writeNCv(NC3_INFO* ncp, const NC_var* varp, const size_t* start,
         const size_t nelems, const void* value, const nc_type memtype)
{
    int status = NC_NOERR;
    switch (CASE(varp->type,memtype)) {

    case CASE(NC_CHAR,NC_CHAR):
    case CASE(NC_CHAR,NC_UBYTE):
        return putNCvx_char_char(ncp,varp,start,nelems,(char*)value);
	break;
    case CASE(NC_BYTE,NC_BYTE):
        return putNCvx_schar_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_BYTE,NC_UBYTE):
        if (fIsSet(ncp->flags,NC_64BIT_DATA))
            return putNCvx_schar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
        else
            /* for CDF-1 and CDF-2, NC_BYTE is treated the same type as uchar memtype */
            return putNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_BYTE,NC_SHORT):
        return putNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_BYTE,NC_INT):
        return putNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_BYTE,NC_FLOAT):
        return putNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_BYTE,NC_DOUBLE):
        return putNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_BYTE,NC_INT64):
        return putNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_BYTE,NC_UINT):
        return putNCvx_schar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_BYTE,NC_UINT64):
        return putNCvx_schar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_BYTE,NC_USHORT):
        return putNCvx_schar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_SHORT,NC_BYTE):
        return putNCvx_short_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_SHORT,NC_UBYTE):
        return putNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_SHORT,NC_SHORT):
        return putNCvx_short_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_SHORT,NC_INT):
        return putNCvx_short_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_SHORT,NC_FLOAT):
        return putNCvx_short_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_SHORT,NC_DOUBLE):
        return putNCvx_short_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_SHORT,NC_INT64):
        return putNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_SHORT,NC_UINT):
        return putNCvx_short_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_SHORT,NC_UINT64):
        return putNCvx_short_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_SHORT,NC_USHORT):
        return putNCvx_short_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_INT,NC_BYTE):
        return putNCvx_int_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_INT,NC_UBYTE):
        return putNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT,NC_SHORT):
        return putNCvx_int_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT,NC_INT):
        return putNCvx_int_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT,NC_FLOAT):
        return putNCvx_int_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT,NC_DOUBLE):
        return putNCvx_int_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT,NC_INT64):
        return putNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT,NC_UINT):
        return putNCvx_int_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT,NC_UINT64):
        return putNCvx_int_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT,NC_USHORT):
        return putNCvx_int_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_FLOAT,NC_BYTE):
        return putNCvx_float_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_FLOAT,NC_UBYTE):
        return putNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_FLOAT,NC_SHORT):
        return putNCvx_float_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_FLOAT,NC_INT):
        return putNCvx_float_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_FLOAT,NC_FLOAT):
        return putNCvx_float_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_FLOAT,NC_DOUBLE):
        return putNCvx_float_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_FLOAT,NC_INT64):
        return putNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT):
        return putNCvx_float_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT64):
        return putNCvx_float_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_FLOAT,NC_USHORT):
        return putNCvx_float_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_DOUBLE,NC_BYTE):
        return putNCvx_double_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_DOUBLE,NC_UBYTE):
        return putNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_DOUBLE,NC_SHORT):
        return putNCvx_double_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT):
        return putNCvx_double_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_DOUBLE,NC_FLOAT):
        return putNCvx_double_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_DOUBLE,NC_DOUBLE):
        return putNCvx_double_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT64):
        return putNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT):
        return putNCvx_double_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT64):
        return putNCvx_double_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_USHORT):
        return putNCvx_double_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_UBYTE,NC_UBYTE):
        return putNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UBYTE,NC_BYTE):
        return putNCvx_uchar_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_UBYTE,NC_SHORT):
        return putNCvx_uchar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UBYTE,NC_INT):
        return putNCvx_uchar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UBYTE,NC_FLOAT):
        return putNCvx_uchar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UBYTE,NC_DOUBLE):
        return putNCvx_uchar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_UBYTE,NC_INT64):
        return putNCvx_uchar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT):
        return putNCvx_uchar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT64):
        return putNCvx_uchar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UBYTE,NC_USHORT):
        return putNCvx_uchar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_USHORT,NC_BYTE):
        return putNCvx_ushort_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_USHORT,NC_UBYTE):
        return putNCvx_ushort_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_USHORT,NC_SHORT):
        return putNCvx_ushort_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_USHORT,NC_INT):
        return putNCvx_ushort_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_USHORT,NC_FLOAT):
        return putNCvx_ushort_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_USHORT,NC_DOUBLE):
        return putNCvx_ushort_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_USHORT,NC_INT64):
        return putNCvx_ushort_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_USHORT,NC_UINT):
        return putNCvx_ushort_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_USHORT,NC_UINT64):
        return putNCvx_ushort_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_USHORT,NC_USHORT):
        return putNCvx_ushort_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_UINT,NC_BYTE):
        return putNCvx_uint_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_UINT,NC_UBYTE):
        return putNCvx_uint_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT,NC_SHORT):
        return putNCvx_uint_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT,NC_INT):
        return putNCvx_uint_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT,NC_FLOAT):
        return putNCvx_uint_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT,NC_DOUBLE):
        return putNCvx_uint_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT,NC_INT64):
        return putNCvx_uint_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT,NC_UINT):
        return putNCvx_uint_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT,NC_UINT64):
        return putNCvx_uint_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT,NC_USHORT):
        return putNCvx_uint_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_INT64,NC_BYTE):
        return putNCvx_longlong_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_INT64,NC_UBYTE):
        return putNCvx_longlong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT64,NC_SHORT):
        return putNCvx_longlong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT64,NC_INT):
        return putNCvx_longlong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT64,NC_FLOAT):
        return putNCvx_longlong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT64,NC_DOUBLE):
        return putNCvx_longlong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT64,NC_INT64):
        return putNCvx_longlong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT64,NC_UINT):
        return putNCvx_longlong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT64,NC_UINT64):
        return putNCvx_longlong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT64,NC_USHORT):
        return putNCvx_longlong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_UINT64,NC_BYTE):
        return putNCvx_ulonglong_schar(ncp,varp,start,nelems,(schar*)value);
	break;
    case CASE(NC_UINT64,NC_UBYTE):
        return putNCvx_ulonglong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT64,NC_SHORT):
        return putNCvx_ulonglong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT64,NC_INT):
        return putNCvx_ulonglong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT64,NC_FLOAT):
        return putNCvx_ulonglong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT64,NC_DOUBLE):
        return putNCvx_ulonglong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT64,NC_INT64):
        return putNCvx_ulonglong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT64,NC_UINT):
        return putNCvx_ulonglong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT64,NC_UINT64):
        return putNCvx_ulonglong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT64,NC_USHORT):
        return putNCvx_ulonglong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    default:
	return NC_EBADTYPE;
	break;
    }
    return status;
}

/**************************************************/

int
NC3_get_vara(int ncid, int varid,
	    const size_t *start, const size_t *edges0,
            void *value0,
	    nc_type memtype)
{
    int status = NC_NOERR;
    NC* nc;
    NC3_INFO* nc3;
    NC_var *varp;
    int ii;
    size_t iocount;
    size_t memtypelen;
    signed char* value = (signed char*) value0; /* legally allow ptr arithmetic */
    const size_t* edges = edges0; /* so we can modify for special cases */
    size_t modedges[NC_MAX_VAR_DIMS];

    status = NC_check_id(ncid, &nc);
    if(status != NC_NOERR)
        return status;
    nc3 = NC3_DATA(nc);

    if(NC_indef(nc3))
        return NC_EINDEFINE;

    status = NC_lookupvar(nc3, varid, &varp);
    if(status != NC_NOERR)
        return status;

    if(memtype == NC_NAT) memtype=varp->type;

    if(memtype == NC_CHAR && varp->type != NC_CHAR)
        return NC_ECHAR;
    else if(memtype != NC_CHAR && varp->type == NC_CHAR)
        return NC_ECHAR;

    /* If edges is NULL, then this was called from nc_get_var() */
    if(edges == NULL && varp->ndims > 0) {
	/* If this is a record variable, then we have to
           substitute the number of records into dimension 0. */
	if(varp->shape[0] == 0) {
	    (void)memcpy((void*)modedges,(void*)varp->shape,
                          sizeof(size_t)*varp->ndims);
	    modedges[0] = NC_get_numrecs(nc3);
	    edges = modedges;
	} else
	    edges = varp->shape;
    }

    status = NCcoordck(nc3, varp, start);
    if(status != NC_NOERR)
        return status;

    status = NCedgeck(nc3, varp, start, edges);
    if(status != NC_NOERR)
        return status;

    /* Get the size of the memtype */
    memtypelen = nctypelen(memtype);

    if(varp->ndims == 0) /* scalar variable */
    {
        return( readNCv(nc3, varp, start, 1, (void*)value, memtype) );
    }

    if(IS_RECVAR(varp))
    {
        if(*start + *edges > NC_get_numrecs(nc3))
            return NC_EEDGE;
        if(varp->ndims == 1 && nc3->recsize <= varp->len)
        {
            /* one dimensional && the only record variable  */
            return( readNCv(nc3, varp, start, *edges, (void*)value, memtype) );
        }
    }

    /*
     * find max contiguous
     *   and accumulate max count for a single io operation
     */
    ii = NCiocount(nc3, varp, edges, &iocount);

    if(ii == -1)
    {
        return( readNCv(nc3, varp, start, iocount, (void*)value, memtype) );
    }

    assert(ii >= 0);

    { /* inline */
    ALLOC_ONSTACK(coord, size_t, varp->ndims);
    ALLOC_ONSTACK(upper, size_t, varp->ndims);
    const size_t index = ii;

    /* copy in starting indices */
    (void) memcpy(coord, start, varp->ndims * sizeof(size_t));

    /* set up in maximum indices */
    set_upper(upper, start, edges, &upper[varp->ndims]);

    /* ripple counter */
    while(*coord < *upper)
    {
        const int lstatus = readNCv(nc3, varp, coord, iocount, (void*)value, memtype);
	if(lstatus != NC_NOERR)
        {
            if(lstatus != NC_ERANGE)
            {
                status = lstatus;
                /* fatal for the loop */
                break;
            }
            /* else NC_ERANGE, not fatal for the loop */
            if(status == NC_NOERR)
                status = lstatus;
        }
        value += (iocount * memtypelen);
        odo1(start, upper, coord, &upper[index], &coord[index]);
    }

    FREE_ONSTACK(upper);
    FREE_ONSTACK(coord);
    } /* end inline */

    return status;
}

int
NC3_put_vara(int ncid, int varid,
	    const size_t *start, const size_t *edges0,
            const void *value0,
	    nc_type memtype)
{
    int status = NC_NOERR;
    NC *nc;
    NC3_INFO* nc3;
    NC_var *varp;
    int ii;
    size_t iocount;
    size_t memtypelen;
    signed char* value = (signed char*) value0; /* legally allow ptr arithmetic */
    const size_t* edges = edges0; /* so we can modify for special cases */
    size_t modedges[NC_MAX_VAR_DIMS];

    status = NC_check_id(ncid, &nc);
    if(status != NC_NOERR)
        return status;
    nc3 = NC3_DATA(nc);

    if(NC_readonly(nc3))
        return NC_EPERM;

    if(NC_indef(nc3))
        return NC_EINDEFINE;

    status = NC_lookupvar(nc3, varid, &varp);
    if(status != NC_NOERR)
       return status; /*invalid varid */


    if(memtype == NC_NAT) memtype=varp->type;

    if(memtype == NC_CHAR && varp->type != NC_CHAR)
        return NC_ECHAR;
    else if(memtype != NC_CHAR && varp->type == NC_CHAR)
        return NC_ECHAR;

    /* Get the size of the memtype */
    memtypelen = nctypelen(memtype);

    /* If edges is NULL, then this was called from nc_get_var() */
    if(edges == NULL && varp->ndims > 0) {
	/* If this is a record variable, then we have to
           substitute the number of records into dimension 0. */
	if(varp->shape[0] == 0) {
	    (void)memcpy((void*)modedges,(void*)varp->shape,
                          sizeof(size_t)*varp->ndims);
	    modedges[0] = NC_get_numrecs(nc3);
	    edges = modedges;
	} else
	    edges = varp->shape;
    }

    status = NCcoordck(nc3, varp, start);
    if(status != NC_NOERR)
        return status;
    status = NCedgeck(nc3, varp, start, edges);
    if(status != NC_NOERR)
        return status;

    if(varp->ndims == 0) /* scalar variable */
    {
        return( writeNCv(nc3, varp, start, 1, (void*)value, memtype) );
    }

    if(IS_RECVAR(varp))
    {
        status = NCvnrecs(nc3, *start + *edges);
        if(status != NC_NOERR)
            return status;

        if(varp->ndims == 1
            && nc3->recsize <= varp->len)
        {
            /* one dimensional && the only record variable  */
            return( writeNCv(nc3, varp, start, *edges, (void*)value, memtype) );
        }
    }

    /*
     * find max contiguous
     *   and accumulate max count for a single io operation
     */
    ii = NCiocount(nc3, varp, edges, &iocount);

    if(ii == -1)
    {
        return( writeNCv(nc3, varp, start, iocount, (void*)value, memtype) );
    }

    assert(ii >= 0);

    { /* inline */
    ALLOC_ONSTACK(coord, size_t, varp->ndims);
    ALLOC_ONSTACK(upper, size_t, varp->ndims);
    const size_t index = ii;

    /* copy in starting indices */
    (void) memcpy(coord, start, varp->ndims * sizeof(size_t));

    /* set up in maximum indices */
    set_upper(upper, start, edges, &upper[varp->ndims]);

    /* ripple counter */
    while(*coord < *upper)
    {
        const int lstatus = writeNCv(nc3, varp, coord, iocount, (void*)value, memtype);
        if(lstatus != NC_NOERR)
        {
            if(lstatus != NC_ERANGE)
            {
                status = lstatus;
                /* fatal for the loop */
                break;
            }
            /* else NC_ERANGE, not fatal for the loop */
            if(status == NC_NOERR)
                status = lstatus;
        }
        value += (iocount * memtypelen);
        odo1(start, upper, coord, &upper[index], &coord[index]);
    }

    FREE_ONSTACK(upper);
    FREE_ONSTACK(coord);
    } /* end inline */

    return status;
}
